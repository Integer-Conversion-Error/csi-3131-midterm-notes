\section{Memory Management}
\subsection{9.1 Background}

\subsubsection*{Things to learn}
\begin{itemize}
    \item Explain difference between logical and physical address and role of MMU in translating addresses.
    \item Apply first-, best-, and worst-fit strategies for allocating memory contiguously.
    \item Explain distinction between internal and external fragmentation.
    \item Translate logical to physical addresses in paging system with TLB.
    \item Describe hierarchical paging, hashed paging, and inverted page tables.
    \item Describe address translation for IA-32, x86-64, and ARM v8 architectures.
\end{itemize}

\subsubsection*{Overview}
\begin{itemize}
    \item Main purpose of computer system: execute programs.
    \item Programs and data must be partially in main memory during execution.
    \item Modern systems maintain several processes in memory.
    \item Memory-management schemes vary; effectiveness depends on situation.
    \item Most algorithms require hardware support.
\end{itemize}

\subsubsection*{Introduction}
\begin{itemize}
    \item CPU shared by processes (CPU Scheduling).
    \item Improves CPU utilization and response speed.
    \item Requires keeping many processes in memory (sharing memory).
    \item Discuss various memory management ways (primitive bare-machine to paging).
    \item Each approach: advantages/disadvantages.
    \item Selection depends on hardware design.
    \item Many algorithms require hardware support; integrated hardware/OS memory management common.
\end{itemize}

\subsubsection*{Background}
\begin{itemize}
    \item Memory central to modern computer system operation.
    \item Memory: large array of bytes, each with own address.
    \item CPU fetches instructions from memory (program counter).
    \item Instructions may cause loading/storing to memory addresses.
    \item Instruction-execution cycle: fetch instruction, decode, fetch operands, execute, store results.
    \item Memory unit sees stream of addresses; doesn't know generation or purpose.
    \item Focus: sequence of memory addresses generated by running program.
    \item Issues pertinent to managing memory: basic hardware, binding symbolic/virtual addresses to physical, logical vs. physical addresses.
    \item Discussion concludes with dynamic linking and shared libraries.
\end{itemize}

\subsubsection*{Basic hardware}
\begin{itemize}
    \item Main memory and registers: only general-purpose storage CPU can access directly.
    \item Instructions/data must be in direct-access storage for CPU operation.
    \item Registers: accessible within one CPU clock cycle.
    \item Main memory: accessed via memory bus; may take many CPU cycles.
    \item Processor may stall waiting for data.
    \item Remedy: add fast memory (\textbf{cache}) between CPU and main memory (often on CPU chip).
    \item Cache management: hardware automatically speeds up memory access (no OS control).
    \item Multithreaded core can switch threads during memory stall.
    \item Concern: correct operation, protection of OS from user processes, user processes from each other.
    \item Protection by hardware (OS doesn't intervene for performance).
    \item Each process needs separate memory space for protection and concurrent execution.
    \item Protection: determine legal address range, ensure access only to legal addresses.
    \item Implementation: \textbf{base register} (smallest legal physical memory address) and \textbf{limit register} (size of range).
    \item CPU hardware compares every address generated in user mode with registers.
    \item Attempt to access OS/other user memory $\rightarrow$ trap to OS (fatal error).
    \item Prevents accidental/deliberate modification of OS/other user code/data.
    \item Base/limit registers loaded only by OS (privileged instruction, kernel mode).
    \item OS has unrestricted access to OS/user memory.
    \item Allows OS to load programs, dump on errors, access system call parameters, perform I/O, context switches.
\end{itemize}

\subsubsection*{Address binding}
\begin{itemize}
    \item Program on disk as binary executable.
    \item To run: brought into memory, placed in process context, eligible for execution.
    \item Process accesses instructions/data from memory.
    \item Terminates: memory reclaimed.
    \item Most systems: user process can reside anywhere in physical memory.
    \item User program steps before execution (optional):
    \begin{itemize}
        \item Addresses symbolic (e.g., \texttt{count}) in source program.
        \item Compiler \textbf{binds} symbolic to relocatable ("14 bytes from module start").
        \item Linker/loader binds relocatable to absolute (e.g., 74014).
        \item Each binding: mapping from one address space to another.
    \end{itemize}
    \item Binding instructions/data to memory addresses:
    \begin{itemize}
        \item \textbf{Compile time}: If process location known, \textbf{absolute code} generated.
        \item \textbf{Load time}: If process location unknown at compile time, compiler generates \textbf{relocatable code}.
        \item \textbf{Execution time}: If process can move during execution, binding delayed until run time.
    \end{itemize}
\end{itemize}

\subsubsection*{Logical versus physical address space}
\begin{itemize}
    \item Address generated by CPU: \textbf{logical address}.
    \item Address seen by memory unit (loaded into memory-address register): \textbf{physical address}.
    \item Compile/load time binding: identical logical and physical addresses.
    \item Execution-time binding: differing logical and physical addresses.
    \begin{itemize}
        \item Logical address also called \textbf{virtual address}.
        \item \textbf{Logical address space}: set of all logical addresses generated by program.
        \item \textbf{Physical address space}: set of all physical addresses corresponding to logical addresses.
    \end{itemize}
    \item Run-time mapping (virtual to physical): done by \textbf{memory-management unit (MMU)}.
    \item Simple MMU scheme: generalization of base-register.
    \begin{itemize}
        \item Base register called \textbf{relocation register}.
        \item Value in relocation register added to every address generated by user process.
    \end{itemize}
    \item User program never accesses real physical addresses.
    \item Program deals with logical addresses.
    \item Memory-mapping hardware converts logical to physical.
    \item Final location of referenced memory address determined at reference time.
    \item Two address types: logical (0 to max), physical (R+0 to R+max).
    \item Logical addresses mapped to physical before use.
    \item Concept of logical address space bound to separate physical address space: central to proper memory management.
\end{itemize}

\subsubsection*{Dynamic loading}
\begin{itemize}
    \item Traditionally: entire program and data in physical memory for execution.
    \item Process size limited by physical memory size.
    \item Better memory-space utilization: \textbf{dynamic loading}.
    \item Routine not loaded until called.
    \item All routines on disk in relocatable load format.
    \item Main program loaded, executed.
    \item When routine calls another: checks if loaded. If not, relocatable linking loader loads routine, updates address tables, passes control.
    \item Advantage: routine loaded only when needed.
    \item Useful for large code amounts handling infrequent cases (e.g., error routines).
    \item Total program size large, but portion used (loaded) much smaller.
    \item Dynamic loading: no special OS support required (user responsibility).
    \item OS may help by providing library routines for dynamic loading.
\end{itemize}

\subsubsection*{Dynamic linking and shared libraries}
\begin{itemize}
    \item \textbf{Dynamically linked libraries (DLLs)}: system libraries linked to user programs at run time.
    \item \textbf{Static linking}: system libraries combined by loader into binary program image.
    \item Dynamic linking: linking postponed until execution time (similar to dynamic loading).
    \item Usually with system libraries (e.g., standard C library).
    \item Without DLLs: each program includes copy of language library in executable image.
    \begin{itemize}
        \item Increases executable size, wastes main memory.
    \end{itemize}
    \item Second advantage of DLLs: shared among multiple processes (one instance in memory).
    \begin{itemize}
        \item Also known as \textbf{shared libraries}.
        \item Extensively used in Windows and Linux.
    \end{itemize}
    \item Program references dynamic library routine: loader locates DLL, loads if needed.
    \item Adjusts addresses referencing DLL functions to DLL's memory location.
    \item DLLs extended to library updates (bug fixes).
    \item Library replaced by new version: all referencing programs automatically use new version.
    \item Without dynamic linking: programs need relinking for new library.
    \item Version information in program/library to prevent incompatible versions.
    \item Multiple library versions loaded; program uses its version info.
    \item Minor changes: same version number. Major changes: increment number.
    \item Only programs compiled with new library version affected by incompatible changes.
    \item Programs linked before new library: continue using older.
    \item Dynamic linking/shared libraries: generally require OS help.
    \item If processes protected: OS checks if routine in another process's memory, allows multiple processes to access same addresses.
\end{itemize}

\subsubsection*{Section glossary}
\begin{tabular}{p{0.3\textwidth}p{0.7\textwidth}}
    \toprule
    \textbf{Term} & \textbf{Definition} \\
    \midrule
    \textbf{stall} & CPU state when CPU waiting for data from main memory, delays execution. \\
    \textbf{cache} & Temporary copy of data in reserved memory area to improve performance. \\
    \textbf{base register} & CPU register with starting address of an address space. Defines logical address space with limit register. \\
    \textbf{limit register} & CPU register defining size of range. Defines logical address space with base register. \\
    \textbf{bind} & Tie together. Compiler binds symbolic to relocatable address. \\
    \textbf{absolute code} & Code with bindings to absolute memory addresses. \\
    \textbf{relocatable code} & Code with bindings to memory addresses changed at loading time to reflect location in main memory. \\
    \textbf{logical address} & Address generated by CPU; translated to physical address before use. \\
    \textbf{physical address} & Actual location in physical memory of code or data. \\
    \textbf{virtual address} & Address generated by CPU; translated to physical address before use. \\
    \textbf{logical address space} & Set of all logical addresses generated by a program. \\
    \textbf{physical address space} & Set of all physical addresses generated by a program. \\
    \textbf{memory-management unit (MMU)} & Hardware component of CPU/motherboard allowing memory access. \\
    \textbf{MMU} & Hardware component of CPU/motherboard allowing memory access. \\
    \textbf{relocation register} & CPU register whose value added to every logical address to create physical address. \\
    \textbf{dynamic loading} & Loading of process routine when called, not at process start. \\
    \textbf{dynamically linked libraries (DLLs)} & System libraries linked to user programs at run time; linking postponed until execution time. \\
    \textbf{static linking} & Linking where system libraries treated like object modules, combined by loader into binary program image. \\
    \textbf{shared libraries} & Libraries loaded once, used by many processes; used in systems supporting dynamic linking. \\
    \bottomrule
\end{tabular}
