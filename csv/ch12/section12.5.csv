Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
"How does an operating system typically enable an application to access data stored on a disk, starting from the application's perspective?",By directly mapping the application's memory to disk sectors.,"Through a file name, which the file system then maps to physical disk blocks.",By using hardware-specific addresses provided directly by the application.,Applications send raw I/O commands to the disk controller.,The application manually translates file names into inode numbers.,B,"The text states, 'Application refers to data by file name. File system maps file name through directories to space allocation.'"
"In MS-DOS using the FAT file system, how does a file name primarily relate to the physical storage on disk?",The file name directly indicates the memory-mapped register of the disk controller.,"The file name is mapped to an inode number, which contains space allocation information.","The file name, via a number, indicates an entry in a file-access table that tells which disk blocks are allocated.","The first part of the file name points to a device driver, and the rest to an offset.",It uses a mount table to associate the file name with a device.,C,"The text explains, 'MS-DOS for FAT: name maps to number, indicates entry in file-access table, tells which disk blocks allocated.'"
How does the UNIX operating system typically map a file name to its physical storage allocation information?,The file name is directly converted into a major and minor device number.,"The file name is mapped to an inode number, which then contains the space-allocation information.","The file name specifies a port address, which is then looked up in a device table.",A mount table entry directly provides the disk block addresses for the file.,It relies on a separate device name space to identify the disk location.,B,"The text states, 'UNIX: name maps to inode number, inode contains space-allocation info.'"
Which characteristic describes the device naming convention in MS-DOS for FAT file systems?,Device names are fully integrated into the regular file-system name space.,Device names are resolved using a mount table lookup for path prefixes.,The first part of the file name (before a colon) identifies the hardware device.,Devices are identified by major and minor device numbers within the file name.,It uses a device table that maps file names directly to port addresses.,C,"The text specifies, 'MS-DOS for FAT: first part of file name (before colon) identifies hardware device (e.g., `C:` for primary hard disk).'"
What is a key difference in how MS-DOS (FAT) and UNIX handle their device name spaces relative to the file-system name space?,"MS-DOS integrates device names into the file system, while UNIX keeps them separate.","MS-DOS uses major/minor device numbers for all device naming, unlike UNIX.","MS-DOS has a separate device name space (due to colon separator), while UNIX incorporates it into the regular file-system name space.","UNIX uses a mount table for device naming, whereas MS-DOS relies on direct port addresses in file names.","Both systems fully integrate device names, but use different lookup mechanisms.",C,"MS-DOS has a 'Device name space separate from file-system name space (due to colon separator),' while 'UNIX: device name space incorporated in regular file-system name space.'"
"In UNIX, what is the primary function of the `mount table`?",To store inode numbers for all files on the system.,To map file names directly to physical disk block addresses.,To associate path name prefixes with specific device names.,To provide a list of all currently open file descriptors for processes.,To convert major device numbers into minor device numbers.,C,"The text states, 'UNIX uses mount table: associates path name prefixes with specific device names.' The glossary further defines it as tracking file systems and access for mounted volumes."
"When resolving a path name to a device in UNIX, what is typically found after looking up the device name itself?",The inode number for the device.,The direct memory-mapped address of the device controller.,"A `<major, minor>` device number.",The file-access table entry.,The corresponding file descriptor.,C,"The text explains, 'Lookup device name: finds `<major, minor>` device number, not inode.'"
What is the purpose of the major device number in UNIX-like systems?,"To identify the specific instance of a device (e.g., the second hard drive).",To indicate the size of the device's buffer cache.,To identify the device driver responsible for handling I/O for that device type.,To specify the hardware port address of the device controller.,To signify whether the device is block-oriented or character-oriented.,C,"The text explicitly states, 'Major device number: identifies device driver to handle I/O.'"
What is the role of the minor device number in UNIX-like systems?,"To identify the generic type of device, such as 'disk' or 'printer'.",To specify the base address in memory where the device's data is stored.,To be passed to the device driver to index into a device table for a specific device instance.,To determine the interrupt request line (IRQ) used by the device.,To indicate whether the device requires direct memory access (DMA).,C,"The text says, 'Minor device number: passed to device driver to index into device table.'"
"After obtaining the major and minor device numbers in UNIX, what information does the device-table entry typically provide?","The file system type (e.g., ext4, FAT32).",The number of disk blocks allocated to the device.,The path to the device driver's executable file.,The port address or memory-mapped address of the device controller.,"The current status of the device (e.g., busy, idle).",D,"The text states, 'Device-table entry: gives port address or memory-mapped address of device controller.'"
What flexibility do modern operating systems often provide regarding device drivers?,They require kernel recompilation for every new device added.,They load all possible device drivers at boot time regardless of connected hardware.,They allow new devices and drivers to be introduced without kernel recompilation and can load drivers on demand.,Device drivers are exclusively managed by user-space applications.,They prevent any dynamic changes to device drivers after boot.,C,The text highlights that 'New devices/drivers can be introduced without kernel recompilation' and 'Some OS load device drivers on demand.'
How might an operating system detect and load a driver for a device added *after* boot time?,By waiting for manual user input to install the driver.,The kernel inspects the device upon detecting an error related to it and loads the driver dynamically.,By performing a full system reboot to rescan all buses.,It requires the application to explicitly call a driver loading function.,"Drivers for such devices must be pre-loaded, or they cannot be used.",B,"The text states, 'Devices added after boot: detected by error, kernel inspects, loads driver dynamically.'"
What is the very first step in the life cycle of a blocking `read()` system call for an opened file?,The device driver immediately allocates kernel buffer space.,The kernel system-call code checks parameters and looks for data in the buffer cache.,The process is directly placed on a wait queue for the device.,The I/O subsystem sends a request to the device controller.,The DMA controller begins transferring data.,B,"The process begins by issuing the `read()` call, and then 'Kernel system-call code checks parameters. If data in buffer cache, data returned, I/O completed.'"
"If a physical I/O operation is required for a blocking `read()` request because the data is not in the buffer cache, what happens to the requesting process?","It continues executing, polling the device for completion.",It is terminated to free up resources.,It is removed from the run queue and placed on a wait queue for the device.,It is immediately moved to the ready queue to await CPU assignment.,It spawns a new thread to handle the I/O asynchronously.,C,"The text explains, 'Else, physical I/O performed. Process removed from run queue, placed on wait queue for device. I/O request scheduled.'"
"After receiving an I/O request from the kernel's I/O subsystem, what is a key action performed by the device driver in the context of a blocking read?",It directly transfers data to the application's address space.,It unblocks the requesting process by moving it to the ready queue.,It allocates kernel buffer space and sends commands to the device controller by writing to its registers.,It receives interrupts from the DMA controller and stores data in the buffer cache.,It updates the mount table with new device information.,C,"Step 5 states, 'Device driver allocates kernel buffer space, schedules I/O. Sends commands to device controller by writing to device-control registers.'"
"In the lifecycle of a blocking read request, what is the primary responsibility of the device controller?",To manage the system's buffer cache.,To operate the device hardware for data transfer.,To determine which device driver to load.,To place the requesting process on the wait queue.,To handle interrupts from other devices.,B,"Step 6 indicates, 'Device controller operates device hardware for data transfer.'"
"How is the completion of a data transfer from a device to kernel memory often signaled, particularly when Direct Memory Access (DMA) is used?",The device driver continuously polls the device status.,The application process checks a shared memory flag.,The DMA controller generates an interrupt upon transfer completion.,The kernel periodically checks a global status variable.,The device controller sends a direct signal to the requesting process.,C,"Step 7 mentions, 'DMA controller generates interrupt on transfer completion.'"
"Upon receiving an interrupt from a DMA controller, what is a key action taken by the correct interrupt handler?",It immediately unblocks the requesting process.,It re-schedules the I/O request for later.,"It stores the transferred data, signals the device driver, and then returns.",It reconfigures the device controller.,It modifies the major and minor device numbers.,C,"Step 8 details, 'Correct interrupt handler receives interrupt via interrupt-vector table, stores data, signals device driver, returns.'"
"After the device driver signals the kernel I/O subsystem that an I/O request has completed, what are the kernel's final steps to complete the blocking `read()`?",It terminates the process and cleans up resources.,It only updates the device's status in the device table.,It transfers data/return codes to the requesting process's address space and moves the process from the wait queue to the ready queue.,It reloads the device driver to ensure readiness for the next request.,It modifies the file system's allocation table.,C,"Step 10 outlines, 'Kernel transfers data/return codes to requesting process's address space. Moves process from wait queue to ready queue.'"
"According to the glossary, what is a `mount table`?",A physical table where hard drives are installed.,A list of all active processes and their file descriptors.,"An in-memory data structure with info about each mounted volume, tracks file systems and access.",A temporary buffer for I/O requests before they are sent to the device controller.,A table that maps interrupt requests to their respective handlers.,C,"The glossary defines 'mount table' as 'In-memory data structure with info about each mounted volume, tracks file systems and access.'"
