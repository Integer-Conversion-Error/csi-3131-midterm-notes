Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
What is the primary purpose of the STREAMS mechanism in UNIX System V?,To provide a secure encryption layer for inter-process communication.,To enable dynamic assembly of driver code pipelines.,To manage virtual memory allocation for user processes.,To facilitate distributed file system access across networks.,To optimize CPU scheduling algorithms for real-time applications.,B,"The STREAMS mechanism enables dynamic assembly of driver code pipelines, as stated in the text and glossary definition."
A 'stream' in the STREAMS mechanism represents a full-duplex connection between which two components?,A user process and a network interface card.,A device driver and a user-level process.,Kernel space and user space.,Two distinct device drivers within the kernel.,Two user-level processes for inter-process communication.,B,The text defines a stream as a 'full-duplex connection between device driver and user-level process'.
Which of the following are the fundamental architectural components of a STREAMS connection?,"Stream head, device files, and read/write system calls.","Stream head, stream modules, and driver end.","User process, kernel, and physical device.","Read queue, write queue, and message buffer.","Input buffer, output buffer, and control logic.",B,"The components listed are 'Stream head', 'Driver end', and 'Zero or more stream modules'."
What is the primary function of the 'stream head' component in a STREAMS mechanism?,Controlling the physical hardware device.,Providing modular processing functionality for data.,Interfacing directly with the user-level process.,Responding to hardware interrupts from the device.,Managing the flow of data between modules.,C,The text states the 'Stream head: interfaces with user process'.
What is the main responsibility of the 'driver end' in a STREAMS connection?,To provide a user-level interface for application programs.,To encapsulate processing logic for data transformation.,To control the actual hardware device.,To manage message exchange between adjacent queues.,To handle asynchronous I/O operations from user processes.,C,The text specifies that the 'Driver end: controls the device'.
How is data primarily transferred between components within a STREAMS connection?,Through direct memory access (DMA) operations.,Using shared memory segments between components.,Via message passing between queues.,By direct function calls between kernel modules.,Through atomic operations on shared variables.,C,The text states 'Data transfer: message passing between queues'.
How are stream modules typically added or 'pushed' onto a stream by a user process?,By modifying kernel boot parameters.,Using the `open()` system call.,Via the `ioctl()` system call.,Through an `exec()` call with specific arguments.,Automatically by the operating system upon device access.,C,Modules are 'pushed' onto a stream using `ioctl()` system call.
What is the main purpose of 'flow control' in STREAMS modules?,To ensure messages are delivered in a specific order.,To prevent queue overflow by regulating data flow.,To encrypt data messages for secure communication.,To compress data before sending it to the device.,To log all data transfers for debugging purposes.,B,The text states flow control is used 'To prevent queue overflow'.
"If a STREAMS queue does NOT support flow control, how does it typically behave when receiving messages?",It buffers messages until sufficient space becomes available.,It immediately drops any incoming messages without processing.,It accepts all messages and immediately sends them to the adjacent queue without buffering.,It signals the sending queue to pause its data transmission.,It redirects overflow messages to a system-wide error log.,C,"Without flow control, a queue 'accepts all messages, immediately sends to adjacent queue without buffering'."
How does a STREAMS queue behave when it *does* support flow control?,It accepts all messages regardless of its current buffer space.,It immediately drops messages if the adjacent queue is busy.,It buffers messages and does not accept new messages without sufficient buffer space.,It signals the user process directly to halt data transmission.,It converts all incoming messages into an unstructured byte stream before processing.,C,"With flow control, a queue 'buffers messages, does not accept messages without sufficient buffer space'."
Which system call allows a user process to write raw data directly to a STREAMS connection?,`getmsg()`,`read()`,`ioctl()`,`putmsg()`,`write()`,E,`write()`: writes raw data to stream.
"A user process wants to send a specific structured message, not just raw data, to a device via STREAMS. Which system call should it use?",`read()`,`getmsg()`,`putmsg()`,`write()`,`poll()`,C,`putmsg()`: allows user to specify a message.
"When a user process reads data from a STREAMS connection using the `read()` system call, what is typically returned by the stream head?",A structured message with header and data fields.,"An ordinary, unstructured byte stream.",A control message indicating the stream's status.,An error code if no complete message is available.,The entire content of the read queue as a single block.,B,"`read()`: stream head gets message, returns ordinary data (unstructured byte stream)."
"Which system call is used by a user process to retrieve a complete message, rather than an unstructured byte stream, from a STREAMS connection?",`write()`,`putmsg()`,`getmsg()`,`ioctl()`,`select()`,C,`getmsg()`: message returned to process.
How is STREAMS I/O generally characterized regarding its blocking behavior?,It is always synchronous and blocking for all operations.,It is always asynchronous and nonblocking.,It is asynchronous (nonblocking) except when communicating with the stream head.,"It blocks only during read operations, never during writes.","It blocks only during write operations, never during reads.",C,STREAMS I/O is asynchronous (or nonblocking) except when communicating with stream head.
Under what condition might a user process block when writing data to a STREAMS connection?,If the device driver is not yet initialized.,If the stream head has no room for the message to be copied.,If the next queue in the stream uses flow control and has no room to copy the message.,If the `write()` call is used instead of `putmsg()`.,If another user process is simultaneously reading from the same stream.,C,Writing to stream: user process blocks (if next queue uses flow control) until room to copy message.
"How does the driver end typically handle incoming data compared to the stream head, concerning flow control and blocking?",Both the driver end and stream head are designed to block if their buffers are full.,"The driver end must handle all incoming data, unlike the stream head which may block.","The stream head must handle all incoming data, unlike the driver end which may block.",Neither can block; they both always drop data if full.,"Only the stream head supports flow control, the driver end does not.",B,"Unlike stream head (may block), driver end must handle all incoming data. Drivers must support flow control."
What commonly happens if a device's internal buffer becomes full when processing data from a STREAMS connection?,The device driver automatically expands its buffer size.,The device typically drops the incoming messages.,"The stream immediately terminates, requiring re-initialization.",The user process is notified to re-send the data at a later time.,Flow control mechanisms are temporarily disabled to force data through.,B,"If device buffer full: device typically drops incoming messages (e.g., network card)."
What is cited as a major benefit of the STREAMS mechanism in UNIX systems?,It provides a robust security layer for all kernel-level I/O operations.,It eliminates the need for physical device drivers in the kernel.,"It offers a framework for modular, incremental device drivers and network protocols.",It guarantees hard real-time performance for all connected devices.,"It simplifies memory management, reducing memory footprint for I/O.",C,"Benefit of STREAMS: framework for modular, incremental device drivers and network protocols."
A key advantage of STREAMS modules is their reusability. What does this mean in practice?,Modules can be dynamically loaded and unloaded without system reboot.,A single module can be used by different streams or for different devices.,"Modules can be written in any programming language, independent of the kernel language.",Modules can automatically adapt to new hardware without modification.,"Modules can be combined into a single, monolithic driver for performance.",B,"Modules reusable by different streams/devices (e.g., networking module for Ethernet and 802.11 wireless)."
"Beyond just unstructured byte streams, what additional information does STREAMS support transfer between modules?",File permissions and ownership details.,CPU utilization metrics for each module.,Message boundaries and control information.,Process IDs and user credentials for security.,Detailed kernel stack trace data for debugging.,C,STREAMS 'Supports message boundaries and control info between modules (not just unstructured byte stream)'.
Which well-known mechanism is mentioned as being implemented using STREAMS in System V UNIX and Solaris?,Virtual memory paging.,Process scheduling algorithms.,File system journaling.,The socket mechanism.,Inter-process communication (IPC) shared memory.,D,Example: System V UNIX and Solaris implement socket mechanism using STREAMS.
