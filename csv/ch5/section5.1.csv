Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
What is the primary goal of CPU scheduling in multiprogrammed operating systems?,To minimize the number of processes in the ready queue.,To decrease the overhead of context switching.,To maximize CPU utilization.,To ensure processes complete their execution as quickly as possible.,To prioritize I/O operations over CPU execution.,C,"CPU scheduling is fundamental to multiprogrammed operating systems, with the primary goal of maximizing CPU utilization by switching the CPU among processes."
"On modern operating systems, which entities are typically scheduled by the CPU scheduler?",User-level processes.,Kernel-level threads.,Applications running in user space.,Memory pages for virtual memory.,I/O requests in the device queue.,B,"On modern operating systems, kernel-level threads are scheduled, although 'process scheduling' and 'thread scheduling' are often used interchangeably."
"In the context of process execution, what does the general terminology of scheduling a process to 'run on a CPU' imply?",The process is loaded into main memory.,The process is allocated a segment of virtual memory.,The process is running on a CPU's core.,The process is waiting for an I/O operation to complete.,The process has completed its execution.,C,A process executes on a CPU's core; general terminology of scheduling a process to 'run on a CPU' implies running on a core.
Which of the following best describes the CPU-I/O burst cycle?,A continuous period of CPU execution without any I/O operations.,"A loop of CPU execution followed by I/O wait, alternating between CPU burst and I/O burst.",A process state where only I/O operations are performed.,The time it takes for a process to switch from user mode to kernel mode.,The mechanism by which the operating system decides which process to run next.,B,"Process execution consists of a cycle of CPU execution and I/O wait, alternating between CPU burst and I/O burst."
What is characteristic of the duration of CPU bursts?,They are typically of fixed length for all processes.,"They tend to have a uniform distribution, with all lengths equally likely.","They vary and tend to have an exponential or hyperexponential frequency curve, meaning many short bursts and few long bursts.",They increase linearly with the complexity of the program.,They are always longer for I/O-bound programs than for CPU-bound programs.,C,"Durations of CPU bursts vary but tend to have an exponential or hyperexponential frequency curve (many short, few long bursts)."
How do I/O-bound programs and CPU-bound programs typically differ in their CPU burst characteristics?,"I/O-bound programs have a few long CPU bursts, while CPU-bound programs have many short CPU bursts.",Both I/O-bound and CPU-bound programs have an equal number of short and long CPU bursts.,"I/O-bound programs have many short CPU bursts, while CPU-bound programs have a few long CPU bursts.","I/O-bound programs only perform I/O bursts, and CPU-bound programs only perform CPU bursts.","CPU-bound programs primarily wait for I/O, whereas I/O-bound programs use the CPU extensively.",C,I/O-bound programs have many short CPU bursts; CPU-bound programs have a few long CPU bursts. This distribution is important for CPU-scheduling algorithms.
What is the primary responsibility of the CPU scheduler?,To manage the allocation of memory to processes.,To perform I/O operations for waiting processes.,To select a process from the ready queue to execute when the CPU becomes idle and allocate the CPU to it.,To handle system calls and interrupts from hardware devices.,To terminate processes that have completed their execution.,C,"When the CPU becomes idle, the operating system selects a process from the ready queue to execute. The CPU scheduler performs this selection and allocates the CPU to the chosen process."
Which of the following is true regarding the structure of the ready queue?,"It is always implemented as a strictly First-In, First-Out (FIFO) queue.",It must be an unordered linked list to ensure fairness.,"It can be a FIFO queue, priority queue, tree, or unordered linked list.",Its structure is fixed and cannot be changed by the operating system.,"It only stores process IDs, not full Process Control Blocks (PCBs).",C,"The ready queue is not necessarily FIFO; it can be a FIFO queue, priority queue, tree, or unordered linked list. Records in queues are generally process control blocks (PCBs)."
What information is typically stored as records in the ready queue?,Only the Process ID (PID) of the waiting processes.,The memory addresses of the process code segments.,The Process Control Blocks (PCBs) of the processes.,The historical CPU burst durations of the processes.,The I/O requests that processes are waiting for.,C,Records in queues are generally process control blocks (PCBs).
Which two circumstances allow for a scheduling choice to be made by the operating system?,"When a process switches from the running to the waiting state, or when it terminates.","When a process switches from the running to the ready state, or when a process switches from the waiting to the ready state.","When a process requests an I/O operation, or when it creates a child process.","When an interrupt occurs, or when the process requests a system call.","When a process is first admitted to the ready queue, or when it completes its first CPU burst.",B,"CPU-scheduling decisions occur under four circumstances. For circumstances where a process switches from running to ready (e.g., interrupt occurs) or from waiting to ready (e.g., I/O completion), choices exist for scheduling a new process. No choice is made when a process switches from running to waiting or terminates, as a new process *must* be selected."
"What happens when a process switches from the running to the waiting state (e.g., due to an I/O request) in terms of CPU scheduling decisions?",The OS defers the scheduling decision until the process completes its I/O.,A scheduling choice is made among multiple ready processes.,No scheduling choice is needed; a new process must be selected to run.,The process immediately switches back to the running state after a brief pause.,The CPU scheduler enters an idle state until the process returns from waiting.,C,"For circumstances where a process switches from running to waiting state (e.g., I/O request) or terminates, no scheduling choice is made; a new process must be selected, as the CPU has become idle due to the current process relinquishing it."
Under which type of scheduling does a CPU core keep a thread until it voluntarily releases the core by terminating or switching to the waiting state?,Preemptive scheduling.,Real-time scheduling.,Cooperative scheduling.,Round-robin scheduling.,Priority-based scheduling.,C,Nonpreemptive or cooperative scheduling means the CPU is allocated to a process until it releases it (terminates or switches to waiting state). The glossary defines 'cooperative' as 'A form of scheduling in which threads voluntarily move from the running state'.
What is a significant characteristic of preemptive CPU scheduling?,"It ensures that once a process starts executing, it completes its task without interruption.",The CPU can be taken away from a process even if it has not completed its current burst or voluntarily released the CPU.,It is primarily used in older operating systems due to its simplicity.,It avoids the need for context switching altogether.,It guarantees that no race conditions will occur with shared data.,B,Preemptive scheduling means the CPU can be taken away from a process. This is in contrast to nonpreemptive scheduling where the process holds the CPU until it releases it.
"Which type of CPU scheduling is predominantly used by most modern operating systems like Windows, macOS, and Linux?",Nonpreemptive scheduling.,Cooperative scheduling.,Batch scheduling.,Preemptive scheduling.,"First-Come, First-Served (FCFS) scheduling.",D,"Most modern OS (Windows, macOS, Linux, UNIX) use preemptive scheduling."
"What potential issue can arise when using preemptive scheduling, especially concerning shared data?",Increased I/O burst durations.,A reduction in overall CPU utilization.,"Race conditions, where shared data might become inconsistent due to preemption.",The inability to switch processes from running to the ready state.,Exclusive reliance on FIFO queues for process management.,C,"Preemptive scheduling can cause race conditions with shared data (e.g., one process updates, is preempted, second process reads inconsistent data)."
How do nonpreemptive kernels handle context switching compared to preemptive kernels?,"Nonpreemptive kernels allow context switches at any time, while preemptive kernels wait for system call completion.","Nonpreemptive kernels always use mutex locks, while preemptive kernels never do.","Nonpreemptive kernels wait for a system call completion or process block before context switching, ensuring simple kernel structure and consistent data, whereas preemptive kernels require mechanisms to prevent race conditions when accessing shared kernel data structures.","Nonpreemptive kernels are ideal for real-time computing, while preemptive kernels are not.","Both types of kernels handle context switching identically, but their scheduling algorithms differ.",C,"Nonpreemptive kernel: waits for system call completion or process block before context switch, ensuring simple kernel structure and consistent data. Preemptive kernel: requires mechanisms (e.g., mutex locks) to prevent race conditions when accessing shared kernel data structures."
What mechanism is typically used to prevent simultaneous use and data loss in sections of code affected by interrupts in an OS kernel?,Implementing a FIFO queue for all kernel operations.,Increasing dispatch latency to allow time for data synchronization.,Guarding the sections by disabling interrupts at entry and re-enabling them at exit.,Limiting the number of CPU-bound processes.,Switching to nonpreemptive scheduling for all kernel operations.,C,"Sections of code affected by interrupts must be guarded (e.g., disable interrupts at entry, reenable at exit) to prevent simultaneous use and data loss."
What is the role of the dispatcher in CPU scheduling?,It decides which process should run next from the ready queue.,It manages the memory allocation for processes.,It gives control of the CPU's core to the process selected by the CPU scheduler.,It handles I/O requests from running processes.,It tracks the duration of CPU and I/O bursts.,C,The dispatcher is a component of the CPU-scheduling function. It gives control of the CPU's core to the process selected by the CPU scheduler.
Which of the following is NOT a function of the dispatcher?,Switching context from one process to another.,Switching to user mode.,Jumping to the proper location in the user program to resume that program.,Selecting the next process to run from the ready queue.,Executing instructions of the chosen process immediately after context switch.,D,"The dispatcher's functions include switching context, switching to user mode, and jumping to the program's resume location. Selecting the next process is the role of the CPU scheduler, not the dispatcher."
Why should the dispatcher be designed to be very fast?,To minimize the time processes spend in the waiting state.,"Because it is invoked during every context switch, and its speed directly impacts system performance by affecting dispatch latency.",To ensure that I/O operations are completed quickly.,To prevent deadlocks in the system.,To reduce the number of CPU bursts for CPU-bound programs.,B,"The dispatcher should be fast, as it's invoked during every context switch. Its speed is critical as it contributes to dispatch latency."
What is 'dispatch latency'?,The time a process spends waiting in the ready queue.,The total time a process takes to complete its execution.,The time it takes for the dispatcher to stop one process and start another running.,The delay introduced by I/O operations.,The interval between two consecutive CPU bursts of the same process.,C,Dispatch latency is the time for the dispatcher to stop one process and start another.
What distinguishes a 'voluntary context switch' from a 'nonvoluntary context switch'?,"A voluntary switch occurs when a process terminates, while a nonvoluntary switch occurs when it requests I/O.","A voluntary switch is initiated by the operating system, while a nonvoluntary switch is initiated by the user.","A voluntary switch is when the process gives up the CPU (e.g., blocking for I/O), whereas a nonvoluntary switch is when the CPU is taken from the process (e.g., time slice expired or preemption).","A voluntary switch only happens in nonpreemptive systems, while a nonvoluntary switch only happens in preemptive systems.",There is no functional difference; they are just different terms for the same event.,C,"Voluntary context switch: process gives up CPU (e.g., blocking for I/O). Nonvoluntary context switch: CPU taken from process (e.g., time slice expired, preempted by higher-priority process)."
"According to the glossary, what is the definition of a 'CPU burst'?",A period when the CPU is idle.,A scheduling process state in which the CPU performs I/O.,A repeating loop in process execution.,A scheduling process state in which the process executes on CPU.,The time it takes for a dispatcher to switch contexts.,D,The glossary defines 'CPU burst' as 'Scheduling process state in which the process executes on CPU.'
Which term describes a form of scheduling where processes or threads are involuntarily moved from the running state?,Cooperative scheduling.,Nonpreemptive scheduling.,Batch scheduling.,Preemptive scheduling.,"First-Come, First-Served scheduling.",D,The glossary defines 'preemptive' as 'A form of scheduling in which processes or threads are involuntarily moved from the running state (by for example a timer signaling the kernel to allow the next thread to run).'
