Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
What is Peterson's solution primarily designed to address?,Memory management issues in operating systems.,The critical-section problem in concurrent programming.,Deadlock prevention in distributed systems.,Efficient data storage and retrieval.,Inter-process communication using message passing.,B,Peterson's solution is defined as a classic software-based solution to the critical-section problem.
On which types of architectures is Peterson's solution generally not guaranteed to work correctly?,Legacy single-core processors.,Embedded systems with limited memory.,Modern multi-core processors.,Mainframe computers running batch jobs.,Virtual machines in a cloud environment.,C,The text states Peterson's solution is 'Not guaranteed to work correctly on modern architectures due to reordering of `load` and `store` instructions.'
"For what reason is Peterson's solution still presented in academic contexts, despite its limitations on modern hardware?",It is the only known software-based solution.,"It provides a simple, direct solution for real-world production systems.","It illustrates complexities in designing software for mutual exclusion, progress, and bounded waiting.",It is highly efficient for large numbers of processes.,It serves as a benchmark for hardware-based solutions.,C,"The text mentions it's 'Presented for its algorithmic description and illustration of complexities in designing software for mutual exclusion, progress, and bounded waiting.'"
What is the scope of processes for which Peterson's solution is restricted?,Any number of processes.,"Exactly two processes (P0, P1).",Up to N processes where N is a small integer.,Only processes that run on different CPUs.,Processes that do not share any data.,B,"The scope of Peterson's solution is 'Restricted to two processes (P0, P1) that alternate execution between critical and remainder sections.'"
"In the notation used for Peterson's solution, if we are discussing process Pi, what does Pj represent?",The process that executed last.,The next process in a queue.,The other process (j = 1 - i).,A process that has already finished its critical section.,A placeholder for any generic process.,C,"The notation states: 'When discussing Pi, Pj denotes the other process (i.e., j = 1 - i).'"
What is the purpose of the shared 'turn' variable in Peterson's solution?,To count how many times a process has entered its critical section.,To indicate which process is currently executing in its remainder section.,To specify whose turn it is to enter the critical section.,To store a random value for process arbitration.,To signal if a deadlock has occurred.,C,The text states: '`turn`: Indicates whose turn it is to enter the critical section (`turn == i` means Pi can enter).'
What does 'flag[i] == true' signify for process Pi in Peterson's solution?,Process Pi is currently in its critical section.,Process Pi has completed its execution.,Process Pi is ready to enter its critical section.,Process Pi is currently in its remainder section.,Process Pi has encountered an error.,C,The text states: '`flag` array: Indicates if a process is ready to enter its critical section (`flag[i] == true` means Pi is ready).'
"According to Peterson's algorithm, what are the first two statements a process Pi executes when it intends to enter its critical section?",`turn = j; flag[i] = true;`,`flag[i] = false; turn = i;`,`flag[j] = true; turn = i;`,`flag[i] = true; turn = j;`,`while (flag[j] && turn == j);`,D,The algorithm for process Pi shows: `flag[i] = true; turn = j;` as the initial steps within the `while(true)` loop before the inner `while` loop.
What is the purpose of the inner `while` loop `while (flag[j] && turn == j);` in Peterson's algorithm for process Pi?,To ensure process Pi completes its remainder section.,To block process Pi if the other process Pj is also trying to enter and it's Pj's turn.,To set the 'turn' variable to Pi's identifier.,To signal that Pi is ready to exit its critical section.,To prevent deadlocks by arbitrarily assigning 'turn'.,B,"This loop causes Pi to wait. Pi waits if Pj is ready (`flag[j] == true`) AND it's Pj's turn (`turn == j`), enforcing mutual exclusion and correct turn-taking."
Which statement is executed by process Pi immediately after exiting its critical section in Peterson's algorithm?,`turn = j;`,`flag[j] = false;`,`flag[i] = false;`,`while (true);`,Re-enters the `while (flag[j] && turn == j)` loop.,C,The algorithm shows `flag[i] = false;` immediately after the critical section.
What happens if both processes (P0 and P1) attempt to enter their critical sections concurrently in Peterson's solution?,Both are immediately granted access.,"A deadlock occurs, preventing either from entering.","The 'turn' variable is set by both, and the final value determines which enters first.",They randomly decide which one enters first.,The system crashes due to a race condition.,C,"The 'Entry Mechanism' section states: 'If both processes try to enter concurrently, `turn` is set to both `i` and `j` almost simultaneously. Only one `turn` assignment will persist; the final value determines which process enters first.'"
"Under what condition can process Pi enter its critical section, according to Peterson's solution's proof of correctness for mutual exclusion?",Only if `turn == j` and `flag[j] == true`.,Only if `flag[j] == false` OR `turn == i`.,Only if both `flag[i] == true` and `flag[j] == true`.,Only if `turn` is undefined.,Only if it has priority over Pj.,B,The 'Proof of Correctness' section for 'Mutual exclusion is preserved' states: 'Pi enters critical section only if `flag[j] == false` OR `turn == i`.'
"If both P0 and P1 were somehow simultaneously in their critical sections using Peterson's solution, which of the following statements about `flag` values would be true?",`flag[0] == false` and `flag[1] == false`,"`flag[0]` could be true or false, but `flag[1]` must be true.",`flag[0] == true` and `flag[1] == true`,The `flag` array would be indeterminate.,Only one `flag` could be true at any given time.,C,"The 'Proof of Correctness' for mutual exclusion states: 'If both P0 and P1 are in critical sections, then `flag[0] == true` and `flag[1] == true`.' This is a premise for proving why it cannot happen under correct execution."
How is the progress requirement satisfied in Peterson's solution?,A process Pi is never prevented from entering its critical section.,"Pi is prevented only if Pj is also trying to enter, but Pi will eventually enter once Pj exits or its turn arrives.","Progress is guaranteed by strictly alternating turns, regardless of readiness.",Processes can only enter their critical sections at fixed time intervals.,"It's not satisfied, leading to potential starvation.",B,"The 'Progress requirement is satisfied' section explains that Pi is blocked only under specific conditions (Pj ready and it's Pj's turn), and once Pj exits its critical section or Pj sets `turn = i` upon re-entry, Pi will eventually enter."
"What is the upper bound on waiting for a process Pi to enter its critical section in Peterson's solution, assuming Pj is also contending?",Pi will enter immediately without any waiting.,"Pi will wait indefinitely, leading to starvation.",Pi will enter after at most one entry by Pj.,Pi will enter after Pj has entered its critical section an arbitrary number of times.,The waiting time is proportional to the number of available CPU cores.,C,"The 'Bounded-waiting requirement is met' section states: 'As shown above, Pi will enter after at most one entry by Pj.'"
Why do modern processors and compilers reorder read/write operations?,To intentionally break existing synchronization algorithms.,To reduce power consumption.,To improve performance by optimizing instruction execution.,To simplify debugging of multithreaded applications.,To ensure strict sequential consistency for all operations.,C,The text states: 'Processors/compilers may reorder read/write operations without data dependencies for performance.'
"In what scenario does reordering of instructions become problematic, leading to inconsistent or unexpected results?",In single-threaded applications.,In applications with purely local variables.,In multithreaded applications with shared data.,When using only integer arithmetic.,"Only during program compilation, not execution.",C,"The text explicitly states: 'For multithreaded apps with shared data, reordering can lead to inconsistent/unexpected results.'"
"Consider Thread 1: `while (!flag); print x;` and Thread 2: `x = 100; flag = true;`. If Thread 2's instructions are reordered to `flag = true; x = 100;`, what is a possible outcome for Thread 1?",Thread 1 will always print 100.,Thread 1 will print 0.,Thread 1 will cause a segmentation fault.,Thread 1 will enter an infinite loop.,Thread 1 will print a random garbage value.,B,The reordering example states: 'Thread 1 could print 0 if `flag` is set before `x` is updated.'
"How can instruction reordering specifically impact Peterson's solution, leading to a failure of its correctness properties?",It can cause the 'turn' variable to become negative.,It can make processes skip their remainder sections.,It can lead to both threads being in their critical sections simultaneously if the initial assignments are reordered.,"It only affects the performance, not the correctness, of Peterson's solution.",It prevents the 'flag' array from being initialized correctly.,C,The 'Impact on Peterson's Solution' section states: 'If the first two statements in Peterson's entry section (`flag[i] = true; turn = j;`) are reordered. It's possible for both threads to be in their critical sections simultaneously.'
What is the ultimate conclusion drawn regarding the use of Peterson's solution and similar algorithms on modern systems?,They are perfectly safe to use as-is.,They should only be used in single-threaded environments.,Proper synchronization tools are necessary to preserve mutual exclusion.,They can be fixed by simply adding more `while` loops.,They demonstrate that software-based solutions are inherently flawed.,C,The conclusion section states: 'Proper synchronization tools are necessary to preserve mutual exclusion.'
