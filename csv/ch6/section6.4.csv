Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
"Why are software-based synchronization solutions, such as Peterson's, not guaranteed on modern computer architectures?",They are too complex to implement efficiently.,They rely on specific compiler optimizations that are not universal.,"Modern architectures may reorder instructions, leading to unreliable data states.","They require excessive CPU cycles, causing performance degradation.",They are vulnerable to external hardware interrupts.,C,"The text states that software-based solutions are not guaranteed on modern architectures because systems may reorder instructions, leading to unreliable data states. This is the core problem hardware support addresses."
What is the primary problem that memory barriers are designed to solve in multi-processor systems?,Preventing deadlocks between multiple processes.,Ensuring fair access to shared resources among threads.,Addressing unreliable data states caused by instruction reordering.,Reducing context switching overhead in the operating system.,Managing cache coherency across different CPU levels.,C,"The text explicitly identifies the 'Problem' memory barriers solve as: 'Systems may reorder instructions, leading to unreliable data states.'"
"According to the text, which of the following best defines a 'memory model' in computer architecture?",A blueprint for designing memory chips.,A specification for how memory is addressed by the CPU.,The way a computer architecture guarantees memory visibility to applications.,The physical layout of RAM modules on a motherboard.,A strategy for optimizing virtual memory usage.,C,The glossary defines 'memory model' as 'How a computer architecture guarantees memory visibility to applications.'
"In a strongly ordered memory model, what is guaranteed regarding memory modifications?",Memory modifications are cached on the local processor only.,Memory modifications on one processor are immediately visible to all others.,Memory modifications are delayed until a synchronization point is reached.,Memory modifications are restricted to atomic operations.,Memory modifications are buffered before propagation.,B,The text defines a 'Strongly ordered' memory model as one where 'Memory modification on one processor is immediately visible to all others.'
What characteristic distinguishes a weakly ordered memory model from a strongly ordered one?,Memory modifications are always faster.,Memory modifications are always slower.,Memory modifications on one processor may not be immediately visible to others.,Memory modifications are globally consistent by default.,Memory modifications require explicit flushing to storage.,C,The text defines a 'Weakly ordered' memory model as one where 'Memory modifications on one processor may not be immediately visible to others.'
Why do kernel developers need to be concerned about memory modification visibility on shared-memory multiprocessors?,Because varying memory models make assumptions about visibility unreliable.,"Because memory is always strongly ordered, requiring explicit weak ordering.",Because cache memory needs to be manually invalidated.,Because all memory operations are inherently atomic.,Because memory access patterns are unpredictable.,A,"The text states, 'Kernel developers cannot assume memory modification visibility on shared-memory multiprocessors due to varying memory models.'"
What is the primary function of a memory barrier (or memory fence) instruction?,To halt all CPU operations until a specific flag is set.,To force memory changes to propagate to all other processors.,To allocate a contiguous block of memory for critical data.,To encrypt data before it is written to memory.,To provide a virtual boundary for memory protection.,B,The text defines 'Memory barriers (or memory fences)' as 'instructions that force memory changes to propagate to all other processors.'
"When a memory barrier is performed, what guarantees does it provide regarding memory operations?",All subsequent loads and stores are completed before any preceding operations.,"Only store operations are completed, not loads.",All preceding loads and stores are completed before any subsequent load or store operations.,Only operations on volatile memory are affected.,It ensures cache coherency but not memory visibility.,C,"The text states, 'When a memory barrier is performed, all preceding loads and stores are completed before any subsequent load or store operations.'"
"How can memory barriers specifically benefit shared-memory programming, even if instructions are reordered?",By automatically rolling back reordered instructions.,By ensuring store operations are completed and visible before future operations.,By increasing the speed of memory access.,By allowing threads to access memory in any order.,By reducing the number of memory accesses.,B,"The text explains the 'Benefit' as: 'Even if instructions are reordered, memory barriers ensure store operations are completed and visible before future operations.'"
"In the provided example for Thread 1 (`while (!flag) memory_barrier(); print x;`), what does the `memory_barrier()` guarantee?",`x` is printed before `flag` is loaded.,`flag` is loaded before `x` is printed.,The loop will execute only once.,The `flag` variable is always true.,`x` is assigned a value of 100.,B,The text states for this specific example: 'Guarantees `flag` is loaded before `x`.'
"In the provided example for Thread 2 (`x = 100; memory_barrier(); flag = true;`), what does the `memory_barrier()` ensure?",`flag` is set to `true` before `x` is assigned.,The assignment to `x` occurs before the assignment to `flag`.,`x` is visible to all other processors immediately.,Both assignments are executed in parallel.,The program will terminate after these statements.,B,The text states for this specific example: 'Ensures assignment to `x` occurs before assignment to `flag`.'
"Where specifically could a memory barrier be placed in Peterson's Solution to prevent instruction reordering, according to the text?",At the very beginning of the critical section.,"After the critical section, before the remainder section.",Between the first two assignment statements in the entry section.,At the end of the remainder section.,Inside the `while` loop condition.,C,The text suggests placing a memory barrier 'between the first two assignment statements in the entry section' of Peterson's Solution.
What is a characteristic of memory barriers regarding their typical usage?,They are high-level operations for general application developers.,They are primarily used for debugging memory leaks.,"They are low-level operations, typically used by kernel developers.",They are used to manage virtual memory paging.,They are implemented solely in software.,C,"The text states: 'Memory barriers are low-level operations, typically used by kernel developers for specialized mutual exclusion code.'"
What does it mean for a computer activity or CPU instruction to operate 'atomically'?,It can be interrupted by other processes.,It operates as one uninterruptible unit.,It is executed in parallel across multiple cores.,It only involves operations on single bits.,It consumes minimal power.,B,The glossary defines 'atomically' as 'A computer activity (such as a CPU instruction) that operates as one uninterruptable unit.'
What is the primary benefit of modern systems providing special hardware instructions like `test_and_set()` and `compare_and_swap()`?,They reduce the amount of physical memory required.,They simplify critical-section problem solving.,They enhance network communication speeds.,They provide stronger encryption for data.,They enable faster file system operations.,B,"The text states, 'These instructions simplify critical-section problem solving.'"
"Consider the definition of `test_and_set(boolean *target)`. What value is returned by this function, and what value is assigned to `*target`?","Returns `true`, sets `*target` to `false`.","Returns the new value of `*target` (which is `true`), sets `*target` to `true`.","Returns the original value of `*target`, sets `*target` to `true`.","Returns `false`, sets `*target` to the original value.","Returns `true` if `*target` was `false`, otherwise `false`, sets `*target` to `true`.",C,"The provided definition of `test_and_set` shows `boolean rv = *target; *target = true; return rv;`. This means it saves the original value to `rv`, sets `*target` to `true`, and then returns the saved original value."
"If two `test_and_set()` instructions attempt to run simultaneously on different cores, how do they behave?","They both execute in parallel, leading to a race condition.",They are both aborted by the operating system.,They execute sequentially in an arbitrary order.,"Only one is allowed to execute, the other is discarded.","They deadlock, preventing further execution.",C,"The text states, 'If two `test_and_set()` instructions run simultaneously (on different cores), they execute sequentially in an arbitrary order.' This is a characteristic of atomic operations."
"In the `test_and_set()` based mutual exclusion implementation, what is the purpose of the `while (test_and_set(&lock))` loop?",To acquire the lock and enter the critical section.,To release the lock after exiting the critical section.,To repeatedly attempt to acquire the lock until successful.,To verify that the lock is still held by the current process.,To initialize the `lock` variable to `false`.,C,"The `while (test_and_set(&lock))` loop causes a process to busy-wait, repeatedly trying to set `lock` to `true`. If `test_and_set` returns `true` (meaning `lock` was already `true`), the loop continues. If it returns `false` (meaning `lock` was `false` and is now set to `true`), the loop terminates, and the process enters the critical section. Thus, it repeatedly attempts to acquire the lock."
How many operands does the `compare_and_swap()` (CAS) instruction operate on atomically?,One,Two,Three,Four,Zero,C,"The text states, 'Operates on three operands atomically.' (value, expected, new_value)"
"Based on the definition of `compare_and_swap(int *value, int expected, int new_value)`, under what condition is `*value` modified to `new_value`?","Always, regardless of `expected`.",Only if `*value` is `0`.,Only if `*value` is NOT equal to `expected`.,Only if `*value` is equal to `expected`.,Only if `new_value` is `0`.,D,"The definition states: `if (*value == expected) *value = new_value;`, meaning `*value` is set to `new_value` ONLY if `(*value == expected)` is true."
What value does the `compare_and_swap()` instruction always return?,The `new_value`.,The `expected` value.,The original value of `value`.,"`0` if successful, `1` otherwise.",A boolean indicating success or failure.,C,"The definition of `compare_and_swap` shows `int temp = *value; ... return temp;`, which means it always returns the original value of `value`."
"Similar to `test_and_set()`, how do two `compare_and_swap()` instructions behave if they run simultaneously?","They both succeed, possibly leading to incorrect state.",They execute sequentially.,They cause a system crash.,"The one that arrived first is executed, the other is ignored.","They attempt to acquire the same lock, resulting in a deadlock.",B,"The text states, 'If two CAS instructions run simultaneously, they execute sequentially.' This is due to their atomic nature."
What is a known limitation of the basic `compare_and_swap()` mutual exclusion algorithm (without the `waiting` array)?,It does not guarantee mutual exclusion.,It consumes excessive CPU resources.,It does not satisfy the bounded-waiting requirement.,It is prone to livelock situations.,It can only be used by two processes.,C,The text explicitly states: 'Limitation: This basic algorithm satisfies mutual exclusion but NOT bounded waiting.'
"In the CAS-based mutual exclusion algorithm with bounded waiting, when does process $P_i$ enter the critical section?",Only if `lock` is 1 and `waiting[i]` is true.,Only if `waiting[i]` is `false` OR `key` is `0`.,"When `key` is 1, regardless of `waiting[i]`.",After `j` has cyclically scanned all other processes.,"When `compare_and_swap(&lock, 0, 1)` returns 1.",B,The 'Mutual Exclusion Proof' section states: '$P_i$ enters the critical section only if `waiting[i] == false || key == 0`.'
"In the CAS-based mutual exclusion with bounded waiting, when a process leaves its critical section, what mechanism ensures progress for other waiting processes?",It automatically broadcasts a signal to all processes.,"It immediately sets `lock` to 0, allowing the next process to contend.","It cyclically scans the `waiting` array and sets `waiting[j]` to `false` for the next process, or sets `lock` to 0.",It increments a global counter which then allows the next process.,It clears all `waiting` array elements.,C,The 'Process $P_i$ structure' and 'Progress Proof' show that a process exiting the critical section either sets `lock = 0` (if no one is waiting) or finds the next waiting process by cyclically scanning `waiting` array and sets `waiting[j]` to `false`.
What is the maximum number of turns a waiting process will take to enter its critical section in the CAS-based algorithm with bounded waiting?,1 turn.,2 turns.,"$n$ turns, where $n$ is the total number of processes.",$n-1$ turns.,An unbounded number of turns.,D,The 'Bounded-Waiting Proof' states: 'Any waiting process will enter its critical section within $n-1$ turns.'
"On Intel x86 architecture, which assembly instruction implements `compare_and_swap()`, and what prefix is used to enforce atomic execution?","`MOV`, `REP`","`XCHG`, `NOP`","`CMPXCHG`, `LOCK`","`PUSH`, `POP`","`LEA`, `VOLATILE`",C,The text specifies: 'Intel x86 Architecture: `cmpxchg` assembly instruction implements `compare_and_swap()`' and '`lock` prefix used to enforce atomic execution by locking the bus during destination operand update.'
For what primary purpose is `compare_and_swap()` often used as a building block rather than directly for general mutual exclusion?,To implement file system journaling.,To create more abstract synchronization tools.,To optimize network packet processing.,To manage virtual memory allocation.,To control CPU clock speed.,B,"The text states: '`compare_and_swap()` is often a building block for other synchronization tools, not used directly for mutual exclusion.'"
What is the definition of an 'atomic variable'?,A variable whose value can only be 0 or 1.,A variable that stores information about CPU atoms.,A programming language construct providing atomic operations on basic data types.,A variable that is accessible only by a single thread.,A variable used for cryptographic purposes.,C,The glossary defines 'atomic variable' as 'A programming language construct that provides atomic operations on basic data types such as integers and booleans.'
What specific type of race condition are atomic variables primarily designed to solve?,Deadlocks involving multiple resources.,"Ensuring mutual exclusion for single variable updates, like counter increments.",Orchestrating complex multi-threaded algorithms.,Managing distributed consensus across nodes.,Preventing starvation in priority-based scheduling.,B,"The text states their 'Purpose': 'Ensures mutual exclusion for single variable updates (e.g., counter increments) where data races might occur.'"
"The provided `increment()` function for an atomic integer (`atomic_int *v`) uses a `do-while` loop structure. What condition must be met for the loop to terminate, indicating a successful atomic increment?",`temp` becomes equal to `v`.,"`compare_and_swap(v, temp, temp+1)` returns `temp+1`.","`temp` is not equal to `compare_and_swap(v, temp, temp+1)`.","`temp` is equal to `compare_and_swap(v, temp, temp+1)`.",The loop runs for a fixed number of iterations.,D,"The loop condition is `while (temp != compare_and_swap(v, temp, temp+1));`. The loop *continues* as long as `temp` is *not* equal to the return value of `compare_and_swap`. The `compare_and_swap` returns the *original* value of `*v`. If `compare_and_swap` succeeds, it means `*v` was `temp` at the moment of the operation, so it will return `temp`. Thus, the loop terminates when `temp == compare_and_swap(v, temp, temp+1)`."
"While atomic variables provide atomic updates, what is a general limitation regarding their ability to solve all race conditions?",They are slower than non-atomic operations.,They cannot be used with boolean data types.,"They don't solve race conditions involving multiple, related shared data accesses that need to be grouped together.",They introduce new types of deadlocks.,They are only supported on single-core processors.,C,"The text states: 'Atomic variables provide atomic updates but don't solve all race conditions.' The Bounded-Buffer Problem example illustrates this, showing that even if a counter is updated atomically, a sequence of operations that rely on that counter's state might still suffer a race condition if they are not themselves atomic as a group."
"In the Bounded-Buffer Problem example, how can the use of an atomic `count` variable still lead to a race condition (e.g., two consumers proceeding with only one item)?",The `increment()` function is not truly atomic.,"Atomic variables are only for integers, not buffer management.","The problem arises because the decision to proceed (`count > 0`) is separate from the consumption action, allowing multiple consumers to pass the check before the buffer state reflects the first consumer's action.",The producer's actions are not atomic.,"The `count` variable can only be decremented, not incremented.",C,"The text describes this scenario: 'Both consumers could exit their `while` loops and proceed to consume, even though `count` is only 1.' This happens because the check (`count > 0`) is atomic, but the sequence of operations including the actual consumption is not, leading to a race if multiple consumers observe `count=1` before one decrements it."
For what kind of applications are atomic variables commonly used?,Complex database transactions.,Distributed ledger technologies.,Single updates of shared data like counters and sequence generators.,Graphical user interface rendering.,Network routing protocols.,C,"The text states their 'Usage': 'Commonly used in OS and concurrent applications, but often limited to single updates of shared data (counters, sequence generators).'"
