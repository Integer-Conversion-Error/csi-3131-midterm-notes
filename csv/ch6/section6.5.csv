Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
What is the primary purpose of a mutex lock in operating systems?,To facilitate inter-process communication directly.,To allocate memory dynamically for processes.,To protect critical sections and prevent race conditions.,To manage CPU scheduling algorithms.,To implement virtual memory paging.,C,The text explicitly states that the purpose of mutex locks is to 'Protect critical sections and prevent race conditions'.
How must a process use a mutex lock to ensure proper synchronization around a critical section?,It must release the lock before entering the critical section and acquire it upon exiting.,It must acquire the lock before entering the critical section and release it upon exiting.,It must acquire the lock only if the critical section is empty.,It must release the lock only if another process is waiting.,It does not need to explicitly acquire or release the lock; it's handled automatically.,B,The text outlines the usage: 'A process must `acquire()` the lock before entering a critical section and `release()` it upon exiting'.
"In the context of a mutex lock, what does the boolean variable `available` signify when its value is `true`?",A process is currently executing within the critical section.,The lock is currently available for acquisition by a process.,The lock has just been released by a process.,"All processes are currently blocked, waiting for the lock.",The system is experiencing high lock contention.,B,The text states: '`available = true`: Lock is available'.
What happens when a process attempts to `acquire()` a mutex lock that is currently unavailable?,The `acquire()` operation immediately returns an error.,The process is terminated by the operating system.,The process is blocked until the lock becomes available.,The `acquire()` operation automatically forces the lock to become available.,The process is immediately granted access to the critical section without the lock.,C,The text specifies: 'Process attempting to acquire an unavailable lock is blocked until released'.
Why is it crucial that calls to `acquire()` and `release()` for a mutex lock are atomic?,To reduce the overhead of context switching.,"To ensure that the lock variable `available` is updated without interruption, preventing race conditions within the lock mechanism itself.",To allow multiple processes to enter the critical section simultaneously.,To prevent deadlocks in single-core systems.,To enable busy waiting for efficient lock acquisition.,B,"The text states that calls to `acquire()` and `release()` must be atomic, implying that their operations (like checking and setting `available`) must be indivisible to maintain the integrity of the lock and prevent race conditions on the lock itself. The mention of CAS operation also supports this."
"According to the provided text, what defines a 'contended lock'?",A lock that is always available when a thread tries to acquire it.,A lock that is being held for an extended period.,A lock where a thread blocks while trying to acquire it.,A lock that is only used by a single thread.,A lock that has been released by a process.,C,The glossary defines 'contended' as: 'A term describing the condition of a lock when a thread blocks while trying to acquire it'.
What characterizes an 'uncontended lock'?,A lock that causes a thread to block when attempting to acquire it.,A lock that is currently in use within a critical section.,A lock that is available when a thread attempts to acquire it.,A lock that prevents any thread from acquiring it.,A lock experiencing high contention.,C,The glossary defines 'uncontended' as: 'A term describing a lock that is available when a thread attempts to acquire it'.
What is the primary effect of highly contended locks on concurrent applications?,They significantly increase overall application performance.,They have no measurable impact on performance.,They decrease overall performance of concurrent applications.,They only affect performance on single-core systems.,They reduce the need for context switches.,C,The text explicitly states: 'Highly contended locks decrease overall performance of concurrent applications'.
"What is a spinlock, as described in the text?",A locking mechanism that puts threads to sleep while waiting for access.,A hardware-based solution for mutual exclusion.,A locking mechanism that continuously uses the CPU while waiting for access to the lock.,A mutex lock specifically designed for long-duration critical sections.,A synchronization tool that does not require an `acquire()` or `release()` operation.,C,"The text identifies the described mutex lock as a spinlock, where a 'Process ""spins"" (loops continuously) while waiting for the lock'. The glossary also defines 'spinlock' as 'A locking mechanism that continuously uses the CPU while waiting for access to the lock'."
What is the main disadvantage of using spinlocks?,They require frequent context switches.,They are complex and inaccessible to application programmers.,"They require busy waiting, which wastes CPU cycles.",They cannot be used on multicore systems.,They increase overall application performance in all scenarios.,C,The text lists 'Disadvantage: Requires busy waiting. Wastes CPU cycles...' as the primary drawback.
Which of the following best describes 'busy waiting'?,A process that is blocked and waiting for an I/O operation to complete.,A thread or process that continuously uses CPU time while waiting for something.,The act of a CPU switching between multiple ready processes.,A state where a lock is available for immediate acquisition.,A mechanism to put processes to sleep to conserve CPU cycles.,B,The glossary defines 'busy waiting' as: 'A practice that allows a thread or process to use CPU time continuously while waiting for something'.
"What is a key advantage of spinlocks, particularly on multicore systems?",They eliminate the need for any synchronization mechanisms.,"They always put waiting processes to sleep, saving CPU cycles.","They require no context switch when waiting on a lock, which can be time-consuming.",They are ideal for long-duration critical sections.,They guarantee fairness in lock acquisition.,C,The text states: 'Advantage: No context switch required when waiting on a lock. Context switches can be time-consuming.' It further notes they are 'Preferable on multicore systems for short-duration locks'.
"When are spinlocks generally preferred on multicore systems, according to the rule of thumb provided?",When the lock will be held for more than two context switches.,When the critical section involves extensive I/O operations.,When the lock will be held for less than two context switches.,When only a single CPU core is available.,When high contention is expected for the lock.,C,The text provides the 'Rule of thumb: Use a spinlock if the lock will be held for less than two context switches (as waiting involves two context switches)'.
Why are spinlocks considered problematic in single-CPU core multiprogramming systems?,"They cause excessive context switching, leading to performance degradation.",They cannot guarantee mutual exclusion in such environments.,"They waste CPU cycles due to busy waiting, as no other thread can execute on the single core.","They require hardware-based solutions, which are often inaccessible.",They lead to an increased number of deadlocks.,C,"The text states that busy waiting 'Wastes CPU cycles, especially problematic in single-CPU core multiprogramming systems'. In such a system, if a thread is spinning, it consumes the sole CPU, preventing the lock holder (or any other thread) from running, thus exacerbating the CPU waste."
"From an operating system design perspective, what type of tool is a mutex lock?",A low-level hardware interrupt handler.,A kernel-mode debugger tool.,A higher-level software tool.,A direct application-level programming construct without OS involvement.,A network communication protocol.,C,The text explains: 'Operating system designers build higher-level software tools. The simplest tool is the mutex lock'.
What does 'mutex' in 'mutex lock' stand for?,Multiple Execution,Memory Unit Expansion,Mutual Exclusion,Multitasking Exchange,Modular Utility Extension,C,The text clarifies: 'The simplest tool is the **mutex lock** (short for **mutual exclusion**)'.
Which statement accurately describes the `acquire()` function's behavior in the provided mutex lock implementation?,It immediately sets `available` to `false` without checking its current state.,It first checks if `available` is `true` and then proceeds to busy-wait if it's `false`.,"It busy-waits while `available` is `false`, and then sets `available` to `false` once `available` becomes `true` (and the loop exits).",It puts the process to sleep if `available` is `false`.,It releases the lock if `available` is `true`.,C,"The `acquire()` definition shows: `while (!available) ; /* busy wait */ available = false;`. This means it loops (busy-waits) as long as the lock is not available, and once it becomes available, it exits the loop and sets `available` to false to acquire it."
What is the sole action performed by the `release()` function in the provided mutex lock implementation?,It checks if any processes are waiting and wakes them up.,It decrements a counter of processes in the critical section.,It sets the boolean variable `available` to `true`.,It busy-waits until no other process is in the critical section.,It calls the `acquire()` function internally.,C,The `release()` definition clearly shows: `available = true;`. This is its only action.
The text mentions strategies to avoid busy waiting. What general approach is discussed for this purpose?,Increasing the number of CPU cores.,Implementing the lock using hardware-based solutions.,Putting processes to sleep instead of letting them spin.,Reducing the length of critical sections.,Using atomic operations for `acquire()` and `release()`.,C,"In the discussion of spinlock disadvantages, the text notes: '(Section \ref{sec:6.6} discusses strategies to avoid busy waiting by putting processes to sleep.)'"
