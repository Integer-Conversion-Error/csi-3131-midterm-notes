Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
"What is a semaphore, as defined in the context of synchronization tools?",A boolean variable for mutual exclusion.,An integer variable accessed through atomic `acquire()` and `release()` operations.,"An integer variable that, apart from initialization, is accessed only through two standard atomic operations: `wait()` and `signal()`.",A floating-point variable used for resource allocation.,A lock that provides exclusive access to a critical section.,C,"The text defines a semaphore as 'An integer variable that, apart from initialization, is accessed only through two standard atomic operations: wait() and signal().'"
Who introduced the concept of semaphores?,Alan Turing,Donald Knuth,Edsger Dijkstra,Charles Babbage,Grace Hopper,C,The text explicitly states that semaphores were 'Introduced by Edsger Dijkstra.'
"What were the original terms used by Edsger Dijkstra for the `wait()` and `signal()` operations, respectively?",`Open` and `Close`,`Lock` and `Unlock`,`P` and `V`,`Down` and `Up`,`Test` and `Increment`,C,"The text states: 'Original terms: `wait()` was `P` (proberen, ""to test""); `signal()` was `V` (verhogen, ""to increment"").'"
"In the classical definition of the `wait(S)` operation, what is the primary mechanism used when the semaphore value `S` is not positive?",The process is immediately suspended and placed in a waiting queue.,"The process spins in a loop, repeatedly checking the semaphore value.","The semaphore value is decremented, and the process continues.","An error is thrown, indicating resource unavailability.",The process is terminated.,B,"The classical `wait(S)` definition includes `while (S <= 0); /* busy wait */`, which signifies busy waiting."
Which statement accurately describes a crucial atomicity requirement for semaphore operations `wait()` and `signal()`?,Only `signal()` operations must be atomic; `wait()` can be interrupted.,The semaphore value can be modified simultaneously by multiple processes as long as the final value is correct.,"All modifications to the semaphore value in `wait()` and `signal()` must be atomic, preventing simultaneous modification by two processes.","Atomicity is only required for binary semaphores, not counting semaphores.","Only the testing of `S <= 0` in `wait()` needs to be atomic, not the decrement.",C,The text states: 'All modifications to semaphore value in `wait()` and `signal()` must be atomic. No two processes can simultaneously modify the same semaphore value.'
Which characteristic is TRUE for a counting semaphore?,Its value is restricted to 0 or 1.,It is primarily used for mutual exclusion on systems without mutex locks.,It is initialized to an unrestricted domain and increments when a process wishes to use a resource.,"Its value can range over an unrestricted domain, and it's used to control access to resources with a finite number of instances.","When its value goes to 0, processes immediately acquire the resource.",D,The text states: 'Counting semaphore: Value can range over an unrestricted domain. Used to control access to a resource with a finite number of instances.'
"How is a counting semaphore typically initialized, and what does its initial value represent?","It's initialized to 0, representing no available resources.","It's initialized to 1, representing a single available resource.","It's initialized to the number of available resources, controlling access to those resources.","It's initialized to an arbitrary negative number, indicating an overflow condition.",Its initialization value is determined dynamically by the operating system.,C,The text explicitly states that a counting semaphore is 'Initialized to the number of available resources.'
"For a counting semaphore, what happens when a process performs a `wait()` operation, and what happens when it performs a `signal()` operation?","`wait()` increments the count, `signal()` decrements the count.","`wait()` decrements the count when a process wants to use a resource, and `signal()` increments the count when a process releases a resource.","Both `wait()` and `signal()` increment the count, but `wait()` blocks if the count is zero.","Both `wait()` and `signal()` decrement the count, but `signal()` resumes a blocked process.",`wait()` decrements the count but never blocks; `signal()` increments the count and always wakes up a process.,B,The text explains: '`wait()`: Decrements count when a process wishes to use a resource.' and '`signal()`: Increments count when a process releases a resource.'
What is a key characteristic and primary use case for a binary semaphore?,"Its value can be any integer, and it's used for inter-process communication.","Its value is restricted to 0 or 1, and it behaves similarly to mutex locks for mutual exclusion.","Its value decreases only, used for signaling critical errors.","Its value increments indefinitely, used for tracking total resource usage.",It's a specialized type of counting semaphore that can handle negative values.,B,The text states: 'Binary semaphore: Value can only be 0 or 1. Behaves similarly to mutex locks. Can be used for mutual exclusion on systems without mutex locks.'
"Consider two processes, P1 with statement S1 and P2 with S2. To ensure S2 executes only after S1 completes using a semaphore `synch`, how should `synch` be initialized and used?","`synch` initialized to 1; P1 calls `wait(synch)` then S1, P2 calls `signal(synch)` then S2.","`synch` initialized to 0; P1 calls S1 then `signal(synch)`, P2 calls `wait(synch)` then S2.","`synch` initialized to -1; P1 calls S1 then `wait(synch)`, P2 calls `signal(synch)` then S2.","`synch` initialized to 1; P1 calls S1 then `signal(synch)`, P2 calls S2 then `wait(synch)`.","`synch` initialized to 0; P1 calls `wait(synch)` then S1, P2 calls S2 then `signal(synch)`.",B,"The example implementation shows: 'Share a common semaphore `synch`, initialized to 0. In process P1: `S1; signal(synch);` In process P2: `wait(synch); S2;`'"
What is the primary drawback of the classical `wait()` and `signal()` semaphore definitions?,They require complex hardware support.,They are prone to race conditions if not implemented correctly.,"They lead to busy waiting, wasting CPU cycles.",They cannot be used for mutual exclusion.,They limit the number of resources that can be controlled.,C,The text states: 'The classical `wait()` and `signal()` definitions suffer from busy waiting.'
"To overcome busy waiting in semaphore implementations, what happens when a `wait()` operation finds the semaphore value not positive?","The process immediately enters an infinite loop, continuously checking the semaphore.",The process increments the semaphore value and retries the operation.,The process suspends itself and is placed into a waiting queue associated with the semaphore.,The operating system forcefully terminates the process.,The semaphore automatically increases its value after a fixed delay.,C,"The text explains: 'When `wait()` finds semaphore value not positive, process suspends itself instead of busy waiting. Places process into a waiting queue associated with the semaphore...'"
"When a process suspends itself after a `wait()` operation due to a non-positive semaphore value, what is its state change?",From ready to running.,From running to terminated.,From running to waiting.,From waiting to ready.,From new to ready.,C,The text states: 'process state switches to waiting.'
"In a semaphore implementation without busy waiting, what is the purpose of the `wakeup()` operation?",To immediately terminate a process that is no longer needed.,To change a process's state from waiting to ready and place it in the ready queue.,To decrement the semaphore value and put the calling process to sleep.,To signal the CPU scheduler to stop all currently running processes.,To prevent a process from ever entering a waiting state.,B,"The text defines `wakeup()` operation as changing 'process from waiting to ready state, places it in the ready queue.'"
"In the semaphore implementation designed to avoid busy waiting, what are the two main components of the `semaphore` structure?",A boolean flag and a process ID.,An integer value and a pointer to a list of waiting processes.,Two integer values representing upper and lower bounds.,A mutex lock and a condition variable.,A timestamp and a counter.,B,The structure is defined as `typedef struct { int value; struct process *list; } semaphore;` where `value` is the integer value and `list` is the list of processes waiting.
"In the `wait(semaphore *S)` implementation designed to avoid busy waiting, what happens if `S->value` becomes negative after decrementing?",The process continues execution immediately.,The process is removed from `S->list` and woken up.,The process is added to `S->list` and calls `sleep()`.,The semaphore value is reset to zero.,"An error is logged, but the process does not change state.",C,The provided code for `wait(semaphore *S)` shows: `if (S->value < 0) { add this process to S->list; sleep(); }`
"In the `signal(semaphore *S)` implementation designed to avoid busy waiting, what action is taken if `S->value` is less than or equal to 0 after incrementing?",The semaphore value is reset to 1.,The calling process is suspended.,A process P is removed from `S->list` and `wakeup(P)` is called.,The `signal()` operation busy waits until `S->value` becomes positive.,No action is taken as all processes are already running.,C,The provided code for `signal(semaphore *S)` shows: `if (S->value <= 0) { remove a process P from S->list; wakeup(P); }`
"In the semaphore implementation without busy waiting, what does a negative semaphore value signify, and why can it occur?","It signifies an error state, occurring when `signal()` is called too many times.","It signifies the number of available resources, occurring because `wait()` decrements before checking.","It signifies the number of processes waiting on that semaphore, occurring because `S->value` is decremented before testing it in `wait()`.","It signifies that the semaphore is broken, occurring due to a system malfunction.","It signifies that all resources are in use, occurring when `S->value` is checked before decrementing.",C,The text explains: 'Magnitude of a negative value = number of processes waiting on that semaphore. This results from decrementing `S->value` before testing it in `wait()`.'
How is the atomicity of `wait()` and `signal()` operations typically ensured in a single-processor environment?,By using hardware-level spinlocks for all critical sections.,By continuously polling a shared memory location.,By inhibiting interrupts during the execution of `wait()` and `signal()`.,By relying on software-only mutexes.,By dedicating a separate core for semaphore operations.,C,The text states: 'Single-processor environment: Solved by inhibiting interrupts during `wait()` and `signal()` execution.'
"In a multicore (SMP) environment, why is simply inhibiting interrupts during `wait()` and `signal()` not a practical solution for ensuring atomicity, and what alternatives are used?",It's impractical because it's difficult and diminishes performance to disable interrupts on every core; `compare_and_swap()` or spinlocks are used instead.,It's impractical because it can lead to deadlocks; only binary semaphores are used.,It's perfectly practical and commonly used; no alternatives are needed.,It's impractical due to increased context switching overhead; only message passing is used.,"It only works for counting semaphores, not binary ones; memory barriers are the alternative.",A,"The text clarifies: 'Interrupts must be disabled on *every* processing core (difficult, diminishes performance). SMP systems use alternative techniques like `compare_and_swap()` or spinlocks to ensure atomicity of `wait()` and `signal()`.'"
"Although designed to overcome busy waiting, where does busy waiting *still* implicitly occur in the improved semaphore implementation, and why is this acceptable?",It occurs within application critical sections and is acceptable because these sections are very short.,"It occurs within the critical sections of `wait()` and `signal()` operations themselves, but is acceptable because these sections are very short and busy waiting occurs rarely.","It occurs during the `sleep()` and `wakeup()` calls, which is acceptable due to the efficiency of system calls.","It occurs during CPU scheduling, which is unavoidable for process management.","Busy waiting is entirely eliminated, so it does not occur anywhere.",B,The text states: 'Busy waiting is not entirely eliminated; it's moved from application critical sections to the critical sections of `wait()` and `signal()` operations themselves. These critical sections are very short... Busy waiting occurs rarely and for a short time in this context.'
