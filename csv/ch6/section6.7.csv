Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
"What is a primary drawback of using semaphores for synchronization, even though they are convenient?",They are computationally expensive and slow down execution significantly.,Their incorrect use can lead to hard-to-detect timing errors that may not be reproducible.,They cannot be used to implement mutual exclusion.,They only work in single-processor environments.,They require excessive memory allocation.,B,"The text states, ""Semaphores are convenient but incorrect use can lead to hard-to-detect timing errors,"" and ""These errors occur only with specific execution sequences and may not be reproducible."""
"In a typical semaphore-based critical-section solution, what sequence of operations must a process observe to ensure mutual exclusion, given a binary semaphore `mutex` initialized to 1?","`signal(mutex)` before critical section, `wait(mutex)` afterward.","`wait(mutex)` before critical section, `wait(mutex)` afterward.","`wait(mutex)` before critical section, `signal(mutex)` afterward.","`signal(mutex)` before critical section, `signal(mutex)` afterward.","No specific sequence is required, as long as `wait` and `signal` are both called.",C,"The text states: ""Each process must execute `wait(mutex)` before critical section and `signal(mutex)` afterward."""
"What is the consequence if a process incorrectly interchanges the `wait()` and `signal()` operations for a binary semaphore `mutex` (i.e., `signal(mutex)` before critical section and `wait(mutex)` afterward)?",The process will permanently block.,"Mutual exclusion will be maintained, but performance will degrade.","Multiple processes may enter the critical section simultaneously, violating mutual exclusion.","The semaphore's state will become negative, leading to a system crash.",The error will always be immediately detectable and reproducible.,C,"The text describes this scenario: ""Result: Multiple processes may enter critical section simultaneously, violating mutual exclusion."" It also notes the error ""may not always be reproducible."""
"If a process replaces `signal(mutex)` with `wait(mutex)` after its critical section (i.e., `wait(mutex)` before and `wait(mutex)` after), what is the outcome?",Mutual exclusion is violated.,The process permanently blocks on the second `wait()` call.,The system enters a deadlock state involving all processes.,The semaphore's value will increase unexpectedly.,"No error occurs, as long as `wait` is called twice.",B,"The text explicitly states for this case: ""Result: Process permanently blocks on the second `wait()` call (semaphore unavailable)."""
"According to the text's glossary, what is a monitor?",A low-level programming construct used for direct memory access.,A type of hardware device for displaying output.,A high-level language synchronization construct that protects variables from race conditions.,A debugging tool for observing process execution flow.,A system call for process creation.,C,"The glossary defines ""monitor"" as ""A high-level language synchronization construct that protects variables from race conditions."""
How does the text define an Abstract Data Type (ADT)?,A data structure that relies heavily on pointer arithmetic.,"A programming construct that encapsulates data with a set of functions to operate on that data, independent of implementation.",A raw collection of data without any associated operations.,A system-level process for managing memory.,A type of network protocol for secure data transmission.,B,"The glossary defines ""abstract data type (ADT)"" as ""A programming construct that encapsulates data with a set of functions to operate on that data that are independent of any specific implementation of the ADT."""
What characteristic distinguishes a monitor type from a general Abstract Data Type (ADT)?,A monitor type does not encapsulate data.,A monitor type requires explicit programmer-coded mutual exclusion.,A monitor type includes programmer-defined operations with mutual exclusion *within* the monitor.,A monitor type is dependent on a specific implementation.,A monitor type cannot declare variables defining its state.,C,"The text states, ""Monitor type: An ADT that includes programmer-defined operations with mutual exclusion *within* the monitor."" It also adds that the programmer ""does not need to explicitly code this synchronization constraint."""
What key synchronization guarantee does the monitor construct provide without requiring explicit coding by the programmer?,All processes will complete their execution within a fixed time frame.,Data consistency is ensured across distributed systems.,Only one process is active within the monitor at a time.,Deadlocks are entirely prevented in all scenarios.,Resource allocation is always fair and optimized.,C,"The text states, ""The monitor construct ensures only one process is active within the monitor at a time. Programmer does not need to explicitly code this synchronization constraint."""
Which of the following statements is true regarding the access rules for variables declared locally within a monitor?,They can be directly accessed by any process outside the monitor.,They can only be accessed by functions declared within the monitor.,They are automatically global to the entire program.,They can be accessed by functions external to the monitor if a pointer is passed.,They are read-only to all functions.,B,"The text specifies: ""Local variables of a monitor can only be accessed by local functions."""
"Despite its benefits, what is a stated limitation of the monitor construct alone?",It increases the complexity of programming.,It is not powerful enough for all synchronization schemes.,It introduces significant performance overhead.,It cannot be implemented in modern programming languages.,It does not provide mutual exclusion.,B,"The text explicitly states: ""Limitation: Monitor construct alone is not powerful enough for all synchronization schemes."""
What are the only two operations permitted on `condition` variables within a monitor?,`create()` and `destroy()`,`increment()` and `decrement()`,`lock()` and `unlock()`,`wait()` and `signal()`,`read()` and `write()`,D,"The text states, ""Operations on condition variables: Only `wait()` and `signal()`."""
"When a process invokes the `x.wait()` operation on a condition variable `x` within a monitor, what happens to that process?",It immediately resumes execution in the monitor.,It is suspended indefinitely.,It is suspended until another process invokes `x.signal()`.,It exits the monitor permanently.,It gains exclusive access to all shared resources.,C,"The text states: ""`x.wait()` operation: Process invoking it is suspended until another process invokes `x.signal()`."""
How does the `x.signal()` operation on a monitor condition variable differ from a semaphore's `signal()` operation when no processes are suspended?,"`x.signal()` always causes a process to be immediately resumed, whereas semaphore `signal()` does not.","`x.signal()` increases the condition variable's count, while semaphore `signal()` decreases its count.","If no process is suspended, `x.signal()` has no effect, unlike semaphore `signal()` which always affects its state.","Semaphore `signal()` can only resume one process, while `x.signal()` can resume multiple.","`x.signal()` requires an argument, while semaphore `signal()` does not.",C,"The text specifies for `x.signal()`: ""If no process is suspended, `signal()` has no effect (state of `x` unchanged)."" And then, ""Contrast with semaphore `signal()`: Semaphore `signal()` always affects its state."""
"When `x.signal()` is invoked on a condition variable `x` and there are processes suspended on it, how many processes are resumed?",All suspended processes.,Exactly one suspended process.,A random number of suspended processes.,"Zero suspended processes, as `signal()` is just a notification.",It depends on the number of available CPU cores.,B,"The text states: ""`x.signal()` operation: Resumes exactly one suspended process."""
"When a process P invokes `x.signal()` and process Q is suspended on `x`, what is the ""compromise"" solution described for their continuation?",Both P and Q are allowed to execute concurrently within the monitor.,"P continues execution, and Q is suspended indefinitely.","P immediately leaves the monitor, and Q is immediately resumed.","Q leaves the monitor, and P remains suspended.",Both P and Q are put into a waiting queue outside the monitor.,C,"The text describes the ""compromise"": ""When P executes `signal()`, it immediately leaves the monitor, and Q is immediately resumed."""
"When implementing a monitor using semaphores, how is mutual exclusion within the monitor typically ensured?",By using a counting semaphore for each function inside the monitor.,"By introducing a binary semaphore `mutex` (initialized to 1), with `wait(mutex)` upon entry and `signal(mutex)` upon exit.",By requiring all processes to use busy waiting before entering the monitor.,By relying on the operating system's default scheduler.,By disallowing any shared variables within the monitor.,B,"The text states under ""Mutual Exclusion"" for implementation: ""For each monitor, a binary semaphore `mutex` (initialized to 1) ensures mutual exclusion. Process executes `wait(mutex)` before entering monitor, `signal(mutex)` after leaving."""
What is the purpose of the `conditional-wait` construct within a monitor?,To allow a process to busy-wait until a condition is met.,To provide a mechanism for a process to terminate itself based on a condition.,To allow for waiting on a condition variable with a priority number to determine which process resumes next.,To enable a process to signal multiple waiting processes simultaneously.,To prevent any process from waiting inside the monitor.,C,"The glossary defines ""conditional-wait"" as ""A component of the monitor construct that allows for waiting on a variable with a priority number to indicate which process should get the lock next."""
"What is a ""priority number"" in the context of a monitor's conditional-wait construct?",A unique identifier assigned to each monitor instance.,An integer value indicating the maximum number of processes allowed in the critical section.,"A number indicating the position of a process in a conditional-wait queue, used for determining resumption order.",The total number of `signal()` operations performed on a condition variable.,A measure of the time a process has spent waiting.,C,"The glossary defines ""priority number"" as ""A number indicating the position of a process in a conditional-wait queue in a monitor construct."""
"In the `conditional-wait` construct `x.wait(c)`, if multiple processes are suspended on condition `x`, which process is resumed when `x.signal()` is executed?",The process that has been waiting the shortest amount of time (LIFO).,A randomly selected process from the waiting queue.,The process with the largest priority number `c`.,The process with the smallest priority number `c`.,All suspended processes are resumed simultaneously.,D,"The text states: ""When `x.signal()` is executed, the process with the smallest priority number resumes."""
"In the `ResourceAllocator` monitor example, what criterion determines which process receives the resource when `x.signal()` is invoked after `busy` becomes false?","First-Come, First-Served (FCFS) order of waiting.",The process that waits for the longest time.,The process with the shortest time-allocation request.,A process chosen randomly.,The process that has executed `R.release()` most recently.,C,"The text describes the `ResourceAllocator` monitor: ""Monitor allocates resource to process with shortest time-allocation request,"" and the `acquire` function uses `x.wait(time)`, indicating `time` as the priority number."
"What is a significant limitation of the monitor concept concerning the required access sequence for a shared resource, such as in the `ResourceAllocator` example?",It inherently guarantees the correct access sequence will be observed.,It prevents any process from accessing the resource directly without monitor permission.,It cannot guarantee that the required access sequence will be observed by user processes.,It automatically detects and corrects any deviations from the specified sequence.,It provides full compiler assistance to enforce the sequence.,C,"The text states under ""Limitations of Monitor Concept (regarding access sequence)"": ""Cannot guarantee the required access sequence will be observed."""
"Beyond ensuring correct call sequences, what other critical condition must be met for a monitor-based solution to prevent time-dependent errors and maintain its scheduling algorithm?",All user processes must be written in assembly language.,The system must always run on a single processor.,Uncooperative processes must not ignore the mutual-exclusion gateway and access the shared resource directly.,The monitor must be able to dynamically adjust its internal scheduling algorithm.,The `conditional-wait` construct must never be used.,C,"The text states one of the two conditions for correctness: ""Uncooperative processes do not ignore mutual-exclusion gateway and access shared resource directly."""
What scalability concern is raised regarding the method of inspecting all programs to ensure correct monitor usage and prevent direct resource access?,It requires specialized hardware that is not widely available.,"It is only feasible for large, dynamic systems.",It introduces significant runtime overhead.,"It is feasible for small, static systems but not large or dynamic ones.",It completely eliminates the need for human inspection.,D,"The text mentions: ""Inspection is feasible for small, static systems but not large or dynamic ones."""
What is the overall strategy proposed to address the issues of easily generated errors with incorrect semaphore/mutex lock usage?,To strictly enforce semaphore usage through kernel-level checks.,To eliminate synchronization mechanisms entirely from programming languages.,To incorporate simple synchronization tools as high-level language constructs.,To shift all synchronization responsibilities to the hardware.,To only use semaphores with busy waiting.,C,"The text states: ""Solution Strategy: Incorporate simple synchronization tools as high-level language constructs."""
What is the effect of an `x.signal()` operation on a monitor condition variable `x` if no processes are currently suspended on `x`?,"It increments an internal counter of `x`, preparing for a future `wait()`.",It causes an error or exception to be thrown.,"It has no effect, and the state of `x` remains unchanged.",It causes the calling process to be suspended.,It causes all other processes in the system to resume.,C,"The text states: ""If no process is suspended, `signal()` has no effect (state of `x` unchanged)."""
"In the semaphore implementation of a monitor's signal-and-wait scheme, what is the purpose of the additional binary semaphore `next` (initialized to 0)?",To control access to external resources.,To allow signaling processes to suspend themselves.,To ensure that only one process can enter the monitor at a time.,To count the total number of processes waiting for any condition.,To directly manage the critical section of the monitor.,B,"The text states: ""An additional binary semaphore `next` (initialized to 0) is introduced. Signaling processes use `next` to suspend themselves."""
"In the semaphore implementation of a monitor's signal-and-wait scheme, what is the role of the integer variable `next_count`?",It tracks the number of times `signal(next)` has been called.,It counts processes suspended on the `next` semaphore.,It represents the total number of processes currently active in the monitor.,It serves as a unique identifier for the next process to enter the monitor.,It measures the elapsed time since the monitor was initialized.,B,"The text states: ""Integer variable `next_count` counts processes suspended on `next`."""
