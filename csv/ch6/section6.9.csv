Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
"What is a primary goal of synchronization tools for solving the critical-section problem, given correct implementation and usage?",To eliminate all forms of resource contention.,To guarantee fairness in resource allocation.,To ensure mutual exclusion and address liveness issues.,To always improve overall system throughput.,To prevent system crashes due to deadlocks.,C,"The text states, 'Given correct implementation and usage, these tools ensure mutual exclusion and address liveness issues.'"
Hardware solutions for synchronization are generally considered to be:,High-level abstractions.,Software-based only.,Very low-level.,Primarily used for real-time systems.,Suitable for direct application by programmers without modification.,C,The text states that hardware solutions are 'Considered very low-level.'
What is the typical role of hardware solutions in constructing synchronization tools?,They are standalone tools for direct application.,They serve as foundations for constructing other synchronization tools like mutex locks.,They are primarily used for debugging concurrent programs.,They replace the need for software-based synchronization entirely.,They are only applicable in single-core systems.,B,"The text states, 'Typically used as foundations for constructing other synchronization tools (e.g., mutex locks).'"
Which of the following best defines a 'lock-free' algorithm?,An algorithm that completely avoids race conditions by serializing all operations.,An algorithmic strategy that provides protection from race conditions without requiring the overhead of locking.,"An algorithm that uses a single, global lock to protect all shared data.",A method for preventing deadlocks in real-time systems.,A technique used exclusively in hardware-level synchronization.,B,The glossary defines 'lock-free' as 'An algorithmic strategy that provides protection from race conditions without requiring the overhead of locking.'
What is a stated advantage of lock-free algorithms?,They are easier to develop and test.,They guarantee freedom from deadlocks in all scenarios.,They offer low overhead and ability to scale.,They are only dependent on software implementations.,They eliminate the need for any form of synchronization.,C,"The text lists 'Advantages: Low overhead, ability to scale' for lock-free algorithms."
What is a known disadvantage of lock-free algorithms?,They typically have high overhead.,They prevent parallel execution.,They are often difficult to develop and test.,They are only suitable for single-processor systems.,They require extensive hardware support not commonly available.,C,The text lists 'Disadvantage: Often difficult to develop and test' for lock-free algorithms.
"Priority inversion is described as more than a scheduling inconvenience, especially in real-time systems, because it can lead to:",Increased system throughput.,Guaranteed mutual exclusion.,"A process taking longer than expected, cascading failures, and system failure.",Reduced contention for shared resources.,Simplified development of concurrent programs.,C,"The text states that priority inversion 'Can cause a process to take longer than expected, leading to cascading failures and system failure.'"
"In the Mars Pathfinder example, what was the direct cause of the high-priority task ('bc_dist') being delayed?",It was preempted by multiple lower-priority tasks.,It was waiting for a shared resource held by a lower-priority task ('ASI/MET').,The system ran out of available memory.,A medium-priority task experienced an infinite loop.,The 'bc_sched' task initiated a reset prematurely.,B,"The text states, 'High-priority task ('bc_dist') was delayed waiting for a shared resource held by a lower-priority task ('ASI/MET').'"
"What contributed to the priority inversion issue in the Mars Pathfinder incident, beyond the high-priority task waiting for a low-priority task?",The high-priority task was performing an I/O operation.,The low-priority task was preempted by multiple medium-priority tasks.,The system was running a non-preemptive scheduler.,The 'bc_sched' task had a higher priority than 'bc_dist'.,The shared resource was corrupted.,B,"The text states, 'The lower-priority task was preempted by multiple medium-priority tasks,' which prevented it from releasing the resource quickly."
What was the solution implemented to resolve the priority inversion problem on the Mars Pathfinder's VxWorks OS?,Decreasing the priority of the high-priority task.,Increasing the priority of the low-priority task permanently.,Disabling preemption for all tasks.,Enabling priority inheritance on all semaphores using a global variable.,Replacing all semaphores with mutex locks.,D,"The text states, 'VxWorks real-time OS (on Sojourner) had a global variable to enable priority inheritance on all semaphores. Setting this variable solved the problem.'"
Which strategy characterizes CAS-based synchronization?,"Pessimistic approach, acquiring locks before any update.","Optimistic approach, updating a variable first and then detecting conflicts.",Strict serialization of all concurrent operations.,A strategy that eliminates the need for any conflict detection.,A method that requires kernel-level intervention for every update.,B,The text describes CAS-based synchronization as an 'Optimistic approach' where you 'Optimistically update a variable first. Use collision detection to see if another thread updated concurrently.'
Which strategy characterizes mutual-exclusion locking?,"Optimistic approach, retrying on conflict.","Lock-free approach, avoiding overhead.","Pessimistic strategy, acquiring the lock before making any updates.",A strategy that relies on hardware-level atomicity without software locks.,A method that ensures fairness among competing threads.,C,The text describes mutual-exclusion locking as a 'Pessimistic strategy' where you 'Pessimistically acquire the lock before making any updates.'
"Regarding performance under uncontended loads, how do CAS-based synchronization and traditional locking compare?",Traditional locking is significantly faster.,CAS protection is much slower due to retries.,"Both are generally fast, with CAS protection being somewhat faster.",Both perform identically.,Only traditional locking is suitable for uncontended scenarios.,C,"The text states, 'Uncontended loads: Both are generally fast; CAS protection is somewhat faster.'"
"Under conditions of moderate contention, which synchronization approach is typically faster?",Traditional synchronization (mutex locks).,CAS-based protection.,Both perform equally.,Higher-level tools like monitors.,Spinlocks.,B,"The text states, 'Moderate contention: CAS protection is faster (possibly much faster).'"
Why is CAS-based protection faster under moderate contention compared to traditional locking?,Traditional locking involves simpler code paths.,CAS operations never fail under moderate contention.,"Traditional locking involves complex, time-intensive code paths like suspending threads and context switches, while CAS often succeeds or iterates few times.",CAS inherently eliminates all forms of contention.,Traditional locking automatically scales better.,C,"The text explains, 'CAS operation succeeds most of the time. If it fails, it iterates only a few times before succeeding. Traditional locking: Any contended lock acquisition involves a more complex, time-intensive code path (suspends thread, places on wait queue, context switch).'"
"Under conditions of high contention, which synchronization approach is ultimately faster?",CAS-based synchronization.,Traditional synchronization.,Atomic integers.,Spinlocks.,Reader-writer locks.,B,"The text states, 'High contention: Traditional synchronization is ultimately faster than CAS-based synchronization.'"
"For single updates to shared variables (e.g., counters), which synchronization mechanism is described as much lighter-weight and more appropriate than traditional locks?",Semaphores.,Spinlocks.,Atomic integers.,Mutex locks.,Reader-writer locks.,C,"The text states, 'Atomic integers are much lighter-weight than traditional locks. More appropriate than mutex locks or semaphores for single updates to shared variables (e.g., counters).'"
In what scenario are spinlocks typically used on multiprocessor systems?,When locks are held for very long durations.,For protecting critical sections that require extensive I/O operations.,When locks are held for short durations.,As a replacement for all other synchronization tools.,On single-processor systems only.,C,"The text states, 'Spinlocks are used on multiprocessor systems when locks are held for short durations.'"
How do mutex locks compare to semaphores in terms of simplicity and overhead?,Semaphores are simpler and have less overhead.,Mutex locks are simpler and have less overhead.,Both have identical simplicity and overhead.,Semaphores are always preferred over mutex locks.,Mutex locks are only used in single-threaded applications.,B,"The text states, 'Mutex locks are simpler and have less overhead than semaphores.'"
"For protecting critical section access, which mechanism is preferable between mutex locks and binary semaphores?",Binary semaphores are always preferable.,Mutex locks are preferable to binary semaphores.,"They are equally preferable, serving the exact same purpose without distinction.",Neither is suitable for critical section access.,Only counting semaphores are appropriate.,B,"The text states, 'Mutex locks are preferable to binary semaphores for protecting critical section access.'"
When is a counting semaphore more appropriate than a mutex lock?,For protecting a critical section from race conditions.,For controlling access to a finite number of resources.,For single updates to shared variables.,For implementing lock-free algorithms.,When higher concurrency is desired with multiple readers.,B,"The text states, 'Counting semaphores are more appropriate than mutex locks for controlling access to a finite number of resources.'"
Why might reader-writer locks be preferred over mutex locks?,They offer simpler implementation.,They have significantly less overhead in all situations.,For higher concurrency by allowing multiple readers simultaneously.,They eliminate the possibility of deadlocks.,They are suitable for single updates to shared variables.,C,"The text states, 'Reader-writer locks may be preferred over mutex locks for higher concurrency (multiple readers allowed).'"
What is the main appeal of higher-level synchronization tools like monitors and condition variables?,Their superior performance in highly contended situations.,Their inherent ability to prevent all liveness issues.,Their simplicity and ease of use.,Their low overhead compared to hardware solutions.,Their direct support for lock-free algorithms.,C,"The text states, 'Appeal: Simplicity and ease of use.'"
What is a stated drawback of higher-level synchronization tools like monitors and condition variables?,They are extremely difficult to develop and test.,They often lack mutual exclusion guarantees.,They introduce significant overhead and may scale less effectively in highly contended situations.,They are only applicable to single-processor systems.,They require specific hardware support that is not widely available.,C,"The text states, 'Drawbacks: Significant overhead; may scale less effectively in highly contended situations depending on implementation.'"
What is a primary focus of ongoing research related to concurrent programming?,Eliminating the need for any synchronization tools.,Developing less scalable and less efficient tools.,Designing compilers for less efficient code.,"Developing scalable, efficient tools for concurrent programming.",Focusing solely on hardware-level solutions.,D,"The text states, 'Much research is focused on developing scalable, efficient tools for concurrent programming.'"
