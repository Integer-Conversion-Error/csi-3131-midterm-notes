"Which of the following was a primary focus of the previous chapter on synchronization tools, according to the introduction?",Applying synchronization tools to classic problems.,"Exploring synchronization mechanisms in Linux, UNIX, and Windows.",The critical-section problem and race conditions with shared data.,Describing API details for Java and POSIX systems.,Designing and developing solutions using POSIX and Java APIs.,C,The introduction states that the 'Previous chapter: Synchronization Tools. Focused on critical-section problem and race conditions with shared data.'
Which of the following is NOT listed as a higher-level synchronization tool examined in the previous chapter?,Mutex locks,Semaphores,Monitors,Memory barriers,All of the above were listed as higher-level tools.,D,"The text states 'Low-level hardware: memory barriers, compare-and-swap. Higher-level: mutex locks, semaphores, monitors.' Therefore, memory barriers are a low-level hardware tool."
What type of liveness hazard was specifically mentioned as a challenge discussed in the previous chapter?,Starvation,Deadlocks,Priority inversion,Livelock,Race conditions,B,The introduction states that the previous chapter 'Discussed challenges: liveness hazards like deadlocks.'
What is a primary purpose for using classic synchronization problems in computer science?,To benchmark CPU clock speeds.,To test new synchronization schemes.,To illustrate the benefits of single-threaded programming.,To analyze network bandwidth utilization.,To develop new hardware architectures.,B,The text states that classic problems are 'Used for testing new synchronization schemes.'
What synchronization primitive is traditionally used for solving classic concurrency-control problems?,Spinlocks,Condition variables,Monitors,Semaphores,Mutex locks,D,"The text states, 'Solutions traditionally use semaphores; mutex locks can be used for binary semaphores in actual implementations.'"
"In the bounded-buffer problem, what is the initial value of the `mutex` semaphore?",0,N (representing total buffers),1,Any positive integer,Undefined,C,The shared data structure for the bounded-buffer problem specifies `semaphore mutex = 1;` and describes it as 'initialized to 1'.
What is the primary function of the `empty` semaphore in the bounded-buffer problem?,To ensure mutual exclusion when accessing the buffer pool.,To count the number of full buffers available.,To count the number of empty buffers available.,To signal the producer when the buffer is full.,To track the total number of items produced.,C,"The text explains, '`empty`: counts empty buffers, initialized to `N`.'"
Which sequence of `wait` operations is performed by the producer process in the bounded-buffer problem?,wait(mutex); wait(empty);,wait(full); wait(mutex);,wait(empty); wait(mutex);,wait(mutex); wait(full);,wait(empty); wait(full);,C,The producer process structure shows `wait(empty); wait(mutex);` before the item is added to the buffer.
Which sequence of `signal` operations is performed by the consumer process after removing an item from the buffer in the bounded-buffer problem?,signal(full); signal(mutex);,signal(empty); signal(mutex);,signal(mutex); signal(full);,signal(mutex); signal(empty);,signal(full); signal(empty);,D,The consumer process structure shows `signal(mutex); signal(empty);` after an item is removed from the buffer.
What is the fundamental requirement for writers in the readers-writers problem?,Writers must always have higher priority than readers.,Writers must ensure all readers have completed before starting.,Writers must have exclusive access to the database while writing.,"Writers must never block, even if readers are active.",Writers should only update a copy of the database.,C,The text explicitly states: 'Requirement: Writers must have exclusive access while writing.'
"In the 'First readers-writers problem' variation, what is the behavior regarding readers and writers?",Writers are given priority over readers to prevent starvation.,"If a writer is waiting, no new readers may start.",No reader waits unless a writer already has permission; readers don't wait for other readers if a writer is waiting.,Both readers and writers must acquire a single mutex for all access.,It ensures fairness by alternating between readers and writers.,C,The text defines the 'First readers-writers problem' as: 'No reader waits unless a writer already has permission. Readers don't wait for other readers if a writer is waiting.'
Which type of process is susceptible to starvation in the solution to the 'First readers-writers problem'?,Readers,Writers,Both readers and writers,"Neither, the solution prevents all starvation",Only processes with low priority,B,"The text states under 'Starvation': 'Solutions may lead to starvation (writers in first case, readers in second).'"
"In the provided solution to the first readers-writers problem, what is the role of the `rw_mutex` semaphore?",It counts the total number of readers.,It ensures mutual exclusion when updating `read_count`.,It provides mutual exclusion for writers and is used by the first/last reader entering/exiting the critical section.,It signals that a read operation has completed.,It manages the queue of waiting readers.,C,"The text states, '`rw_mutex`: common to reader and writer processes, acts as mutual exclusion for writers, used by first/last reader entering/exiting critical section.'"
What is the initial value of the `read_count` integer variable in the shared data for the first readers-writers problem solution?,1,N (total processes),0,Depends on the number of writers,It's a boolean value.,C,The shared data structures for reader processes include `int read_count = 0;` and it's explicitly 'initialized to 0'.
When does a reader process in the first readers-writers problem solution acquire the `rw_mutex`?,Every time a reader attempts to read.,When `read_count` becomes 0 (the last reader exiting).,When `read_count` becomes 1 (the first reader entering the critical section).,Only when a writer is currently active.,"It never acquires `rw_mutex`, only `mutex`.",C,The reader process structure shows `if (read_count == 1) wait(rw_mutex);` meaning the first reader entering its critical section will wait on `rw_mutex`.
How do reader-writer locks generalize the readers-writers problem solutions?,They allow any number of processes to write concurrently.,"They force all processes to use a single, global lock.","They allow acquiring a lock by specifying a mode (read or write), enabling concurrent reads but exclusive writes.",They eliminate the need for any semaphores or mutexes.,They only support read-only access to shared data.,C,The text explains: 'Acquire lock by specifying mode: read or write. Read mode: multiple processes concurrently. Write mode: only one process (exclusive access).'
The dining-philosophers problem is a classic example of allocating what among several processes?,CPU cores,Memory pages,Network packets,Several resources,Messages in a queue,D,The text states the dining-philosophers problem is an 'example of allocating several resources among several processes.'
What are the two primary goals for a satisfactory solution to the dining-philosophers problem?,Efficiency and low latency.,Deadlock-free and starvation-free allocation.,High throughput and fairness.,Minimal resource usage and high reliability.,Simplicity and portability.,B,The goal is stated as 'deadlock-free and starvation-free allocation.'
"In the basic semaphore solution for the dining-philosophers problem, how is each chopstick represented?",By a binary semaphore.,By a counting semaphore initialized to 5.,By a boolean flag.,By a mutex lock.,By a condition variable.,A,"The text states 'Each chopstick represented by a semaphore' and shows `semaphore chopstick[5];` with 'All `chopstick` elements initialized to 1', which defines them as binary semaphores."
What is the critical problem that can arise from the basic semaphore solution for the dining-philosophers problem?,Starvation of a single philosopher.,Livelock where philosophers continuously pick up and put down chopsticks.,"Deadlock, specifically when all philosophers pick up their left chopstick simultaneously.",Data inconsistency in the bowl of rice.,Race conditions on the `chopstick` array.,C,"The text states, 'Problem: Could create deadlock. Example: All five philosophers hungry, each grabs left chopstick. All `chopstick` elements become 0. Each tries to grab right chopstick, delayed forever.'"
Which of the following is NOT listed as a remedy to the deadlock problem in the semaphore solution for the dining-philosophers problem?,Allow at most four philosophers at the table simultaneously.,A philosopher picks up both chopsticks only if both are available (in a critical section).,An asymmetric solution where odd-numbered philosophers pick left then right; even-numbered pick right then left.,Introducing a global timer to reset chopstick states.,All of the above are listed as remedies.,D,"The listed remedies are: 'Allow at most four philosophers at table simultaneously.', 'Philosopher picks up both chopsticks only if both available (in critical section).', and 'Asymmetric solution: odd-numbered philosopher picks left then right; even-numbered picks right then left.' A global timer is not mentioned."
Does a deadlock-free solution for the dining-philosophers problem automatically guarantee a starvation-free allocation?,"Yes, these two concepts are always mutually exclusive.","Yes, if no deadlock, then no starvation can occur.","No, a deadlock-free solution does not necessarily guard against starvation.",Only if the solution is implemented using binary semaphores.,"Only if the solution is implemented using a first-come, first-served queue.",C,"The text explicitly states, 'Satisfactory solution must guard against starvation (deadlock-free != starvation-free).'"
The deadlock-free solution to the dining-philosophers problem presented in the text primarily utilizes which synchronization construct?,Binary semaphores,Counting semaphores,Monitors,Mutex locks,Spinlocks,C,The section detailing the deadlock-free solution is titled 'Monitor solution' and describes its implementation using a monitor.
"In the monitor solution for the dining-philosophers problem, what are the three possible states a philosopher can be in?","Thinking, Eating, Waiting","Idle, Busy, Blocked","Ready, Running, Sleeping","Thinking, Hungry, Eating","Active, Inactive, Completed",D,"The text defines `enum {THINKING, HUNGRY, EATING} state[5];` for a philosopher's state."
What is the purpose of the `self[5]` condition variable array in the monitor solution for the dining-philosophers problem?,To count the number of available chopsticks.,To ensure mutual exclusion for the shared `state` array.,To allow a philosopher to delay if they are hungry but cannot obtain chopsticks.,To signal when all philosophers have finished eating.,To determine which philosopher eats next based on priority.,C,"The text states, 'Condition variable: `condition self[5];` Allows philosopher `i` to delay if hungry but cannot get chopsticks.'"
"In the monitor solution for the dining-philosophers problem, what function does the `test(int i)` method perform?",It simulates a philosopher eating for a fixed duration.,It decrements `read_count` for a reader process.,"It checks if philosopher `i` can eat (i.e., is hungry and neighbors are not eating), and if so, sets their state to EATING and signals them.",It initializes the chopsticks at the start of the simulation.,It determines the order in which philosophers pick up chopsticks.,C,The `test` function's logic is `if ((state[(i + 4) % 5] != EATING) && (state[i] == HUNGRY) && (state[(i + 1) % 5] != EATING)) { state[i] = EATING; self[i].signal(); }`. This precisely checks if a hungry philosopher can eat and signals them if so.
"According to the text, which of the following guarantees are provided by the monitor solution for the dining-philosophers problem?",It ensures that no philosopher ever starves.,It ensures optimal resource utilization among all philosophers.,It ensures no two neighbors eat simultaneously and no deadlocks.,It guarantees that philosophers pick up chopsticks in a strict order.,It guarantees that all philosophers finish eating within a specific timeframe.,C,"The text states, 'Ensures no two neighbors eat simultaneously and no deadlocks.' It also notes that starvation is 'Possible' but not addressed by the provided solution."
"Based on the section glossary, what is the definition of the 'readers-writers problem'?",A problem where concurrent processes share a single message queue.,A synchronization problem where processes/threads either read or read/write shared data.,A problem ensuring exclusive access to a printer resource.,A classic problem used to test CPU scheduling algorithms for I/O-bound tasks.,A scenario where multiple processes attempt to modify the same file concurrently without control.,B,The glossary defines 'readers-writers problem' as 'Synchronization problem where processes/threads either read or read/write shared data.'
"According to the glossary, what is a 'reader-writer lock'?",A lock exclusively for processes that only read data.,A lock that permits only one process to access an item at any given time.,A lock for item access by read-only and read-write accessors.,A specific type of semaphore used for file system synchronization.,A mechanism designed to prevent deadlocks in distributed systems.,C,The glossary defines 'reader-writer lock' as 'Lock for item access by read-only and read-write accessors.'
The 'dining-philosophers problem' is defined in the glossary as a classic synchronization problem where multiple operators (philosophers) access what simultaneously?,Shared memory segments.,Network connections.,CPU registers.,Multiple items (chopsticks).,Exclusive access to a printer.,D,The glossary defines 'dining-philosophers problem' as 'Classic synchronization problem where multiple operators (philosophers) access multiple items (chopsticks) simultaneously.'
Which of the following best describes the characteristics of the Windows operating system kernel regarding synchronization?,It is a single-threaded kernel that primarily supports batch processing.,It is a multithreaded kernel that supports real-time applications and multiple processors.,It is a monolithic kernel that exclusively uses interrupt masking for all synchronization.,"It is a microkernel designed only for embedded systems, not supporting multiple processors.",It uses a non-preemptive kernel model for all thread synchronization within the kernel.,B,"The text states, ""Windows OS: multithreaded kernel, supports real-time applications and multiple processors."""
How does the Windows kernel typically protect access to global resources in single-processor systems?,By using spinlocks for all critical sections.,By implementing mutex locks at the kernel level.,By temporarily masking interrupts for all interrupt handlers that may access the resource.,By relying solely on user-mode critical-section objects.,By transitioning dispatcher objects to a nonsignaled state permanently.,C,"For single-processor systems, the text indicates the kernel 'temporarily masks interrupts for all interrupt handlers that may access the resource.'"
"In multiprocessor Windows systems, what mechanism does the kernel primarily use to protect access to global resources?",Event objects.,Semaphores.,Interrupt masking for all processors.,Spinlocks.,Critical-section objects.,D,"For multiprocessor systems, the text states, 'Kernel protects global resource access using spinlocks.'"
Which statement accurately describes the use of spinlocks within the Windows kernel on multiprocessor systems?,"Spinlocks are used for all code segments, regardless of duration.",Threads holding a spinlock are frequently preempted for fairness.,Spinlocks are exclusively used for synchronization outside the kernel.,"Spinlocks are used only for short code segments, and the kernel ensures a thread holding a spinlock is never preempted.",Spinlocks are primarily a user-mode synchronization mechanism.,D,"The text specifies, 'Spinlocks used only for short code segments' and 'Kernel ensures thread never preempted while holding a spinlock (for efficiency).'"
What is the primary mechanism used for thread synchronization outside the kernel in Windows?,Atomic integers.,Kernel-level interrupt masking.,Dispatcher objects.,Custom user-defined semaphores only.,Direct hardware register manipulation.,C,"The text states, 'Thread synchronization outside kernel: dispatcher objects.'"
Which of the following is NOT listed as a type of dispatcher object used by threads for synchronization in Windows?,Mutex locks,Semaphores,Events,Timers,Atomic variables,E,"The text lists mutex locks, semaphores, events, and timers as dispatcher objects. Atomic variables are mentioned as a Linux-specific synchronization mechanism."
What is the primary purpose of mutex locks in Windows thread synchronization?,To notify waiting threads when a specific time expires.,To function as a counter for shared resources.,To protect shared data; a thread gains ownership to access it and releases it when finished.,To act as a general-purpose condition variable for any event.,To mask interrupts during critical sections.,C,"The text defines mutex locks as protecting shared data, where a 'thread gains ownership to access, releases when finished.'"
"In Windows, what are 'Events' similar to, and what is their function?",Similar to spinlocks; they protect short code segments.,Similar to condition variables; they notify a waiting thread when a condition occurs.,Similar to atomic integers; they perform mathematical operations atomically.,Similar to mutex locks; they grant exclusive access to shared data.,Similar to timers; they trigger after a specified time interval.,B,"The text states, 'Events: similar to condition variables; notify waiting thread when condition occurs.'"
What is the role of 'Timers' as a dispatcher object in Windows?,They control the preemption of threads in the kernel.,They ensure that only one thread can access a resource at a time.,They notify one (or more) threads when a specified time expires.,They count the number of available resources.,They function as a user-mode mutex without kernel intervention.,C,The text explains that timers 'notify one (or more) threads when specified time expires.'
"When a dispatcher object in Windows is in a 'signaled state', what does it indicate?","The object is not available, and a thread attempting to acquire it will block.","The object is available, and a thread acquiring it will not block.",The object has encountered an error and is unusable.,The object is waiting for an external interrupt.,The object is currently owned by a thread and cannot be acquired.,B,A 'signaled state' indicates 'that the object is available and a thread acquiring it will not block.'
Which statement accurately describes a 'nonsignaled state' for a Windows dispatcher object?,The object is ready for immediate acquisition by multiple threads.,"The object is available, and a thread acquiring it will not block.","The object is not available, and a thread attempting to acquire it will block.",The object has been permanently disabled.,The object is only accessible by kernel threads.,C,A 'nonsignaled state' indicates 'that the object is not available and a thread attempting to acquire it will block.'
What state transition occurs when a mutex lock is acquired by a thread in Windows?,It transitions from a nonsignaled state to a signaled state.,It transitions from a signaled state to a nonsignaled state.,It remains in the signaled state.,It enters a waiting state.,It becomes permanently unavailable.,B,"A mutex lock is 'acquired by a thread when it is in the signaled state, and it transitions to the nonsignaled state.'"
"When a thread releases a mutex lock in Windows, what state transition does the mutex undergo?",It transitions from a signaled state to a nonsignaled state.,It remains in the nonsignaled state.,It transitions back to the signaled state.,It enters a blocked state.,It is destroyed and recreated.,C,"When the thread releases the lock, 'it returns to the signaled state.'"
What happens to a thread in Windows when it attempts to acquire a nonsignaled dispatcher object?,"It immediately proceeds without blocking, as the object is available.","Its state changes from waiting to ready, and it is placed in the ready queue.","Its state changes from ready to waiting, and it is placed in a waiting queue.","The kernel automatically allocates a new, available object for it.",It signals all other waiting threads to also block.,C,"When a thread blocks on a nonsignaled object, its 'state changes from ready to waiting, placed in waiting queue.'"
"When a dispatcher object in Windows moves to a signaled state, what action does the kernel typically take regarding waiting threads?",It immediately blocks all threads currently in the ready queue.,It destroys the object and notifies the system of an error.,It checks for waiting threads and moves one or more of them from the waiting to the ready state.,It increments the object's internal counter without affecting threads.,It converts the object into a critical-section object.,C,When an 'Object moves to signaled state: kernel checks waiting threads. Kernel moves one (or more) threads from waiting to ready state.'
"How many waiting threads does the Windows kernel typically move to the ready state when a mutex becomes signaled, versus when an event becomes signaled?",Mutex: all waiting threads; Event: only one thread.,Mutex: one thread; Event: one thread.,Mutex: one thread; Event: all waiting threads.,Mutex: all waiting threads; Event: all waiting threads.,Mutex: zero threads; Event: all waiting threads.,C,"For a mutex, 'only one thread' is selected, while for an event, 'all waiting threads' are selected."
What is a 'critical-section object' in Windows OS?,A kernel-mode semaphore always requiring kernel intervention.,A user-mode mutex that is often acquired and released without kernel intervention.,A specialized timer used for real-time applications.,A system-wide event that signals all waiting processes.,A type of spinlock used exclusively in single-processor systems.,B,"The glossary defines a 'critical-section object' as a 'User-mode mutex object in Windows OS, often acquired/released without kernel intervention.'"
"On a multiprocessor Windows system, what is the initial behavior of a thread attempting to acquire a critical-section object that is currently held?",It immediately allocates a kernel mutex and yields the CPU.,It blocks indefinitely until the object becomes available.,It first uses a spinlock while waiting.,It signals the operating system to force release of the lock.,It transitions directly to a ready state.,C,"For multiprocessor systems, a critical-section object 'first uses spinlock while waiting.'"
What happens if a thread attempting to acquire a Windows critical-section object spins for too long on a multiprocessor system?,It is immediately terminated by the kernel.,"It continues spinning indefinitely, causing a deadlock.",The acquiring thread allocates a kernel mutex and yields the CPU.,The critical-section object automatically converts to a signaled state.,All other waiting threads are moved to the ready queue.,C,If a critical-section object 'spins too long: acquiring thread allocates kernel mutex and yields CPU.'
How has the Linux kernel's preemption model evolved since Version 2.6?,It changed from fully preemptive to nonpreemptive.,It has remained nonpreemptive to ensure stability.,It changed from nonpreemptive (prior to 2.6) to fully preemptive (now).,It removed all forms of kernel preemption.,"It adopted a hybrid model, selectively preemptive based on user configuration.",C,"The text states, 'Prior to Version 2.6: nonpreemptive kernel... Now: Linux kernel is fully preemptive (task can be preempted while running in kernel).'"
What is described as the simplest synchronization technique in the Linux kernel?,Mutex locks.,Semaphores.,Spinlocks.,Atomic integers.,Critical-section objects.,D,"The text states, 'Atomic integers: Simplest synchronization technique.'"
Which of the following is true regarding atomic integers in the Linux kernel?,They are complex data structures used for protecting multiple variables in race conditions.,All mathematical operations on an `atomic_t` type are performed without interruption.,They incur significant locking overhead due to their robust nature.,They are primarily used for managing thread waiting queues.,"The `atomic_t` data type is transparent, allowing direct integer manipulation.",B,The text states: 'All math operations are atomic (performed without interruption)' for `atomic_t`.
"Consider the following Linux atomic operations: `atomic_set(&counter, 5);`, `atomic_add(10, &counter);`, `atomic_sub(4, &counter);`, `atomic_inc(&counter);`. If `value = atomic_read(&counter);` is called after these operations, what would be the value of `value`?",12,11,10,5,4,A,"Starting with `atomic_set(&counter, 5);` sets counter to 5. Then `atomic_add(10, &counter);` makes it 15. `atomic_sub(4, &counter);` makes it 11. `atomic_inc(&counter);` increments it to 12. So, `value` would be 12."
What is the primary use of mutex locks within the Linux kernel?,To handle interrupt masking for I/O operations.,To implement general-purpose condition variables.,"To protect critical sections within the kernel, where a task sleeps if the lock is unavailable.",To perform atomic arithmetic operations on single integer variables.,To disable kernel preemption for very short durations.,C,"Linux mutex locks 'Protect critical sections within kernel.' and 'If unavailable: task calling mutex_lock() sleeps, awakened when owner invokes mutex_unlock().'"
How do Linux spinlocks behave differently on single-processor machines (like embedded systems) compared to SMP machines?,"On single-processor machines, spinlocks are replaced by mutex locks.","On SMP machines, spinlocks are inappropriate and replaced by semaphores.","On single-processor machines, spinlocks are replaced by enabling/disabling kernel preemption.",Spinlocks are not available in single-processor Linux kernels.,Spinlocks are only used for user-mode synchronization on single-processor systems.,C,"For single-processor machines, 'spinlocks inappropriate. Replaced by enabling/disabling kernel preemption.'"
Which characteristic is shared by both spinlocks and mutex locks in the Linux kernel?,They are recursive locks.,They are designed for long-duration critical sections.,They are nonrecursive locks.,They always cause the acquiring task to sleep if unavailable.,They only operate on atomic integer variables.,C,The text explicitly states: 'Both spinlocks and mutex locks in Linux kernel are nonrecursive.'
What happens if a thread in the Linux kernel attempts to acquire a nonrecursive lock (like a spinlock or mutex) that it already holds?,"The lock is successfully reacquired, as they are recursive by default.","The thread enters an infinite loop, causing a system crash.","The lock is released automatically, then reacquired.",The second attempt to acquire the lock will block the thread.,The kernel silently ignores the second acquisition attempt.,D,"For nonrecursive locks, 'If thread acquires lock, cannot acquire same lock again without releasing it first. Second attempt to acquire will block.'"
"Which system calls are used in Linux to disable and enable kernel preemption, respectively?",`disable_preemption()` and `enable_preemption()`,`lock_kernel()` and `unlock_kernel()`,`preempt_off()` and `preempt_on()`,`preempt_disable()` and `preempt_enable()`,`interrupt_mask()` and `interrupt_unmask()`,D,The Linux approach for preemption control uses '`preempt_disable()` and `preempt_enable()` system calls.'
"In the Linux kernel, what is the purpose of the `preempt_count` counter within a task's `thread-info` structure?",It tracks the total number of times the task has been preempted.,It indicates the number of locks currently held by the task.,It measures the time a task has spent in kernel mode.,It stores the task's priority level for scheduling.,It counts the number of times `preempt_enable()` has been called.,B,`preempt_count`: indicates number of locks held by task.'
How does the `preempt_count` in the Linux kernel change when a task acquires and then releases a lock?,It is decremented upon acquisition and incremented upon release.,It remains unchanged during lock operations.,It is incremented upon acquisition and decremented upon release.,It is reset to zero after each lock operation.,It fluctuates randomly based on system load.,C,When a 'Lock acquired: `preempt_count` incremented. Lock released: `preempt_count` decremented.'
Under what condition is it NOT safe for the Linux kernel to be preempted?,If the `preempt_count` is 0.,If the task is running in user mode.,If the `preempt_count` is greater than 0.,If no `preempt_disable()` calls have ever been made.,If the task is waiting in an I/O queue.,C,If `preempt_count` > 0: not safe to preempt kernel (task holds lock).'
For what duration of lock holding are spinlocks (and kernel preemption disable/enable) typically recommended in the Linux kernel?,"When the lock must be held for a very long period, spanning multiple system calls.",When the lock needs to be acquired recursively by the same thread.,Only when the lock is held for a short duration.,"For any duration, as they are the most versatile synchronization mechanism.",Exclusively for user-mode synchronization.,C,Spinlocks (and kernel preemption disable/enable): only when lock held for short duration.'
When should semaphores or mutex locks be preferred over spinlocks in the Linux kernel?,When the lock needs to be held for a short duration.,When the lock must be held for a longer period.,When atomic operations on single integers are required.,When interrupt masking is the primary concern.,When synchronization is required across different processors in an SMP system for short code segments.,B,Semaphores or mutex locks: when lock must be held for longer period.'
"According to the glossary, what are 'dispatcher objects' in Windows OS?",Hardware-level components that manage CPU scheduling.,"Windows scheduler features controlling dispatching and synchronization, allowing threads to synchronize via mutex locks, semaphores, events, and timers.",User-mode structures that directly manipulate the kernel's process table.,"Objects used exclusively for inter-process communication, not thread synchronization.",A type of nonrecursive lock used to protect critical sections in kernel mode.,B,"The glossary defines 'dispatcher objects' as 'Windows scheduler feature controlling dispatching and synchronization. Threads synchronize via mutex locks, semaphores, events, and timers.'"
"What is the definition of an 'event' in the context of Windows OS scheduling features, as provided in the glossary?",A mechanism for protecting shared data with exclusive access.,A timer that notifies threads when a specified time expires.,A scheduling feature similar to a condition variable.,A system call that disables kernel preemption.,An atomic data type for integer operations.,C,"The glossary defines 'event' as 'Windows OS scheduling feature, similar to a condition variable.'"
What is a 'critical-section object' as defined in the Windows OS context?,A kernel-mode object that always requires kernel intervention for acquisition/release.,A hardware interrupt handler for critical system events.,"A user-mode mutex object, often acquired/released without kernel intervention.",A Linux-specific synchronization primitive for multi-core systems.,A type of semaphore used for resource counting.,C,"The glossary defines 'critical-section object' as 'User-mode mutex object in Windows OS, often acquired/released without kernel intervention.'"
For which level of programmers is the POSIX API primarily available?,Kernel-level developers,Device driver programmers,User-level programmers,System administrators,Network protocol engineers,C,The text states that the 'POSIX API: available for user-level programmers'.
Which statement accurately describes the relationship of the POSIX API with the OS kernel?,It is an integral part of specific OS kernels.,It is a stand-alone operating system.,It is not part of a specific OS kernel but is implemented using host OS tools.,"It is a hardware abstraction layer, not related to the OS.",It replaces the need for any OS kernel.,C,The text clarifies that the POSIX API is 'not part of specific OS kernel' but is 'Implemented using host OS tools'.
Which synchronization methods are covered in the provided text's section on POSIX synchronization?,"Message queues, shared memory, and pipes","Mutex locks, semaphores, and condition variables","Spinlocks, reader-writer locks, and barriers","Atomic operations, signals, and events","Timers, interrupts, and system calls",B,"The text explicitly states: 'This section covers: mutex locks, semaphores, condition variables in Pthreads and POSIX APIs.'"
What is the primary purpose of POSIX mutex locks in Pthreads?,To manage inter-process communication.,To facilitate thread creation.,To protect critical sections of code.,To handle asynchronous events.,To allocate dynamic memory safely.,C,The purpose of POSIX mutex locks is to 'protect critical sections of code'.
What is the data type used for a POSIX mutex lock?,lock_t,mutex_type,pthread_lock_t,pthread_mutex_t,thread_mutex_t,D,The text specifies the data type as 'pthread_mutex_t'.
Which function is used to create and initialize a POSIX mutex lock?,pthread_mutex_create(),pthread_init_mutex(),pthread_mutex_init(),mutex_open(),new_pthread_mutex(),C,The text identifies 'pthread_mutex_init()' as the creation function for mutex locks.
"When invoking pthread_mutex_init(), what value is typically passed as the second parameter for default attributes?",0,TRUE,DEFAULT_ATTRIBUTES,NULL,PTHREAD_MUTEX_DEFAULT,D,The text states that the 'Second parameter: NULL for default attributes'.
What happens if pthread_mutex_lock() is invoked and the mutex is currently unavailable?,The function returns an error immediately.,The calling thread continues execution without acquiring the lock.,The calling thread blocks until the owner invokes pthread_mutex_unlock().,The mutex is automatically released by the system.,A new mutex is created for the calling thread.,C,The text explains: 'If pthread_mutex_lock() invoked and mutex unavailable: calling thread blocks until owner invokes pthread_mutex_unlock()'.
"Which functions are used for acquiring and releasing a POSIX mutex lock, respectively?",lock() and unlock(),acquire_mutex() and release_mutex(),pthread_mutex_lock() and pthread_mutex_unlock(),get_lock() and put_lock(),sem_wait() and sem_post(),C,The functions for acquisition and release are specified as 'pthread_mutex_lock()' and 'pthread_mutex_unlock()'.
"What does a return value of 0 from POSIX mutex lock operations (like init, lock, unlock) signify?",An error occurred.,The operation is still pending.,The operation completed successfully.,The mutex is currently locked.,The mutex is currently unlocked.,C,"The text indicates: 'Return values: 0 for correct operation, nonzero for error'."
"POSIX semaphores, though often provided with Pthreads systems, officially belong to which standard or extension?",The core POSIX standard.,The C++ Standard Library.,The POSIX SEM extension.,The UNIX System V standard.,The Linux Kernel API.,C,The text states: 'Not part of POSIX standard; belong to POSIX SEM extension'.
What are the two types of POSIX semaphores discussed in the text?,Binary and Counting,Global and Local,Named and Unnamed,Read and Write,Shared and Private,C,The text identifies 'Two types: named and unnamed'.
What is the primary difference between named and unnamed POSIX semaphores?,Their data types.,The functions used for their operations.,Their initial values.,How they are created and shared between processes.,The operating systems that support them.,D,The text states: 'Differences: how they are created and shared between processes'.
Which function is used for creating and opening POSIX named semaphores?,sem_create(),sem_init(),sem_open(),pthread_sem_init(),create_named_semaphore(),C,The text specifies 'sem_open()' for 'Creation and opening' of named semaphores.
"In the `sem_open()` function call `sem_open(""SEM"", O_CREAT, 0666, 1)`, what does the `O_CREAT` flag signify?",Open an existing semaphore only.,Create a new semaphore regardless.,Create the semaphore if it does not exist.,Open the semaphore for read-only access.,Open the semaphore exclusively.,C,The text states: 'O_CREAT flag: semaphore created if it doesn't exist'.
What access permissions does the `0666` parameter in `sem_open()` typically grant for a named semaphore?,Execute-only access for the owner.,Read-only access for all users.,Read and write access only for the creating process.,Read and write access for other processes.,No access for other processes.,D,The text explains: '0666: read and write access for other processes'.
What is a significant advantage of using POSIX named semaphores?,They are faster than unnamed semaphores.,They can only be used by threads within the same process.,They are automatically destroyed upon process termination.,Multiple unrelated processes can easily use a common semaphore by name.,They consume less system memory compared to unnamed semaphores.,D,The text highlights the 'Advantage: multiple unrelated processes can easily use common semaphore by name'.
"Which functions correspond to the standard 'wait()' and 'signal()' operations for POSIX named semaphores, respectively?",sem_get() and sem_put(),sem_lock() and sem_unlock(),sem_wait() and sem_post(),acquire_sem() and release_sem(),P() and V(),C,The text maps 'wait() -> sem_wait()' and 'signal() -> sem_post()'.
"According to the section glossary, what defines a POSIX named semaphore?",A scheduling construct usable only by threads in the same process.,A kernel-level construct for inter-thread communication.,A POSIX scheduling construct that exists in the file system and is shareable by unrelated processes.,A data structure for managing shared memory between processes.,A hardware-level synchronization primitive.,C,"The glossary defines 'named semaphore' as a 'POSIX scheduling construct, exists in file system, shareable by unrelated processes'."
Which function is used for creating and initializing POSIX unnamed semaphores?,sem_open(),sem_create_unnamed(),sem_init(),pthread_sem_init(),unnamed_sem_create(),C,The text indicates 'Creation and initialization: sem_init() function' for unnamed semaphores.
"In the `sem_init(&sem, 0, 1)` function call for an unnamed semaphore, what does the second parameter `0` (flag) indicate?",The semaphore is shared across the entire system.,The semaphore is shared only by threads within the creating process.,The semaphore's initial value is zero.,The semaphore is named.,The operation failed to set sharing.,B,The text states: 'Flag 0: semaphore shared only by threads in creating process'.
How can POSIX unnamed semaphores be shared between separate processes?,By passing their name to `sem_open()`.,By creating them with a sharing flag of 0.,By placing them in shared memory and using a nonzero sharing flag.,They cannot be shared between separate processes.,By using a system-wide identifier.,C,The text specifies: 'Nonzero flag: allows sharing between separate processes (by placing in shared memory)'.
Which functions are used for the operations on POSIX unnamed semaphores?,sem_down() and sem_up(),pthread_wait() and pthread_signal(),sem_wait() and sem_post(),acquire_unnamed_sem() and release_unnamed_sem(),Different functions than named semaphores are used.,C,The text clarifies that unnamed semaphores 'uses same sem_wait() and sem_post() as named semaphores'.
"According to the section glossary, what describes a POSIX unnamed semaphore?",A POSIX scheduling construct that exists in the file system.,A semaphore that can be shared by unrelated processes by name.,A POSIX scheduling construct usable only by threads in the same process.,A system-wide resource that requires a mutex lock.,A semaphore that has no initial value.,C,"The glossary defines 'unnamed semaphore' as a 'POSIX scheduling construct, usable only by threads in the same process'."
"What mechanism is used with Pthreads condition variables for locking, considering that the C language does not provide monitors?",Spinlocks are used for locking.,Atomic operations ensure locking.,They automatically acquire a global lock.,The condition variable is associated with a mutex lock.,They rely on hardware-level interrupts for synchronization.,D,The text states: 'Locking accomplished by associating condition variable with a mutex lock'.
What is the data type for a POSIX condition variable?,cond_var_t,pthread_condition_t,condition_t,pthread_cond_t,cond_type,D,The text specifies the data type as 'pthread_cond_t'.
Which function is used to initialize a POSIX condition variable?,pthread_cond_create(),pthread_init_cond(),pthread_cond_init(),cond_var_open(),new_pthread_cond(),C,The text identifies 'pthread_cond_init()' as the initialization function for condition variables.
"When calling pthread_cond_wait(), what must be true about the associated mutex lock?",It must be released immediately before the call.,It must be acquired by the calling thread before the call.,It is optional and can be ignored.,It should be acquired by a different thread.,It is automatically acquired by `pthread_cond_wait()`.,B,The text states: 'Mutex lock must be acquired before pthread_cond_wait() call'.
What happens to the mutex lock when pthread_cond_wait() is invoked by a thread?,It remains locked by the calling thread.,It is automatically destroyed.,"pthread_cond_wait() releases the mutex lock, allowing other threads to access/update shared data.",It is acquired by another waiting thread immediately.,It is ignored by the condition variable.,C,"The text specifies: 'pthread_cond_wait() releases mutex lock, allowing other threads to access/update shared data'."
Why is it important to place the conditional clause for pthread_cond_wait() within a loop?,To ensure the thread spins indefinitely.,To prevent the mutex from being released.,To protect against program errors by rechecking the condition after being signaled.,To signal multiple waiting threads simultaneously.,To acquire the mutex lock faster.,C,The text advises: 'Conditional clause within a loop: important to recheck condition after being signaled (protects against program errors)'.
Which function is used to signal a single waiting thread on a POSIX condition variable?,pthread_cond_broadcast(),pthread_cond_signal_all(),pthread_signal_cond(),pthread_cond_signal(),signal_one_cond(),D,The text states: 'Signaling a condition variable: pthread_cond_signal() function' and clarifies it signals 'one waiting thread'.
What is a key behavior of pthread_cond_signal() concerning the associated mutex lock?,It immediately releases the mutex lock.,It acquires the mutex lock for the signaling thread.,It does NOT release the mutex lock.,It destroys the mutex lock upon completion.,"It makes the mutex available to all threads, regardless of ownership.",C,The text explicitly states: 'pthread_cond_signal() does NOT release mutex lock'.
"After a thread is signaled by pthread_cond_signal(), when does it typically become the owner of the mutex and return from pthread_cond_wait()?",Immediately upon being signaled.,Before the signaling thread has finished its critical section.,Once the signaling thread acquires another mutex.,After the mutex is released by the signaling thread via pthread_mutex_unlock().,It never re-acquires the mutex; it is given to another thread.,D,"The text explains: 'Once mutex released, signaled thread becomes owner of mutex and returns from pthread_cond_wait()'."
Which statement accurately describes Java's support for thread synchronization?,Java introduced thread synchronization features only in Release 1.5.,Java has provided rich support for thread synchronization since its origins.,Java primarily relies on external libraries for thread synchronization.,Java's synchronization mechanisms are limited to basic monitors.,Atomic variables are the original and primary synchronization mechanism in Java.,B,"The text states, 'Java language and API: rich support for thread synchronization since its origins.'"
The provided text covers which of the following Java synchronization mechanisms?,Atomic variables and CAS instruction.,Only Java monitors.,"Reentrant locks, semaphores, and condition variables exclusively.","Java monitors, Reentrant locks, semaphores, and condition variables.",Distributed locks and transactional memory.,D,"The text explicitly lists 'Java monitors (original mechanism)' and 'Reentrant locks, semaphores, condition variables (introduced in Release 1.5)' as covered topics."
"In Java, how many locks are associated with a single object when using Java monitors?","Zero locks, synchronization is managed by a central scheduler.","Multiple locks, one for each synchronized method.",Exactly one lock.,"A dynamic number of locks, depending on contention.",One lock per thread accessing the object.,C,"The text clearly states, 'Every Java object has a single associated lock.'"
What must a thread acquire before it can enter a synchronized method in Java?,A permit from a semaphore.,Ownership of the object's associated lock.,Access to the shared critical section directly.,A unique thread ID from the JVM.,Permission from the operating system's kernel.,B,"The text states, 'synchronized method: entering requires owning the object's lock.'"
How is a method declared as synchronized in Java?,By enclosing its body within a synchronized block.,By implementing the Synchronized interface.,By placing the 'synchronized' keyword in the method definition.,By marking the class as synchronized.,By using an annotation like @Synchronized.,C,"The text specifies, 'Declared by placing synchronized keyword in method definition (e.g., insert(), remove()).'"
"In the context of Java monitors, what is an 'entry set'?",A set of threads that have successfully entered a synchronized method.,A set of threads that are actively executing within a critical section.,A set of threads waiting for an object's lock to become available.,A collection of variables that are protected by the monitor.,A mechanism for threads to register for callbacks when a lock is released.,C,"The glossary defines 'entry set' as 'In Java, the set of threads waiting to enter a monitor.' The main text also states, 'Entry set: set of threads waiting for lock to become available.'"
"When a thread attempts to enter a synchronized method and the object's lock is currently owned by another thread, what is the immediate consequence for the calling thread?",It immediately throws an IllegalMonitorStateException.,It proceeds to execute the method's non-critical sections.,It releases its own lock and tries again later.,It blocks and is placed in the object's entry set.,It bypasses the lock and forces entry.,D,"The text states, 'If lock owned by another thread: calling thread blocks, placed in object's entry set.'"
"When a thread exits a synchronized method and releases the object's lock, what happens if the object's entry set is not empty?",The lock remains unowned until a new thread explicitly requests it.,The thread that just exited re-acquires the lock automatically.,The JVM arbitrarily selects a thread from the entry set to own the lock.,All threads in the entry set are simultaneously granted the lock.,"The entry set is cleared, and all waiting threads are de-scheduled.",C,"The text states, 'If entry set not empty on lock release: JVM arbitrarily selects thread from set to own lock (often FIFO in practice).'"
What is a 'wait set' in Java synchronization?,A set of methods waiting for input from the user.,A set of threads that have completed their execution and are waiting to be terminated.,"A set of threads, each waiting for a specific condition that will allow it to continue.",A queue of tasks waiting to be assigned to worker threads.,A collection of monitor objects waiting for garbage collection.,C,"The glossary defines 'wait set' as 'In Java, a set of threads, each waiting for a condition that will allow it to continue.'"
"When a thread inside a synchronized method calls the wait() method, which of the following actions occur?
1. The thread releases the lock for the object.
2. The thread's state is set to blocked.
3. The thread is placed in the wait set for the object.
4. The thread's priority is increased.",1 and 2 only,"1, 2, and 3 only",2 and 3 only,"1, 3, and 4 only","1, 2, 3, and 4",B,The text explicitly lists these three actions: 'When thread calls wait() method: 1. Releases lock for the object. 2. Thread state set to blocked. 3. Thread placed in wait set for the object.'
"According to the provided text, what is the 'scope' of a lock?",The number of threads that can simultaneously hold the lock.,The geographical area over which the lock is effective.,The time between when a lock is acquired and when it is released.,The specific critical section protected by the lock.,The set of variables that the lock protects.,C,The glossary defines 'scope' as 'The time between when a lock is acquired and when it is released.'
Why is block synchronization generally preferred over synchronized methods when only a small portion of the method manipulates shared data?,Block synchronization is simpler to implement.,Synchronized methods do not provide true mutual exclusion.,"Block synchronization allows for a smaller lock scope, improving concurrency.","Synchronized methods require explicit lock release, unlike blocks.",Block synchronization automatically handles thread interruptions.,C,"The text states, 'synchronized method: large scope if only small part manipulates shared data. Better: synchronize only the block of code manipulating shared data (smaller lock scope).'"
What happens to a thread in the wait set when it is notified?,It immediately re-acquires the lock and resumes execution.,It is terminated and removed from the system.,It is moved to the entry set and becomes eligible to be granted the lock.,It remains in the wait set but changes its state to runnable.,It broadcasts a signal to all other waiting threads.,C,"The text describes, 'when a thread in the wait set is notified, it is moved to the entry set and becomes eligible to be granted the lock.'"
"When the notify() method is invoked, what is its primary effect on threads in the wait set?",It moves all threads from the wait set to the entry set.,It terminates all threads in the wait set.,"It selects an arbitrary thread from the wait set, moves it to the entry set, and sets its state to runnable.",It allows the current thread to acquire a second lock.,It signals all threads in the entry set to proceed.,C,"The text states, 'notify() method: Picks arbitrary thread T from wait set. Moves T from wait set to entry set. Sets state of T from blocked to runnable.'"
"After a thread in the entry set successfully reacquires the lock following a notify() call, what is its next typical action upon resuming from wait()?",It immediately exits the synchronized method.,It throws an InterruptedException.,It rechecks the condition that caused it to wait().,It calls notifyAll() to wake up other threads.,It enters an infinite loop.,C,"The text describes, 'Once T regains lock, returns from wait(), rechecks count.' (Referring to the example with 'while (count == BUFFER_SIZE)' or 'while (count == 0)')."
What happens if the notify() method is called when the object's wait set is empty?,It causes an error.,It has no effect.,It automatically places the calling thread into the wait set.,It signals all threads in the entry set.,It waits indefinitely for a thread to enter the wait set.,B,"The text states, 'notify() ignored if no thread in wait set.'"
Which of the following are identified as the 'original Java mechanisms' for synchronization?,Reentrant locks and Condition variables.,Semaphores and Atomic variables.,"synchronized, wait(), and notify().",ReentrantLock and ReentrantReadWriteLock.,acquire() and release() methods.,C,"The text explicitly states, 'synchronized, wait(), notify() are original Java mechanisms.'"
In what way is a ReentrantLock similar to a synchronized statement?,Both are original Java mechanisms from its origins.,Both require manual release even upon exceptions.,Both are owned by a single thread and provide mutual exclusive access.,Both offer a fairness parameter by default.,Both can be used without an explicit try-finally block.,C,"The text notes, 'Similar to synchronized statement: owned by single thread, provides mutual exclusive access to shared resource.'"
What does the 'reentrant' aspect of a ReentrantLock signify?,The lock can be acquired multiple times by different threads concurrently.,The lock automatically re-acquires itself after being released.,The invoking thread can acquire the lock even if it already owns it.,The lock allows threads to re-enter a critical section without needing to acquire the lock again.,The lock can be used across different JVM instances.,C,"The text states, 'If lock available OR invoking thread already owns it (reentrant): lock() assigns ownership, returns control.'"
Why is the 'try { key.lock(); /* critical section */ } finally { key.unlock(); }' idiom recommended when using ReentrantLock?,To catch checked exceptions thrown by the lock() method.,To prevent the lock from being acquired if the critical section fails.,To ensure the lock is released even if an exception occurs within the critical section.,To allow multiple threads to acquire the lock concurrently in the try block.,To signal other threads that the critical section is available.,C,"The text explicitly states, 'Ensures lock is released (via unlock()) after critical section completes or if exception occurs in try block.' It also mentions lock() doesn't throw checked exceptions."
For what type of concurrency scenario does the ReentrantReadWriteLock provide a specific advantage?,Scenarios where only a single thread needs exclusive access.,Scenarios requiring strict FIFO ordering for all access.,Scenarios with significantly more readers than writers.,Scenarios where distributed locking is necessary.,Scenarios that need automatic lock management.,C,"The text states, 'ReentrantReadWriteLock: Java API also provides this for scenarios with more readers than writers. Allows multiple concurrent readers but only one writer.'"
What is the initial value of a Semaphore set by in its constructor?,A boolean indicating if it's fair or not.,A string representing its name.,An integer representing its initial permit count.,A thread object to associate it with.,The current time in milliseconds.,C,"The text states, 'Constructor: Semaphore(int value). value: initial value of semaphore (negative allowed).'"
Which exception can the acquire() method of a Semaphore throw if the acquiring thread is interrupted?,IllegalMonitorStateException,NullPointerException,InterruptedException,IllegalArgumentException,UnsupportedOperationException,C,"The text mentions, 'acquire() method: throws InterruptedException if acquiring thread interrupted.'"
Why is sem.release() typically placed within a finally clause when using a Semaphore for mutual exclusion?,To ensure the semaphore is released only after successful critical section execution.,To prevent the release() method from throwing an exception.,To guarantee the semaphore is released even if an exception occurs in the critical section.,To allow other threads to acquire the semaphore immediately.,To automatically acquire the semaphore again for the same thread.,C,"The example shows release() in finally and the explanation states, 'release() placed in finally clause to ensure semaphore is released.'"
Condition variables in Java must always be associated with which other synchronization mechanism?,A Thread object.,A Semaphore.,A ReentrantLock.,An AtomicInteger.,A synchronized block.,C,"The text states, 'Must be associated with a reentrant lock for mutual exclusion.'"
What is the correct sequence of steps to create a Condition object in Java's concurrency API?,"Create a Semaphore, then call its newCondition() method.",Create a Condition directly using its constructor.,"Create a ReentrantLock, then invoke its newCondition() method.",Call the wait() method on any object to get a condition.,Declare a synchronized method and the JVM provides one implicitly.,C,The text describes creation as: '1. Create a ReentrantLock. 2. Invoke its newCondition() method.'
The await() and signal() methods of a Condition object provide functionality similar to which other Java methods?,start() and stop(),lock() and unlock(),acquire() and release(),wait() and notify(),get() and set(),D,"The text states, 'Operations: await() and signal() methods. The function of these methods is the same as that of the wait() and signal() methods described in a previous chapter.'"
"Which statement is true regarding the condition variable associated with a basic Java monitor (using synchronized, wait(), notify())?",Each monitor can have multiple named condition variables.,There are no condition variables associated with basic Java monitors.,Each Java monitor is associated with a single unnamed condition variable.,Condition variables for basic monitors must be explicitly created using newCondition().,The condition variable is automatically named after the monitor object.,C,The text explains: 'Java (language level): does not provide named condition variables. Each Java monitor: associated with one unnamed condition variable.'
What is a limitation of the notify() method (used with Java monitors) that Condition variables aim to remedy?,notify() cannot wake up any thread in the wait set.,"notify() always wakes up all waiting threads, even if not needed.",The awakened thread receives no information about why it was notified and must recheck its condition.,"notify() requires the lock to be released immediately, which can cause race conditions.",notify() can only be called from a non-synchronized context.,C,The text points out: 'When Java thread awakened via notify(): receives no info on why; reactivated thread must check condition itself.' And later: 'Condition variables (this section): remedy this by allowing specific thread to be notified.'
"In the doWork(int threadNumber) example demonstrating condition variables, how is mutual exclusion achieved?",The doWork() method is declared as synchronized.,Each thread acquires a unique semaphore before entering.,A ReentrantLock is acquired at the beginning and released at the end.,The await() method inherently provides mutual exclusion.,The signal() method ensures only one thread can proceed.,C,"The example code explicitly shows 'lock.lock()' at the start and 'lock.unlock()' in a 'finally' block. The text also states, 'doWork() does not need to be synchronized. ReentrantLock provides mutual exclusion.'"
"When a thread invokes await() on a Condition variable, which lock is released?",No lock is released; the thread simply pauses.,The monitor lock associated with 'this' object.,The ReentrantLock associated with that specific condition variable.,All locks held by the current thread.,A global system lock.,C,"The text states, 'await() on condition variable releases associated ReentrantLock.'"
"When a thread invokes signal() on a Condition variable, what happens to the lock currently held by the signaling thread?",The lock is immediately released.,The lock is transferred to the signaled thread.,The lock is only released when the signaling thread invokes unlock().,The lock is held indefinitely until another thread calls await().,A new lock is automatically acquired.,C,"The text clarifies, 'signal() only signals condition variable; lock released by unlock().' This means signal() itself doesn't release the lock."
What is a primary consequence of the emergence of multicore systems in application development?,Decreased demand for concurrent applications.,Reduced risk of race conditions and liveness hazards.,Increased pressure to develop concurrent applications.,Simplification of traditional mutex lock implementation.,Elimination of the need for process synchronization techniques.,C,The text states that the 'Emergence of multicore systems: increased pressure to develop concurrent applications.'
Which of the following hazards are specifically mentioned as increasing with the development of concurrent applications?,Memory leaks and buffer overflows.,"Race conditions and liveness hazards (e.g., deadlock).",Compilation errors and runtime exceptions.,Performance bottlenecks due to single-threaded execution.,Stack overflow and heap corruption.,B,"The text indicates that 'Concurrent applications: increased risk of race conditions and liveness hazards (e.g., deadlock).'"
Which of the following are traditionally used to address synchronization issues in concurrent applications?,"Compiler optimizations, garbage collectors, and JIT compilers.","Message queues, remote procedure calls, and distributed transactions.","Mutex locks, semaphores, and monitors.","Virtual memory, paging, and swapping.","Network protocols, firewalls, and encryption algorithms.",C,"The text states, 'Traditionally: mutex locks, semaphores, monitors used to address these.'"
"According to the text, what is the core definition of a 'memory transaction'?",A financial operation involving data exchange between two memory banks.,A sequence of memory read-write operations that are atomic.,A process of encrypting and decrypting data stored in memory.,A method for allocating and deallocating memory blocks dynamically.,A mechanism for virtual memory management.,B,The text defines 'memory transaction' as a 'sequence of memory read-write operations that are atomic.'
"In transactional memory, what happens if all operations within a memory transaction successfully complete?",The operations are aborted and rolled back.,The system generates a fatal error.,The transaction is committed.,The transaction enters a waiting state.,The memory is deallocated.,C,"The text states, 'If all operations complete: transaction committed.'"
What occurs in transactional memory if not all operations within a transaction complete successfully?,The transaction commits partially.,The operations are aborted and rolled back.,The system attempts to re-execute the operations indefinitely.,The memory state remains unchanged from before the transaction started.,A new transaction is automatically initiated.,B,The text specifies that 'Otherwise [if operations do not complete]: operations aborted and rolled back.'
From which field did the idea of transactional memory originate before being applied to process synchronization?,Artificial intelligence.,Network security.,Operating system kernel design.,Database theory.,Computer graphics.,D,"The text mentions, 'Idea originated in database theory, now used for process synchronization.'"
Which of the following are identified as problems with traditional locking mechanisms when designing multithreaded applications?,Increased memory usage and CPU caching issues.,Deadlock and poor scalability with increasing threads due to high contention.,Difficulty in debugging single-threaded programs.,Inability to support concurrent read access.,Limited support for object-oriented programming paradigms.,B,"The text highlights 'deadlock, poor scalability with increasing threads (high contention for lock ownership)' as problems with traditional locking."
What is the purpose of the `atomic{S}` construct in programming languages utilizing transactional memory?,To declare a block of code that is never executed.,To ensure operations in S execute as a transaction.,To mark S as a section for manual memory allocation.,To specify S as a region where race conditions are intentionally allowed.,To define S as a function that cannot be called concurrently.,B,The text states that the 'Construct `atomic{S}`: ensures operations in `S` execute as a transaction.'
One significant advantage of transactional memory over traditional locking is that atomicity is guaranteed by whom?,The application developer.,The operating system kernel.,The transactional memory system itself.,The database administrator.,"The compiler, but only with specific flags.",C,The text lists as an advantage: 'Transactional memory system (not developer) guarantees atomicity.'
"Why is deadlock not possible when using transactional memory, as described in the text?",It uses a global lock that prevents all contention.,It automatically detects and resolves deadlocks.,No locks are involved in its operation.,"It relies on a first-come, first-served scheduling policy.",It distributes memory transactions across multiple machines.,C,The text states as an advantage: 'No locks involved -> deadlock not possible.'
What capability does a transactional memory system possess regarding concurrent execution that is difficult for a programmer to manage with increasing thread counts?,Automatically generating documentation for concurrent code.,"Identifying concurrent execution of statements in atomic blocks (e.g., concurrent read access).",Optimizing network latency for distributed transactions.,Preventing all forms of resource contention automatically.,Debugging errors in single-threaded legacy code.,B,"The text notes that the 'System can identify concurrent execution of statements in atomic blocks (e.g., concurrent read access)' and that this is difficult for programmers as thread counts grow."
How is Software Transactional Memory (STM) typically implemented to manage transactions?,By requiring specialized hardware co-processors.,"By inserting instrumentation code inside transaction blocks, usually by a compiler.",By modifying the operating system kernel.,By relying solely on explicit developer-managed locks.,By using dedicated network protocols.,B,The text specifies that STM 'Works by inserting instrumentation code inside transaction blocks (by compiler).'
What is a key characteristic of Software Transactional Memory (STM) regarding hardware?,It requires modification of existing cache hierarchies.,It necessitates specialized transactional processing units.,It uses hardware cache coherency protocols exclusively.,No special hardware is needed.,It performs best on single-core processors.,D,The text states for STM: 'Implemented exclusively in software; no special hardware needed.'
What does Hardware Transactional Memory (HTM) utilize to manage and resolve conflicts for shared data in separate processors' caches?,Software-only instrumentation code.,Traditional mutex locks and semaphores.,Hardware cache hierarchies and cache coherency protocols.,Operating system-level virtual memory management.,Distributed ledger technology.,C,The text states that HTM 'Uses hardware cache hierarchies and cache coherency protocols.'
"Compared to Software Transactional Memory (STM), what is an advantage of Hardware Transactional Memory (HTM) concerning code instrumentation?",It requires extensive manual code instrumentation.,It introduces significant overhead due to complex instrumentation.,"It requires no special code instrumentation, resulting in less overhead.",It performs instrumentation at runtime only.,It uses the same instrumentation approach as STM.,C,The text indicates that HTM 'Requires no special code instrumentation (less overhead than STM).'
In what type of computing environment does OpenMP primarily support parallel programming?,Distributed memory systems.,Message-passing interface (MPI) clusters.,Shared-memory environments.,Cloud-based serverless architectures.,Single-core embedded systems.,C,The text states: 'OpenMP supports parallel programming in a shared-memory environment.'
What does OpenMP include as part of its framework for parallel programming?,A dedicated operating system and file system.,A set of compiler directives and an API.,A new programming language and runtime environment.,A hardware abstraction layer and device drivers.,A graphical user interface builder.,B,The text states OpenMP 'Includes: set of compiler directives and an API.'
What is the effect of the `#pragma omp parallel` compiler directive in OpenMP?,It causes the following code to be compiled sequentially.,"It defines the following code as a parallel region, performed by threads equal to processing cores.",It designates the following code as a critical section for exclusive access.,It explicitly instructs the developer to manage thread creation manually.,It includes an external library for network communication.,B,"The text explains that with `#pragma omp parallel`, the 'Code following this is a parallel region. Performed by number of threads equal to processing cores.'"
What is a significant advantage of OpenMP regarding thread creation and management?,It requires developers to manually create and destroy threads.,"The OpenMP library handles thread creation and management, not the application developers.","It only supports a fixed number of threads, regardless of processing cores.",It completely eliminates the need for threads in parallel applications.,It delegates thread management entirely to the operating system without any OpenMP involvement.,B,The text lists as an advantage: 'OpenMP library handles thread creation and management (not application developers' responsibility).'
What is the primary purpose of the `#pragma omp critical` compiler directive in OpenMP?,To indicate a section of code that is prone to errors.,To specify a code region as a critical section where only one thread is active at a time.,To mark a block of code for parallel execution by multiple threads.,To define a function that must be executed at a specific time.,To declare global variables for shared access.,B,The text states that `#pragma omp critical` 'Specifies code region as a critical section. Only one thread active at a time. Ensures threads do not generate race conditions.'
How does an OpenMP critical-section directive behave if a thread tries to enter it while another thread is already active within the same critical section?,The calling thread generates a runtime error.,The calling thread preempts the active thread.,"The calling thread proceeds immediately, leading to a race condition.",The calling thread blocks until the owner exits.,The critical section is automatically expanded to accommodate both threads.,D,The text states: 'If thread tries to enter when another is active (owns section): calling thread blocks until owner exits.'
What is true about multiple critical sections in OpenMP that are identified by a name?,"Only one thread can be active in any critical section, regardless of name.",A thread can be active in multiple named critical sections simultaneously.,The rule specifies only one thread active in critical section of the *same name* simultaneously.,Naming critical sections disables their synchronization properties.,Naming is purely for documentation purposes and has no functional impact.,C,The text explains: 'Multiple critical sections: each can be named; rule specifies only one thread active in critical section of same name simultaneously.'
"Despite its advantages, what responsibility still falls upon developers when using OpenMP to prevent race conditions?",They must rewrite the OpenMP library for their specific hardware.,They must manually manage thread creation and destruction.,They must still identify possible race conditions and adequately protect shared data.,They are required to use only single-threaded applications.,They must design new cache coherency protocols.,C,The text lists as disadvantages: 'Developers must still identify possible race conditions. Must adequately protect shared data using directive.'
"What is a potential issue that can still occur when using OpenMP critical sections, similar to mutex locks?",Performance degradation due to excessive parallelization.,Memory fragmentation.,"Deadlock, if two or more critical sections are identified.",Unpredictable program termination.,Automatic re-execution of failed transactions.,C,The text states as a disadvantage: 'Deadlock still possible if two or more critical sections are identified (behaves like mutex lock).'
"Which of the following is a defining characteristic of imperative (or procedural) programming languages, such as C, C++, Java, and C#?",They primarily operate without maintaining state.,"Variables, once defined, are immutable.",They implement state-based algorithms where program state is mutable.,They are designed to eliminate all concurrency issues automatically.,They only support functional programming paradigms.,C,The text describes imperative languages as implementing 'state-based algorithms' where 'Program state is mutable (variables can change values).'
"What is the fundamental difference in programming paradigm between functional languages and imperative languages, as described in the text?","Functional languages are compiled, while imperative languages are interpreted.","Functional languages utilize graphical interfaces, while imperative languages are text-based.","Functional languages do not maintain state, while imperative languages do.","Functional languages are strictly for scientific computing, while imperative languages are for general purpose.",Functional languages require more memory.,C,The text states that a 'Fundamental difference: [functional languages] do not maintain state' in contrast to imperative languages that 'Implement state-based algorithms'.
"What is a key property of variables in functional programming languages, once they have been defined and assigned a value?",Their value can be changed at any time.,Their value is mutable only within specific critical sections.,Their value is immutable and cannot change.,Their value can only be modified by the operating system.,They are automatically garbage collected immediately after assignment.,C,"The text states for functional languages: 'Once variable defined and assigned value, its value is immutable (cannot change).'"
"Due to the disallowance of mutable state, what major concurrency problems are generally nonexistent in functional programming languages?",Memory leaks and buffer overflows.,Runtime exceptions and syntax errors.,Race conditions and deadlocks.,Performance bottlenecks in single-threaded execution.,Issues with distributed consensus.,C,The text states for functional languages: 'Because mutable state disallowed: no concern with race conditions and deadlocks. Most problems addressed in this chapter are nonexistent.'
Which of the following functional languages is specifically mentioned as having gained attention for its concurrency support and ease of developing parallel applications?,C#.,Java.,Erlang.,C++.,Python.,C,The text lists 'Erlang: gained attention for concurrency support and ease of developing parallel applications' as an example.
"Based on the section glossary, what is the definition of 'transactional memory'?",A type of memory used for financial transactions.,Memory that supports advanced encryption algorithms.,Memory designed for single-threaded applications.,A type of memory supporting memory transactions.,Volatile memory that loses data upon power loss.,D,The glossary defines 'transactional memory' as 'Type of memory supporting memory transactions.'
"According to the glossary, what is an 'imperative language' (also known as a 'procedural language')?",A language that emphasizes immutable data structures.,A language for implementing state-based algorithms.,A language used exclusively for hardware programming.,A language that does not require states to be managed.,A language focused on parallel execution without explicit synchronization.,B,"The glossary defines both 'imperative language' and 'procedural language' as 'Language for implementing state-based algorithms (e.g., C, C++, Java, C#).'"
How does the glossary define a 'functional language'?,A programming language that requires states to be explicitly managed by programs.,A language primarily designed for database queries.,A programming language that does not require states to be managed by programs written in it.,A language that uses procedural calls exclusively.,A language that only supports concurrent execution.,C,"The glossary defines 'functional language' as a 'Programming language that does not require states to be managed by programs written in it (e.g., Erlang, Scala).'"
Which type of transactional memory implementation generally has less overhead because it requires no special code instrumentation?,Software Transactional Memory (STM),Hardware Transactional Memory (HTM),Hybrid Transactional Memory (HyTM),Distributed Transactional Memory (DTM),Compiler-assisted Transactional Memory (CATM),B,The text states for HTM: 'Requires no special code instrumentation (less overhead than STM).'
What is the current trend regarding the status of transactional memory implementation?,It has seen widespread implementation for many years.,It is being phased out due to inherent limitations.,The growth of multicore systems and emphasis on concurrent programming has prompted significant research.,It remains a theoretical concept with no practical applications.,"It is only used in highly specialized, niche applications.",C,The text notes its 'Status: existed for years without widespread implementation' but 'Current trend: growth of multicore systems and emphasis on concurrent/parallel programming has prompted significant research.'
What specific hardware modification is required for Hardware Transactional Memory (HTM) implementation?,Addition of specialized GPU units.,Modification of existing cache hierarchies and cache coherency protocols.,Installation of a dedicated transactional memory chip.,Redesign of the system's bus architecture.,Upgrading to Solid State Drives.,B,The text states for HTM: 'Requires modification of existing cache hierarchies and cache coherency protocols.'
The behavior of an OpenMP critical-section directive is described as being much like what traditional synchronization primitives?,Message queues or pipes.,Binary semaphore or mutex lock.,Condition variables or event flags.,Shared memory segments or files.,Remote procedure calls or sockets.,B,The text states: 'Behavior of critical-section directive: Much like binary semaphore or mutex lock.'
What is generally considered an advantage of the OpenMP critical-section directive compared to standard mutex locks?,It guarantees freedom from all deadlocks.,It automatically detects and resolves all race conditions.,It is generally considered easier to use.,It supports distributed memory environments natively.,It requires no explicit directives from the developer.,C,The text lists as an advantage: 'Generally considered easier to use than standard mutex locks.'
"With the current emphasis on concurrent/parallel programming for multicore systems, what type of programming languages are gaining greater focus?",Assembly languages.,Imperative languages.,Object-oriented languages (excluding functional features).,Functional programming languages.,Markup languages.,D,The text states: 'Current emphasis on concurrent/parallel programming for multicore systems: greater focus on functional programming languages.'
Which pair of languages are provided as examples of functional programming languages?,C and C++.,Java and C#.,Erlang and Scala.,Python and Ruby.,Fortran and COBOL.,C,The text lists 'Erlang' and 'Scala' as examples of functional languages.
Which of the following are explicitly listed as classic process synchronization problems?,"Bounded-buffer problem, Readers-writers problem, Dining-philosophers problem","Deadlock problem, Starvation problem, Livelock problem","Producer-consumer problem, Critical-section problem, Mutual exclusion problem","Memory leak problem, Race condition problem, Priority inversion problem","File locking problem, Database concurrency problem, Network latency problem",A,"The text lists the Bounded-buffer, Readers-writers, and Dining-philosophers problems as classic process synchronization problems."
"According to the text, which of the following tools are generally used for solving process synchronization problems?","Mutex locks, Semaphores, Monitors, Condition variables","Atomic variables, Spinlocks, Dispatcher objects","Transactional memory, OpenMP, Functional languages","Events, Named semaphores, Unnamed semaphores","Critical sections, Race conditions, Deadlocks",A,"The text states that solutions use 'Mutex locks, Semaphores, Monitors, Condition variables' from the 'Synchronization Tools' chapter."
What primary objects does Windows synchronization utilize?,Dispatcher objects,Event objects,Mutex locks,Spinlocks,Semaphores,A,Windows synchronization 'Uses dispatcher objects'.
How does Windows implement its synchronization tools according to the provided text?,By using events,By using dispatcher objects directly as tools,By relying on shared memory segments,By incorporating POSIX API,By implementing atomic variables,A,Windows synchronization 'Uses events to implement synchronization tools'.
Which of the following synchronization mechanisms are explicitly mentioned as being used in Linux to protect against race conditions?,"Atomic variables, Spinlocks, Mutex locks","Dispatcher objects, Events","Named semaphores, Unnamed semaphores","Monitors, Reentrant locks","Transactional memory, OpenMP",A,"Linux synchronization 'Includes atomic variables, Includes spinlocks, Includes mutex locks'."
The POSIX API provides which of the following synchronization tools?,"Mutex locks, Semaphores, Condition variables","Dispatcher objects, Atomic variables","Monitors, Reentrant locks","Spinlocks, Events","Transactional memory, OpenMP",A,"The POSIX API 'Provides mutex locks, Provides semaphores, Provides condition variables'."
What are the two forms of semaphores provided by the POSIX API?,Named semaphores and Unnamed semaphores,Binary semaphores and Counting semaphores,Local semaphores and Global semaphores,System V semaphores and POSIX semaphores,Recursive semaphores and Non-recursive semaphores,A,The text explicitly states 'Two forms of semaphores: Named semaphores' and 'Unnamed semaphores'.
What is a key characteristic of POSIX named semaphores?,They are easily accessed by unrelated processes by name.,They require placement in shared memory to be shared.,They cannot be shared easily among processes.,They are primarily used for thread synchronization within a single process.,"They are built directly into the language level, not just the API.",A,Named semaphores are described as 'easily accessed by unrelated processes by name'.
What is a key characteristic of POSIX unnamed semaphores?,They cannot be shared as easily; require placement in shared memory.,They are easily accessed by unrelated processes by name.,They are typically used for inter-process communication directly.,They do not suffer from the critical-section problem.,They are managed by dispatcher objects.,A,Unnamed semaphores 'cannot be shared as easily; require placement in shared memory'.
Which of the following synchronization tools are available in Java according to the text?,"Monitors, Reentrant locks, Semaphores, Condition variables","Dispatcher objects, Atomic variables, Spinlocks","Named semaphores, Unnamed semaphores","Mutex locks, OpenMP, Transactional memory","Readers-writers locks, Bounded-buffer solutions",A,"Java's 'Available tools' are listed as 'Monitors, Reentrant locks, Semaphores, Condition variables'."
"In Java, which synchronization tool is provided at the language level?",Monitors,Reentrant locks,Semaphores,Condition variables,Mutex locks,A,Monitors in Java are listed as 'provided at language level'.
Which of the following Java synchronization tools are supported by its API?,"Reentrant locks, Semaphores, Condition variables",Monitors only,Mutex locks only,All listed tools are language-level,All listed tools are API-supported,A,"Reentrant locks, Semaphores, and Condition variables in Java are listed as 'supported by API'."
What alternative approaches to the critical-section problem are mentioned in the text?,"Transactional memory, OpenMP, Functional languages","Mutex locks, Semaphores, Monitors","Atomic variables, Spinlocks, Dispatcher objects","Named semaphores, Unnamed semaphores, Events","Bounded-buffer, Readers-writers, Dining-philosophers",A,"The text lists 'Transactional memory, OpenMP, Functional languages' as 'Alternative approaches to critical-section problem'."
"What is a fundamental characteristic of functional languages that distinguishes them from procedural languages, according to the text?",They do not maintain state.,They extensively use shared memory for communication.,They are primarily designed for embedded systems.,They are prone to race conditions and deadlocks.,They rely on dispatcher objects for synchronization.,A,"Functional languages, unlike procedural languages, 'do not maintain state'."
Why are functional languages generally immune from race conditions and critical sections?,Because they do not maintain state.,Because they heavily rely on mutex locks and semaphores.,Because they use transactional memory extensively.,Because they are a procedural programming paradigm.,Because they are optimized for single-threaded execution.,A,"Functional languages 'do not maintain state', which makes them 'Generally immune from race conditions and critical sections'."
