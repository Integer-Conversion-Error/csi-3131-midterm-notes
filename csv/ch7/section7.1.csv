Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
"Which of the following was a primary focus of the previous chapter on synchronization tools, according to the introduction?",Applying synchronization tools to classic problems.,"Exploring synchronization mechanisms in Linux, UNIX, and Windows.",The critical-section problem and race conditions with shared data.,Describing API details for Java and POSIX systems.,Designing and developing solutions using POSIX and Java APIs.,C,The introduction states that the 'Previous chapter: Synchronization Tools. Focused on critical-section problem and race conditions with shared data.'
Which of the following is NOT listed as a higher-level synchronization tool examined in the previous chapter?,Mutex locks,Semaphores,Monitors,Memory barriers,All of the above were listed as higher-level tools.,D,"The text states 'Low-level hardware: memory barriers, compare-and-swap. Higher-level: mutex locks, semaphores, monitors.' Therefore, memory barriers are a low-level hardware tool."
What type of liveness hazard was specifically mentioned as a challenge discussed in the previous chapter?,Starvation,Deadlocks,Priority inversion,Livelock,Race conditions,B,The introduction states that the previous chapter 'Discussed challenges: liveness hazards like deadlocks.'
What is a primary purpose for using classic synchronization problems in computer science?,To benchmark CPU clock speeds.,To test new synchronization schemes.,To illustrate the benefits of single-threaded programming.,To analyze network bandwidth utilization.,To develop new hardware architectures.,B,The text states that classic problems are 'Used for testing new synchronization schemes.'
What synchronization primitive is traditionally used for solving classic concurrency-control problems?,Spinlocks,Condition variables,Monitors,Semaphores,Mutex locks,D,"The text states, 'Solutions traditionally use semaphores; mutex locks can be used for binary semaphores in actual implementations.'"
"In the bounded-buffer problem, what is the initial value of the `mutex` semaphore?",0,N (representing total buffers),1,Any positive integer,Undefined,C,The shared data structure for the bounded-buffer problem specifies `semaphore mutex = 1;` and describes it as 'initialized to 1'.
What is the primary function of the `empty` semaphore in the bounded-buffer problem?,To ensure mutual exclusion when accessing the buffer pool.,To count the number of full buffers available.,To count the number of empty buffers available.,To signal the producer when the buffer is full.,To track the total number of items produced.,C,"The text explains, '`empty`: counts empty buffers, initialized to `N`.'"
Which sequence of `wait` operations is performed by the producer process in the bounded-buffer problem?,wait(mutex); wait(empty);,wait(full); wait(mutex);,wait(empty); wait(mutex);,wait(mutex); wait(full);,wait(empty); wait(full);,C,The producer process structure shows `wait(empty); wait(mutex);` before the item is added to the buffer.
Which sequence of `signal` operations is performed by the consumer process after removing an item from the buffer in the bounded-buffer problem?,signal(full); signal(mutex);,signal(empty); signal(mutex);,signal(mutex); signal(full);,signal(mutex); signal(empty);,signal(full); signal(empty);,D,The consumer process structure shows `signal(mutex); signal(empty);` after an item is removed from the buffer.
What is the fundamental requirement for writers in the readers-writers problem?,Writers must always have higher priority than readers.,Writers must ensure all readers have completed before starting.,Writers must have exclusive access to the database while writing.,"Writers must never block, even if readers are active.",Writers should only update a copy of the database.,C,The text explicitly states: 'Requirement: Writers must have exclusive access while writing.'
"In the 'First readers-writers problem' variation, what is the behavior regarding readers and writers?",Writers are given priority over readers to prevent starvation.,"If a writer is waiting, no new readers may start.",No reader waits unless a writer already has permission; readers don't wait for other readers if a writer is waiting.,Both readers and writers must acquire a single mutex for all access.,It ensures fairness by alternating between readers and writers.,C,The text defines the 'First readers-writers problem' as: 'No reader waits unless a writer already has permission. Readers don't wait for other readers if a writer is waiting.'
Which type of process is susceptible to starvation in the solution to the 'First readers-writers problem'?,Readers,Writers,Both readers and writers,"Neither, the solution prevents all starvation",Only processes with low priority,B,"The text states under 'Starvation': 'Solutions may lead to starvation (writers in first case, readers in second).'"
"In the provided solution to the first readers-writers problem, what is the role of the `rw_mutex` semaphore?",It counts the total number of readers.,It ensures mutual exclusion when updating `read_count`.,It provides mutual exclusion for writers and is used by the first/last reader entering/exiting the critical section.,It signals that a read operation has completed.,It manages the queue of waiting readers.,C,"The text states, '`rw_mutex`: common to reader and writer processes, acts as mutual exclusion for writers, used by first/last reader entering/exiting critical section.'"
What is the initial value of the `read_count` integer variable in the shared data for the first readers-writers problem solution?,1,N (total processes),0,Depends on the number of writers,It's a boolean value.,C,The shared data structures for reader processes include `int read_count = 0;` and it's explicitly 'initialized to 0'.
When does a reader process in the first readers-writers problem solution acquire the `rw_mutex`?,Every time a reader attempts to read.,When `read_count` becomes 0 (the last reader exiting).,When `read_count` becomes 1 (the first reader entering the critical section).,Only when a writer is currently active.,"It never acquires `rw_mutex`, only `mutex`.",C,The reader process structure shows `if (read_count == 1) wait(rw_mutex);` meaning the first reader entering its critical section will wait on `rw_mutex`.
How do reader-writer locks generalize the readers-writers problem solutions?,They allow any number of processes to write concurrently.,"They force all processes to use a single, global lock.","They allow acquiring a lock by specifying a mode (read or write), enabling concurrent reads but exclusive writes.",They eliminate the need for any semaphores or mutexes.,They only support read-only access to shared data.,C,The text explains: 'Acquire lock by specifying mode: read or write. Read mode: multiple processes concurrently. Write mode: only one process (exclusive access).'
The dining-philosophers problem is a classic example of allocating what among several processes?,CPU cores,Memory pages,Network packets,Several resources,Messages in a queue,D,The text states the dining-philosophers problem is an 'example of allocating several resources among several processes.'
What are the two primary goals for a satisfactory solution to the dining-philosophers problem?,Efficiency and low latency.,Deadlock-free and starvation-free allocation.,High throughput and fairness.,Minimal resource usage and high reliability.,Simplicity and portability.,B,The goal is stated as 'deadlock-free and starvation-free allocation.'
"In the basic semaphore solution for the dining-philosophers problem, how is each chopstick represented?",By a binary semaphore.,By a counting semaphore initialized to 5.,By a boolean flag.,By a mutex lock.,By a condition variable.,A,"The text states 'Each chopstick represented by a semaphore' and shows `semaphore chopstick[5];` with 'All `chopstick` elements initialized to 1', which defines them as binary semaphores."
What is the critical problem that can arise from the basic semaphore solution for the dining-philosophers problem?,Starvation of a single philosopher.,Livelock where philosophers continuously pick up and put down chopsticks.,"Deadlock, specifically when all philosophers pick up their left chopstick simultaneously.",Data inconsistency in the bowl of rice.,Race conditions on the `chopstick` array.,C,"The text states, 'Problem: Could create deadlock. Example: All five philosophers hungry, each grabs left chopstick. All `chopstick` elements become 0. Each tries to grab right chopstick, delayed forever.'"
Which of the following is NOT listed as a remedy to the deadlock problem in the semaphore solution for the dining-philosophers problem?,Allow at most four philosophers at the table simultaneously.,A philosopher picks up both chopsticks only if both are available (in a critical section).,An asymmetric solution where odd-numbered philosophers pick left then right; even-numbered pick right then left.,Introducing a global timer to reset chopstick states.,All of the above are listed as remedies.,D,"The listed remedies are: 'Allow at most four philosophers at table simultaneously.', 'Philosopher picks up both chopsticks only if both available (in critical section).', and 'Asymmetric solution: odd-numbered philosopher picks left then right; even-numbered picks right then left.' A global timer is not mentioned."
Does a deadlock-free solution for the dining-philosophers problem automatically guarantee a starvation-free allocation?,"Yes, these two concepts are always mutually exclusive.","Yes, if no deadlock, then no starvation can occur.","No, a deadlock-free solution does not necessarily guard against starvation.",Only if the solution is implemented using binary semaphores.,"Only if the solution is implemented using a first-come, first-served queue.",C,"The text explicitly states, 'Satisfactory solution must guard against starvation (deadlock-free != starvation-free).'"
The deadlock-free solution to the dining-philosophers problem presented in the text primarily utilizes which synchronization construct?,Binary semaphores,Counting semaphores,Monitors,Mutex locks,Spinlocks,C,The section detailing the deadlock-free solution is titled 'Monitor solution' and describes its implementation using a monitor.
"In the monitor solution for the dining-philosophers problem, what are the three possible states a philosopher can be in?","Thinking, Eating, Waiting","Idle, Busy, Blocked","Ready, Running, Sleeping","Thinking, Hungry, Eating","Active, Inactive, Completed",D,"The text defines `enum {THINKING, HUNGRY, EATING} state[5];` for a philosopher's state."
What is the purpose of the `self[5]` condition variable array in the monitor solution for the dining-philosophers problem?,To count the number of available chopsticks.,To ensure mutual exclusion for the shared `state` array.,To allow a philosopher to delay if they are hungry but cannot obtain chopsticks.,To signal when all philosophers have finished eating.,To determine which philosopher eats next based on priority.,C,"The text states, 'Condition variable: `condition self[5];` Allows philosopher `i` to delay if hungry but cannot get chopsticks.'"
"In the monitor solution for the dining-philosophers problem, what function does the `test(int i)` method perform?",It simulates a philosopher eating for a fixed duration.,It decrements `read_count` for a reader process.,"It checks if philosopher `i` can eat (i.e., is hungry and neighbors are not eating), and if so, sets their state to EATING and signals them.",It initializes the chopsticks at the start of the simulation.,It determines the order in which philosophers pick up chopsticks.,C,The `test` function's logic is `if ((state[(i + 4) % 5] != EATING) && (state[i] == HUNGRY) && (state[(i + 1) % 5] != EATING)) { state[i] = EATING; self[i].signal(); }`. This precisely checks if a hungry philosopher can eat and signals them if so.
"According to the text, which of the following guarantees are provided by the monitor solution for the dining-philosophers problem?",It ensures that no philosopher ever starves.,It ensures optimal resource utilization among all philosophers.,It ensures no two neighbors eat simultaneously and no deadlocks.,It guarantees that philosophers pick up chopsticks in a strict order.,It guarantees that all philosophers finish eating within a specific timeframe.,C,"The text states, 'Ensures no two neighbors eat simultaneously and no deadlocks.' It also notes that starvation is 'Possible' but not addressed by the provided solution."
"Based on the section glossary, what is the definition of the 'readers-writers problem'?",A problem where concurrent processes share a single message queue.,A synchronization problem where processes/threads either read or read/write shared data.,A problem ensuring exclusive access to a printer resource.,A classic problem used to test CPU scheduling algorithms for I/O-bound tasks.,A scenario where multiple processes attempt to modify the same file concurrently without control.,B,The glossary defines 'readers-writers problem' as 'Synchronization problem where processes/threads either read or read/write shared data.'
"According to the glossary, what is a 'reader-writer lock'?",A lock exclusively for processes that only read data.,A lock that permits only one process to access an item at any given time.,A lock for item access by read-only and read-write accessors.,A specific type of semaphore used for file system synchronization.,A mechanism designed to prevent deadlocks in distributed systems.,C,The glossary defines 'reader-writer lock' as 'Lock for item access by read-only and read-write accessors.'
The 'dining-philosophers problem' is defined in the glossary as a classic synchronization problem where multiple operators (philosophers) access what simultaneously?,Shared memory segments.,Network connections.,CPU registers.,Multiple items (chopsticks).,Exclusive access to a printer.,D,The glossary defines 'dining-philosophers problem' as 'Classic synchronization problem where multiple operators (philosophers) access multiple items (chopsticks) simultaneously.'
