Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
Which of the following best describes the characteristics of the Windows operating system kernel regarding synchronization?,It is a single-threaded kernel that primarily supports batch processing.,It is a multithreaded kernel that supports real-time applications and multiple processors.,It is a monolithic kernel that exclusively uses interrupt masking for all synchronization.,"It is a microkernel designed only for embedded systems, not supporting multiple processors.",It uses a non-preemptive kernel model for all thread synchronization within the kernel.,B,"The text states, ""Windows OS: multithreaded kernel, supports real-time applications and multiple processors."""
How does the Windows kernel typically protect access to global resources in single-processor systems?,By using spinlocks for all critical sections.,By implementing mutex locks at the kernel level.,By temporarily masking interrupts for all interrupt handlers that may access the resource.,By relying solely on user-mode critical-section objects.,By transitioning dispatcher objects to a nonsignaled state permanently.,C,"For single-processor systems, the text indicates the kernel 'temporarily masks interrupts for all interrupt handlers that may access the resource.'"
"In multiprocessor Windows systems, what mechanism does the kernel primarily use to protect access to global resources?",Event objects.,Semaphores.,Interrupt masking for all processors.,Spinlocks.,Critical-section objects.,D,"For multiprocessor systems, the text states, 'Kernel protects global resource access using spinlocks.'"
Which statement accurately describes the use of spinlocks within the Windows kernel on multiprocessor systems?,"Spinlocks are used for all code segments, regardless of duration.",Threads holding a spinlock are frequently preempted for fairness.,Spinlocks are exclusively used for synchronization outside the kernel.,"Spinlocks are used only for short code segments, and the kernel ensures a thread holding a spinlock is never preempted.",Spinlocks are primarily a user-mode synchronization mechanism.,D,"The text specifies, 'Spinlocks used only for short code segments' and 'Kernel ensures thread never preempted while holding a spinlock (for efficiency).'"
What is the primary mechanism used for thread synchronization outside the kernel in Windows?,Atomic integers.,Kernel-level interrupt masking.,Dispatcher objects.,Custom user-defined semaphores only.,Direct hardware register manipulation.,C,"The text states, 'Thread synchronization outside kernel: dispatcher objects.'"
Which of the following is NOT listed as a type of dispatcher object used by threads for synchronization in Windows?,Mutex locks,Semaphores,Events,Timers,Atomic variables,E,"The text lists mutex locks, semaphores, events, and timers as dispatcher objects. Atomic variables are mentioned as a Linux-specific synchronization mechanism."
What is the primary purpose of mutex locks in Windows thread synchronization?,To notify waiting threads when a specific time expires.,To function as a counter for shared resources.,To protect shared data; a thread gains ownership to access it and releases it when finished.,To act as a general-purpose condition variable for any event.,To mask interrupts during critical sections.,C,"The text defines mutex locks as protecting shared data, where a 'thread gains ownership to access, releases when finished.'"
"In Windows, what are 'Events' similar to, and what is their function?",Similar to spinlocks; they protect short code segments.,Similar to condition variables; they notify a waiting thread when a condition occurs.,Similar to atomic integers; they perform mathematical operations atomically.,Similar to mutex locks; they grant exclusive access to shared data.,Similar to timers; they trigger after a specified time interval.,B,"The text states, 'Events: similar to condition variables; notify waiting thread when condition occurs.'"
What is the role of 'Timers' as a dispatcher object in Windows?,They control the preemption of threads in the kernel.,They ensure that only one thread can access a resource at a time.,They notify one (or more) threads when a specified time expires.,They count the number of available resources.,They function as a user-mode mutex without kernel intervention.,C,The text explains that timers 'notify one (or more) threads when specified time expires.'
"When a dispatcher object in Windows is in a 'signaled state', what does it indicate?","The object is not available, and a thread attempting to acquire it will block.","The object is available, and a thread acquiring it will not block.",The object has encountered an error and is unusable.,The object is waiting for an external interrupt.,The object is currently owned by a thread and cannot be acquired.,B,A 'signaled state' indicates 'that the object is available and a thread acquiring it will not block.'
Which statement accurately describes a 'nonsignaled state' for a Windows dispatcher object?,The object is ready for immediate acquisition by multiple threads.,"The object is available, and a thread acquiring it will not block.","The object is not available, and a thread attempting to acquire it will block.",The object has been permanently disabled.,The object is only accessible by kernel threads.,C,A 'nonsignaled state' indicates 'that the object is not available and a thread attempting to acquire it will block.'
What state transition occurs when a mutex lock is acquired by a thread in Windows?,It transitions from a nonsignaled state to a signaled state.,It transitions from a signaled state to a nonsignaled state.,It remains in the signaled state.,It enters a waiting state.,It becomes permanently unavailable.,B,"A mutex lock is 'acquired by a thread when it is in the signaled state, and it transitions to the nonsignaled state.'"
"When a thread releases a mutex lock in Windows, what state transition does the mutex undergo?",It transitions from a signaled state to a nonsignaled state.,It remains in the nonsignaled state.,It transitions back to the signaled state.,It enters a blocked state.,It is destroyed and recreated.,C,"When the thread releases the lock, 'it returns to the signaled state.'"
What happens to a thread in Windows when it attempts to acquire a nonsignaled dispatcher object?,"It immediately proceeds without blocking, as the object is available.","Its state changes from waiting to ready, and it is placed in the ready queue.","Its state changes from ready to waiting, and it is placed in a waiting queue.","The kernel automatically allocates a new, available object for it.",It signals all other waiting threads to also block.,C,"When a thread blocks on a nonsignaled object, its 'state changes from ready to waiting, placed in waiting queue.'"
"When a dispatcher object in Windows moves to a signaled state, what action does the kernel typically take regarding waiting threads?",It immediately blocks all threads currently in the ready queue.,It destroys the object and notifies the system of an error.,It checks for waiting threads and moves one or more of them from the waiting to the ready state.,It increments the object's internal counter without affecting threads.,It converts the object into a critical-section object.,C,When an 'Object moves to signaled state: kernel checks waiting threads. Kernel moves one (or more) threads from waiting to ready state.'
"How many waiting threads does the Windows kernel typically move to the ready state when a mutex becomes signaled, versus when an event becomes signaled?",Mutex: all waiting threads; Event: only one thread.,Mutex: one thread; Event: one thread.,Mutex: one thread; Event: all waiting threads.,Mutex: all waiting threads; Event: all waiting threads.,Mutex: zero threads; Event: all waiting threads.,C,"For a mutex, 'only one thread' is selected, while for an event, 'all waiting threads' are selected."
What is a 'critical-section object' in Windows OS?,A kernel-mode semaphore always requiring kernel intervention.,A user-mode mutex that is often acquired and released without kernel intervention.,A specialized timer used for real-time applications.,A system-wide event that signals all waiting processes.,A type of spinlock used exclusively in single-processor systems.,B,"The glossary defines a 'critical-section object' as a 'User-mode mutex object in Windows OS, often acquired/released without kernel intervention.'"
"On a multiprocessor Windows system, what is the initial behavior of a thread attempting to acquire a critical-section object that is currently held?",It immediately allocates a kernel mutex and yields the CPU.,It blocks indefinitely until the object becomes available.,It first uses a spinlock while waiting.,It signals the operating system to force release of the lock.,It transitions directly to a ready state.,C,"For multiprocessor systems, a critical-section object 'first uses spinlock while waiting.'"
What happens if a thread attempting to acquire a Windows critical-section object spins for too long on a multiprocessor system?,It is immediately terminated by the kernel.,"It continues spinning indefinitely, causing a deadlock.",The acquiring thread allocates a kernel mutex and yields the CPU.,The critical-section object automatically converts to a signaled state.,All other waiting threads are moved to the ready queue.,C,If a critical-section object 'spins too long: acquiring thread allocates kernel mutex and yields CPU.'
How has the Linux kernel's preemption model evolved since Version 2.6?,It changed from fully preemptive to nonpreemptive.,It has remained nonpreemptive to ensure stability.,It changed from nonpreemptive (prior to 2.6) to fully preemptive (now).,It removed all forms of kernel preemption.,"It adopted a hybrid model, selectively preemptive based on user configuration.",C,"The text states, 'Prior to Version 2.6: nonpreemptive kernel... Now: Linux kernel is fully preemptive (task can be preempted while running in kernel).'"
What is described as the simplest synchronization technique in the Linux kernel?,Mutex locks.,Semaphores.,Spinlocks.,Atomic integers.,Critical-section objects.,D,"The text states, 'Atomic integers: Simplest synchronization technique.'"
Which of the following is true regarding atomic integers in the Linux kernel?,They are complex data structures used for protecting multiple variables in race conditions.,All mathematical operations on an `atomic_t` type are performed without interruption.,They incur significant locking overhead due to their robust nature.,They are primarily used for managing thread waiting queues.,"The `atomic_t` data type is transparent, allowing direct integer manipulation.",B,The text states: 'All math operations are atomic (performed without interruption)' for `atomic_t`.
"Consider the following Linux atomic operations: `atomic_set(&counter, 5);`, `atomic_add(10, &counter);`, `atomic_sub(4, &counter);`, `atomic_inc(&counter);`. If `value = atomic_read(&counter);` is called after these operations, what would be the value of `value`?",12,11,10,5,4,A,"Starting with `atomic_set(&counter, 5);` sets counter to 5. Then `atomic_add(10, &counter);` makes it 15. `atomic_sub(4, &counter);` makes it 11. `atomic_inc(&counter);` increments it to 12. So, `value` would be 12."
What is the primary use of mutex locks within the Linux kernel?,To handle interrupt masking for I/O operations.,To implement general-purpose condition variables.,"To protect critical sections within the kernel, where a task sleeps if the lock is unavailable.",To perform atomic arithmetic operations on single integer variables.,To disable kernel preemption for very short durations.,C,"Linux mutex locks 'Protect critical sections within kernel.' and 'If unavailable: task calling mutex_lock() sleeps, awakened when owner invokes mutex_unlock().'"
How do Linux spinlocks behave differently on single-processor machines (like embedded systems) compared to SMP machines?,"On single-processor machines, spinlocks are replaced by mutex locks.","On SMP machines, spinlocks are inappropriate and replaced by semaphores.","On single-processor machines, spinlocks are replaced by enabling/disabling kernel preemption.",Spinlocks are not available in single-processor Linux kernels.,Spinlocks are only used for user-mode synchronization on single-processor systems.,C,"For single-processor machines, 'spinlocks inappropriate. Replaced by enabling/disabling kernel preemption.'"
Which characteristic is shared by both spinlocks and mutex locks in the Linux kernel?,They are recursive locks.,They are designed for long-duration critical sections.,They are nonrecursive locks.,They always cause the acquiring task to sleep if unavailable.,They only operate on atomic integer variables.,C,The text explicitly states: 'Both spinlocks and mutex locks in Linux kernel are nonrecursive.'
What happens if a thread in the Linux kernel attempts to acquire a nonrecursive lock (like a spinlock or mutex) that it already holds?,"The lock is successfully reacquired, as they are recursive by default.","The thread enters an infinite loop, causing a system crash.","The lock is released automatically, then reacquired.",The second attempt to acquire the lock will block the thread.,The kernel silently ignores the second acquisition attempt.,D,"For nonrecursive locks, 'If thread acquires lock, cannot acquire same lock again without releasing it first. Second attempt to acquire will block.'"
"Which system calls are used in Linux to disable and enable kernel preemption, respectively?",`disable_preemption()` and `enable_preemption()`,`lock_kernel()` and `unlock_kernel()`,`preempt_off()` and `preempt_on()`,`preempt_disable()` and `preempt_enable()`,`interrupt_mask()` and `interrupt_unmask()`,D,The Linux approach for preemption control uses '`preempt_disable()` and `preempt_enable()` system calls.'
"In the Linux kernel, what is the purpose of the `preempt_count` counter within a task's `thread-info` structure?",It tracks the total number of times the task has been preempted.,It indicates the number of locks currently held by the task.,It measures the time a task has spent in kernel mode.,It stores the task's priority level for scheduling.,It counts the number of times `preempt_enable()` has been called.,B,`preempt_count`: indicates number of locks held by task.'
How does the `preempt_count` in the Linux kernel change when a task acquires and then releases a lock?,It is decremented upon acquisition and incremented upon release.,It remains unchanged during lock operations.,It is incremented upon acquisition and decremented upon release.,It is reset to zero after each lock operation.,It fluctuates randomly based on system load.,C,When a 'Lock acquired: `preempt_count` incremented. Lock released: `preempt_count` decremented.'
Under what condition is it NOT safe for the Linux kernel to be preempted?,If the `preempt_count` is 0.,If the task is running in user mode.,If the `preempt_count` is greater than 0.,If no `preempt_disable()` calls have ever been made.,If the task is waiting in an I/O queue.,C,If `preempt_count` > 0: not safe to preempt kernel (task holds lock).'
For what duration of lock holding are spinlocks (and kernel preemption disable/enable) typically recommended in the Linux kernel?,"When the lock must be held for a very long period, spanning multiple system calls.",When the lock needs to be acquired recursively by the same thread.,Only when the lock is held for a short duration.,"For any duration, as they are the most versatile synchronization mechanism.",Exclusively for user-mode synchronization.,C,Spinlocks (and kernel preemption disable/enable): only when lock held for short duration.'
When should semaphores or mutex locks be preferred over spinlocks in the Linux kernel?,When the lock needs to be held for a short duration.,When the lock must be held for a longer period.,When atomic operations on single integers are required.,When interrupt masking is the primary concern.,When synchronization is required across different processors in an SMP system for short code segments.,B,Semaphores or mutex locks: when lock must be held for longer period.'
"According to the glossary, what are 'dispatcher objects' in Windows OS?",Hardware-level components that manage CPU scheduling.,"Windows scheduler features controlling dispatching and synchronization, allowing threads to synchronize via mutex locks, semaphores, events, and timers.",User-mode structures that directly manipulate the kernel's process table.,"Objects used exclusively for inter-process communication, not thread synchronization.",A type of nonrecursive lock used to protect critical sections in kernel mode.,B,"The glossary defines 'dispatcher objects' as 'Windows scheduler feature controlling dispatching and synchronization. Threads synchronize via mutex locks, semaphores, events, and timers.'"
"What is the definition of an 'event' in the context of Windows OS scheduling features, as provided in the glossary?",A mechanism for protecting shared data with exclusive access.,A timer that notifies threads when a specified time expires.,A scheduling feature similar to a condition variable.,A system call that disables kernel preemption.,An atomic data type for integer operations.,C,"The glossary defines 'event' as 'Windows OS scheduling feature, similar to a condition variable.'"
What is a 'critical-section object' as defined in the Windows OS context?,A kernel-mode object that always requires kernel intervention for acquisition/release.,A hardware interrupt handler for critical system events.,"A user-mode mutex object, often acquired/released without kernel intervention.",A Linux-specific synchronization primitive for multi-core systems.,A type of semaphore used for resource counting.,C,"The glossary defines 'critical-section object' as 'User-mode mutex object in Windows OS, often acquired/released without kernel intervention.'"
