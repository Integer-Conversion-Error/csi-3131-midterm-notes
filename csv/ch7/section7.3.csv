Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
For which level of programmers is the POSIX API primarily available?,Kernel-level developers,Device driver programmers,User-level programmers,System administrators,Network protocol engineers,C,The text states that the 'POSIX API: available for user-level programmers'.
Which statement accurately describes the relationship of the POSIX API with the OS kernel?,It is an integral part of specific OS kernels.,It is a stand-alone operating system.,It is not part of a specific OS kernel but is implemented using host OS tools.,"It is a hardware abstraction layer, not related to the OS.",It replaces the need for any OS kernel.,C,The text clarifies that the POSIX API is 'not part of specific OS kernel' but is 'Implemented using host OS tools'.
Which synchronization methods are covered in the provided text's section on POSIX synchronization?,"Message queues, shared memory, and pipes","Mutex locks, semaphores, and condition variables","Spinlocks, reader-writer locks, and barriers","Atomic operations, signals, and events","Timers, interrupts, and system calls",B,"The text explicitly states: 'This section covers: mutex locks, semaphores, condition variables in Pthreads and POSIX APIs.'"
What is the primary purpose of POSIX mutex locks in Pthreads?,To manage inter-process communication.,To facilitate thread creation.,To protect critical sections of code.,To handle asynchronous events.,To allocate dynamic memory safely.,C,The purpose of POSIX mutex locks is to 'protect critical sections of code'.
What is the data type used for a POSIX mutex lock?,lock_t,mutex_type,pthread_lock_t,pthread_mutex_t,thread_mutex_t,D,The text specifies the data type as 'pthread_mutex_t'.
Which function is used to create and initialize a POSIX mutex lock?,pthread_mutex_create(),pthread_init_mutex(),pthread_mutex_init(),mutex_open(),new_pthread_mutex(),C,The text identifies 'pthread_mutex_init()' as the creation function for mutex locks.
"When invoking pthread_mutex_init(), what value is typically passed as the second parameter for default attributes?",0,TRUE,DEFAULT_ATTRIBUTES,NULL,PTHREAD_MUTEX_DEFAULT,D,The text states that the 'Second parameter: NULL for default attributes'.
What happens if pthread_mutex_lock() is invoked and the mutex is currently unavailable?,The function returns an error immediately.,The calling thread continues execution without acquiring the lock.,The calling thread blocks until the owner invokes pthread_mutex_unlock().,The mutex is automatically released by the system.,A new mutex is created for the calling thread.,C,The text explains: 'If pthread_mutex_lock() invoked and mutex unavailable: calling thread blocks until owner invokes pthread_mutex_unlock()'.
"Which functions are used for acquiring and releasing a POSIX mutex lock, respectively?",lock() and unlock(),acquire_mutex() and release_mutex(),pthread_mutex_lock() and pthread_mutex_unlock(),get_lock() and put_lock(),sem_wait() and sem_post(),C,The functions for acquisition and release are specified as 'pthread_mutex_lock()' and 'pthread_mutex_unlock()'.
"What does a return value of 0 from POSIX mutex lock operations (like init, lock, unlock) signify?",An error occurred.,The operation is still pending.,The operation completed successfully.,The mutex is currently locked.,The mutex is currently unlocked.,C,"The text indicates: 'Return values: 0 for correct operation, nonzero for error'."
"POSIX semaphores, though often provided with Pthreads systems, officially belong to which standard or extension?",The core POSIX standard.,The C++ Standard Library.,The POSIX SEM extension.,The UNIX System V standard.,The Linux Kernel API.,C,The text states: 'Not part of POSIX standard; belong to POSIX SEM extension'.
What are the two types of POSIX semaphores discussed in the text?,Binary and Counting,Global and Local,Named and Unnamed,Read and Write,Shared and Private,C,The text identifies 'Two types: named and unnamed'.
What is the primary difference between named and unnamed POSIX semaphores?,Their data types.,The functions used for their operations.,Their initial values.,How they are created and shared between processes.,The operating systems that support them.,D,The text states: 'Differences: how they are created and shared between processes'.
Which function is used for creating and opening POSIX named semaphores?,sem_create(),sem_init(),sem_open(),pthread_sem_init(),create_named_semaphore(),C,The text specifies 'sem_open()' for 'Creation and opening' of named semaphores.
"In the `sem_open()` function call `sem_open(""SEM"", O_CREAT, 0666, 1)`, what does the `O_CREAT` flag signify?",Open an existing semaphore only.,Create a new semaphore regardless.,Create the semaphore if it does not exist.,Open the semaphore for read-only access.,Open the semaphore exclusively.,C,The text states: 'O_CREAT flag: semaphore created if it doesn't exist'.
What access permissions does the `0666` parameter in `sem_open()` typically grant for a named semaphore?,Execute-only access for the owner.,Read-only access for all users.,Read and write access only for the creating process.,Read and write access for other processes.,No access for other processes.,D,The text explains: '0666: read and write access for other processes'.
What is a significant advantage of using POSIX named semaphores?,They are faster than unnamed semaphores.,They can only be used by threads within the same process.,They are automatically destroyed upon process termination.,Multiple unrelated processes can easily use a common semaphore by name.,They consume less system memory compared to unnamed semaphores.,D,The text highlights the 'Advantage: multiple unrelated processes can easily use common semaphore by name'.
"Which functions correspond to the standard 'wait()' and 'signal()' operations for POSIX named semaphores, respectively?",sem_get() and sem_put(),sem_lock() and sem_unlock(),sem_wait() and sem_post(),acquire_sem() and release_sem(),P() and V(),C,The text maps 'wait() -> sem_wait()' and 'signal() -> sem_post()'.
"According to the section glossary, what defines a POSIX named semaphore?",A scheduling construct usable only by threads in the same process.,A kernel-level construct for inter-thread communication.,A POSIX scheduling construct that exists in the file system and is shareable by unrelated processes.,A data structure for managing shared memory between processes.,A hardware-level synchronization primitive.,C,"The glossary defines 'named semaphore' as a 'POSIX scheduling construct, exists in file system, shareable by unrelated processes'."
Which function is used for creating and initializing POSIX unnamed semaphores?,sem_open(),sem_create_unnamed(),sem_init(),pthread_sem_init(),unnamed_sem_create(),C,The text indicates 'Creation and initialization: sem_init() function' for unnamed semaphores.
"In the `sem_init(&sem, 0, 1)` function call for an unnamed semaphore, what does the second parameter `0` (flag) indicate?",The semaphore is shared across the entire system.,The semaphore is shared only by threads within the creating process.,The semaphore's initial value is zero.,The semaphore is named.,The operation failed to set sharing.,B,The text states: 'Flag 0: semaphore shared only by threads in creating process'.
How can POSIX unnamed semaphores be shared between separate processes?,By passing their name to `sem_open()`.,By creating them with a sharing flag of 0.,By placing them in shared memory and using a nonzero sharing flag.,They cannot be shared between separate processes.,By using a system-wide identifier.,C,The text specifies: 'Nonzero flag: allows sharing between separate processes (by placing in shared memory)'.
Which functions are used for the operations on POSIX unnamed semaphores?,sem_down() and sem_up(),pthread_wait() and pthread_signal(),sem_wait() and sem_post(),acquire_unnamed_sem() and release_unnamed_sem(),Different functions than named semaphores are used.,C,The text clarifies that unnamed semaphores 'uses same sem_wait() and sem_post() as named semaphores'.
"According to the section glossary, what describes a POSIX unnamed semaphore?",A POSIX scheduling construct that exists in the file system.,A semaphore that can be shared by unrelated processes by name.,A POSIX scheduling construct usable only by threads in the same process.,A system-wide resource that requires a mutex lock.,A semaphore that has no initial value.,C,"The glossary defines 'unnamed semaphore' as a 'POSIX scheduling construct, usable only by threads in the same process'."
"What mechanism is used with Pthreads condition variables for locking, considering that the C language does not provide monitors?",Spinlocks are used for locking.,Atomic operations ensure locking.,They automatically acquire a global lock.,The condition variable is associated with a mutex lock.,They rely on hardware-level interrupts for synchronization.,D,The text states: 'Locking accomplished by associating condition variable with a mutex lock'.
What is the data type for a POSIX condition variable?,cond_var_t,pthread_condition_t,condition_t,pthread_cond_t,cond_type,D,The text specifies the data type as 'pthread_cond_t'.
Which function is used to initialize a POSIX condition variable?,pthread_cond_create(),pthread_init_cond(),pthread_cond_init(),cond_var_open(),new_pthread_cond(),C,The text identifies 'pthread_cond_init()' as the initialization function for condition variables.
"When calling pthread_cond_wait(), what must be true about the associated mutex lock?",It must be released immediately before the call.,It must be acquired by the calling thread before the call.,It is optional and can be ignored.,It should be acquired by a different thread.,It is automatically acquired by `pthread_cond_wait()`.,B,The text states: 'Mutex lock must be acquired before pthread_cond_wait() call'.
What happens to the mutex lock when pthread_cond_wait() is invoked by a thread?,It remains locked by the calling thread.,It is automatically destroyed.,"pthread_cond_wait() releases the mutex lock, allowing other threads to access/update shared data.",It is acquired by another waiting thread immediately.,It is ignored by the condition variable.,C,"The text specifies: 'pthread_cond_wait() releases mutex lock, allowing other threads to access/update shared data'."
Why is it important to place the conditional clause for pthread_cond_wait() within a loop?,To ensure the thread spins indefinitely.,To prevent the mutex from being released.,To protect against program errors by rechecking the condition after being signaled.,To signal multiple waiting threads simultaneously.,To acquire the mutex lock faster.,C,The text advises: 'Conditional clause within a loop: important to recheck condition after being signaled (protects against program errors)'.
Which function is used to signal a single waiting thread on a POSIX condition variable?,pthread_cond_broadcast(),pthread_cond_signal_all(),pthread_signal_cond(),pthread_cond_signal(),signal_one_cond(),D,The text states: 'Signaling a condition variable: pthread_cond_signal() function' and clarifies it signals 'one waiting thread'.
What is a key behavior of pthread_cond_signal() concerning the associated mutex lock?,It immediately releases the mutex lock.,It acquires the mutex lock for the signaling thread.,It does NOT release the mutex lock.,It destroys the mutex lock upon completion.,"It makes the mutex available to all threads, regardless of ownership.",C,The text explicitly states: 'pthread_cond_signal() does NOT release mutex lock'.
"After a thread is signaled by pthread_cond_signal(), when does it typically become the owner of the mutex and return from pthread_cond_wait()?",Immediately upon being signaled.,Before the signaling thread has finished its critical section.,Once the signaling thread acquires another mutex.,After the mutex is released by the signaling thread via pthread_mutex_unlock().,It never re-acquires the mutex; it is given to another thread.,D,"The text explains: 'Once mutex released, signaled thread becomes owner of mutex and returns from pthread_cond_wait()'."
