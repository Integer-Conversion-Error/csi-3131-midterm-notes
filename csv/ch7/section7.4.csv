Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
Which statement accurately describes Java's support for thread synchronization?,Java introduced thread synchronization features only in Release 1.5.,Java has provided rich support for thread synchronization since its origins.,Java primarily relies on external libraries for thread synchronization.,Java's synchronization mechanisms are limited to basic monitors.,Atomic variables are the original and primary synchronization mechanism in Java.,B,"The text states, 'Java language and API: rich support for thread synchronization since its origins.'"
The provided text covers which of the following Java synchronization mechanisms?,Atomic variables and CAS instruction.,Only Java monitors.,"Reentrant locks, semaphores, and condition variables exclusively.","Java monitors, Reentrant locks, semaphores, and condition variables.",Distributed locks and transactional memory.,D,"The text explicitly lists 'Java monitors (original mechanism)' and 'Reentrant locks, semaphores, condition variables (introduced in Release 1.5)' as covered topics."
"In Java, how many locks are associated with a single object when using Java monitors?","Zero locks, synchronization is managed by a central scheduler.","Multiple locks, one for each synchronized method.",Exactly one lock.,"A dynamic number of locks, depending on contention.",One lock per thread accessing the object.,C,"The text clearly states, 'Every Java object has a single associated lock.'"
What must a thread acquire before it can enter a synchronized method in Java?,A permit from a semaphore.,Ownership of the object's associated lock.,Access to the shared critical section directly.,A unique thread ID from the JVM.,Permission from the operating system's kernel.,B,"The text states, 'synchronized method: entering requires owning the object's lock.'"
How is a method declared as synchronized in Java?,By enclosing its body within a synchronized block.,By implementing the Synchronized interface.,By placing the 'synchronized' keyword in the method definition.,By marking the class as synchronized.,By using an annotation like @Synchronized.,C,"The text specifies, 'Declared by placing synchronized keyword in method definition (e.g., insert(), remove()).'"
"In the context of Java monitors, what is an 'entry set'?",A set of threads that have successfully entered a synchronized method.,A set of threads that are actively executing within a critical section.,A set of threads waiting for an object's lock to become available.,A collection of variables that are protected by the monitor.,A mechanism for threads to register for callbacks when a lock is released.,C,"The glossary defines 'entry set' as 'In Java, the set of threads waiting to enter a monitor.' The main text also states, 'Entry set: set of threads waiting for lock to become available.'"
"When a thread attempts to enter a synchronized method and the object's lock is currently owned by another thread, what is the immediate consequence for the calling thread?",It immediately throws an IllegalMonitorStateException.,It proceeds to execute the method's non-critical sections.,It releases its own lock and tries again later.,It blocks and is placed in the object's entry set.,It bypasses the lock and forces entry.,D,"The text states, 'If lock owned by another thread: calling thread blocks, placed in object's entry set.'"
"When a thread exits a synchronized method and releases the object's lock, what happens if the object's entry set is not empty?",The lock remains unowned until a new thread explicitly requests it.,The thread that just exited re-acquires the lock automatically.,The JVM arbitrarily selects a thread from the entry set to own the lock.,All threads in the entry set are simultaneously granted the lock.,"The entry set is cleared, and all waiting threads are de-scheduled.",C,"The text states, 'If entry set not empty on lock release: JVM arbitrarily selects thread from set to own lock (often FIFO in practice).'"
What is a 'wait set' in Java synchronization?,A set of methods waiting for input from the user.,A set of threads that have completed their execution and are waiting to be terminated.,"A set of threads, each waiting for a specific condition that will allow it to continue.",A queue of tasks waiting to be assigned to worker threads.,A collection of monitor objects waiting for garbage collection.,C,"The glossary defines 'wait set' as 'In Java, a set of threads, each waiting for a condition that will allow it to continue.'"
"When a thread inside a synchronized method calls the wait() method, which of the following actions occur?
1. The thread releases the lock for the object.
2. The thread's state is set to blocked.
3. The thread is placed in the wait set for the object.
4. The thread's priority is increased.",1 and 2 only,"1, 2, and 3 only",2 and 3 only,"1, 3, and 4 only","1, 2, 3, and 4",B,The text explicitly lists these three actions: 'When thread calls wait() method: 1. Releases lock for the object. 2. Thread state set to blocked. 3. Thread placed in wait set for the object.'
"According to the provided text, what is the 'scope' of a lock?",The number of threads that can simultaneously hold the lock.,The geographical area over which the lock is effective.,The time between when a lock is acquired and when it is released.,The specific critical section protected by the lock.,The set of variables that the lock protects.,C,The glossary defines 'scope' as 'The time between when a lock is acquired and when it is released.'
Why is block synchronization generally preferred over synchronized methods when only a small portion of the method manipulates shared data?,Block synchronization is simpler to implement.,Synchronized methods do not provide true mutual exclusion.,"Block synchronization allows for a smaller lock scope, improving concurrency.","Synchronized methods require explicit lock release, unlike blocks.",Block synchronization automatically handles thread interruptions.,C,"The text states, 'synchronized method: large scope if only small part manipulates shared data. Better: synchronize only the block of code manipulating shared data (smaller lock scope).'"
What happens to a thread in the wait set when it is notified?,It immediately re-acquires the lock and resumes execution.,It is terminated and removed from the system.,It is moved to the entry set and becomes eligible to be granted the lock.,It remains in the wait set but changes its state to runnable.,It broadcasts a signal to all other waiting threads.,C,"The text describes, 'when a thread in the wait set is notified, it is moved to the entry set and becomes eligible to be granted the lock.'"
"When the notify() method is invoked, what is its primary effect on threads in the wait set?",It moves all threads from the wait set to the entry set.,It terminates all threads in the wait set.,"It selects an arbitrary thread from the wait set, moves it to the entry set, and sets its state to runnable.",It allows the current thread to acquire a second lock.,It signals all threads in the entry set to proceed.,C,"The text states, 'notify() method: Picks arbitrary thread T from wait set. Moves T from wait set to entry set. Sets state of T from blocked to runnable.'"
"After a thread in the entry set successfully reacquires the lock following a notify() call, what is its next typical action upon resuming from wait()?",It immediately exits the synchronized method.,It throws an InterruptedException.,It rechecks the condition that caused it to wait().,It calls notifyAll() to wake up other threads.,It enters an infinite loop.,C,"The text describes, 'Once T regains lock, returns from wait(), rechecks count.' (Referring to the example with 'while (count == BUFFER_SIZE)' or 'while (count == 0)')."
What happens if the notify() method is called when the object's wait set is empty?,It causes an error.,It has no effect.,It automatically places the calling thread into the wait set.,It signals all threads in the entry set.,It waits indefinitely for a thread to enter the wait set.,B,"The text states, 'notify() ignored if no thread in wait set.'"
Which of the following are identified as the 'original Java mechanisms' for synchronization?,Reentrant locks and Condition variables.,Semaphores and Atomic variables.,"synchronized, wait(), and notify().",ReentrantLock and ReentrantReadWriteLock.,acquire() and release() methods.,C,"The text explicitly states, 'synchronized, wait(), notify() are original Java mechanisms.'"
In what way is a ReentrantLock similar to a synchronized statement?,Both are original Java mechanisms from its origins.,Both require manual release even upon exceptions.,Both are owned by a single thread and provide mutual exclusive access.,Both offer a fairness parameter by default.,Both can be used without an explicit try-finally block.,C,"The text notes, 'Similar to synchronized statement: owned by single thread, provides mutual exclusive access to shared resource.'"
What does the 'reentrant' aspect of a ReentrantLock signify?,The lock can be acquired multiple times by different threads concurrently.,The lock automatically re-acquires itself after being released.,The invoking thread can acquire the lock even if it already owns it.,The lock allows threads to re-enter a critical section without needing to acquire the lock again.,The lock can be used across different JVM instances.,C,"The text states, 'If lock available OR invoking thread already owns it (reentrant): lock() assigns ownership, returns control.'"
Why is the 'try { key.lock(); /* critical section */ } finally { key.unlock(); }' idiom recommended when using ReentrantLock?,To catch checked exceptions thrown by the lock() method.,To prevent the lock from being acquired if the critical section fails.,To ensure the lock is released even if an exception occurs within the critical section.,To allow multiple threads to acquire the lock concurrently in the try block.,To signal other threads that the critical section is available.,C,"The text explicitly states, 'Ensures lock is released (via unlock()) after critical section completes or if exception occurs in try block.' It also mentions lock() doesn't throw checked exceptions."
For what type of concurrency scenario does the ReentrantReadWriteLock provide a specific advantage?,Scenarios where only a single thread needs exclusive access.,Scenarios requiring strict FIFO ordering for all access.,Scenarios with significantly more readers than writers.,Scenarios where distributed locking is necessary.,Scenarios that need automatic lock management.,C,"The text states, 'ReentrantReadWriteLock: Java API also provides this for scenarios with more readers than writers. Allows multiple concurrent readers but only one writer.'"
What is the initial value of a Semaphore set by in its constructor?,A boolean indicating if it's fair or not.,A string representing its name.,An integer representing its initial permit count.,A thread object to associate it with.,The current time in milliseconds.,C,"The text states, 'Constructor: Semaphore(int value). value: initial value of semaphore (negative allowed).'"
Which exception can the acquire() method of a Semaphore throw if the acquiring thread is interrupted?,IllegalMonitorStateException,NullPointerException,InterruptedException,IllegalArgumentException,UnsupportedOperationException,C,"The text mentions, 'acquire() method: throws InterruptedException if acquiring thread interrupted.'"
Why is sem.release() typically placed within a finally clause when using a Semaphore for mutual exclusion?,To ensure the semaphore is released only after successful critical section execution.,To prevent the release() method from throwing an exception.,To guarantee the semaphore is released even if an exception occurs in the critical section.,To allow other threads to acquire the semaphore immediately.,To automatically acquire the semaphore again for the same thread.,C,"The example shows release() in finally and the explanation states, 'release() placed in finally clause to ensure semaphore is released.'"
Condition variables in Java must always be associated with which other synchronization mechanism?,A Thread object.,A Semaphore.,A ReentrantLock.,An AtomicInteger.,A synchronized block.,C,"The text states, 'Must be associated with a reentrant lock for mutual exclusion.'"
What is the correct sequence of steps to create a Condition object in Java's concurrency API?,"Create a Semaphore, then call its newCondition() method.",Create a Condition directly using its constructor.,"Create a ReentrantLock, then invoke its newCondition() method.",Call the wait() method on any object to get a condition.,Declare a synchronized method and the JVM provides one implicitly.,C,The text describes creation as: '1. Create a ReentrantLock. 2. Invoke its newCondition() method.'
The await() and signal() methods of a Condition object provide functionality similar to which other Java methods?,start() and stop(),lock() and unlock(),acquire() and release(),wait() and notify(),get() and set(),D,"The text states, 'Operations: await() and signal() methods. The function of these methods is the same as that of the wait() and signal() methods described in a previous chapter.'"
"Which statement is true regarding the condition variable associated with a basic Java monitor (using synchronized, wait(), notify())?",Each monitor can have multiple named condition variables.,There are no condition variables associated with basic Java monitors.,Each Java monitor is associated with a single unnamed condition variable.,Condition variables for basic monitors must be explicitly created using newCondition().,The condition variable is automatically named after the monitor object.,C,The text explains: 'Java (language level): does not provide named condition variables. Each Java monitor: associated with one unnamed condition variable.'
What is a limitation of the notify() method (used with Java monitors) that Condition variables aim to remedy?,notify() cannot wake up any thread in the wait set.,"notify() always wakes up all waiting threads, even if not needed.",The awakened thread receives no information about why it was notified and must recheck its condition.,"notify() requires the lock to be released immediately, which can cause race conditions.",notify() can only be called from a non-synchronized context.,C,The text points out: 'When Java thread awakened via notify(): receives no info on why; reactivated thread must check condition itself.' And later: 'Condition variables (this section): remedy this by allowing specific thread to be notified.'
"In the doWork(int threadNumber) example demonstrating condition variables, how is mutual exclusion achieved?",The doWork() method is declared as synchronized.,Each thread acquires a unique semaphore before entering.,A ReentrantLock is acquired at the beginning and released at the end.,The await() method inherently provides mutual exclusion.,The signal() method ensures only one thread can proceed.,C,"The example code explicitly shows 'lock.lock()' at the start and 'lock.unlock()' in a 'finally' block. The text also states, 'doWork() does not need to be synchronized. ReentrantLock provides mutual exclusion.'"
"When a thread invokes await() on a Condition variable, which lock is released?",No lock is released; the thread simply pauses.,The monitor lock associated with 'this' object.,The ReentrantLock associated with that specific condition variable.,All locks held by the current thread.,A global system lock.,C,"The text states, 'await() on condition variable releases associated ReentrantLock.'"
"When a thread invokes signal() on a Condition variable, what happens to the lock currently held by the signaling thread?",The lock is immediately released.,The lock is transferred to the signaled thread.,The lock is only released when the signaling thread invokes unlock().,The lock is held indefinitely until another thread calls await().,A new lock is automatically acquired.,C,"The text clarifies, 'signal() only signals condition variable; lock released by unlock().' This means signal() itself doesn't release the lock."
