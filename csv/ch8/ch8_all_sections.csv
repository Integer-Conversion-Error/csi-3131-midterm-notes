"In a multiprogramming environment, what do multiple threads typically compete for?",CPU speed,Network bandwidth,Finite resources,External peripherals,Developer attention,C,The text states that in a 'Multiprogramming Environment: Multiple threads compete for finite resources'.
"When a thread requests a resource that is currently unavailable, what state does it enter?",Terminated state,Running state,Waiting state,Ready state,Suspended state,C,"The text explicitly states under 'Resource Request': 'If unavailable, thread enters a waiting state'."
"Which of the following best describes a deadlock situation, as defined in the introduction?",A thread is indefinitely running a critical section.,A waiting thread can never change state because its requested resources are held by other waiting threads.,Multiple threads simultaneously access a shared resource without synchronization.,A thread requests a resource that does not exist.,A system crash due to excessive resource allocation.,B,The introduction defines deadlock as 'A situation where a waiting thread can never change state because its requested resources are held by other waiting threads'.
"According to the formal definition, a deadlock occurs when every process in a set is waiting for an event that can only be caused by which of the following?",An external interrupt,Another process in the set,The operating system kernel,User input,A timer expiration,B,The formal definition of deadlock is: 'Every process in a set is waiting for an event that can only be caused by another process in the set'.
How is the system described in terms of resources and threads?,An infinite number of resources shared among infinite threads.,A finite number of resources distributed among competing threads.,Resources are unlimited and available on demand.,Resources are exclusively allocated to a single thread.,"Resources are only available to processes, not threads.",B,The 'System model' section states the 'System Composition' is a 'Finite number of resources distributed among competing threads'.
How are resources typically organized or partitioned in the system model?,They are randomly assigned without structure.,"They are partitioned into types (classes), each with identical instances.",They are grouped by their physical location.,They are categorized by their usage frequency.,"They are all considered to be of a single, generic type.",B,"Under 'Resource Types', the text states: 'Resources partitioned into types (classes), each with identical instances'."
What characteristic of resource types ensures flexibility when a thread requests a resource?,Resources must be allocated sequentially.,Resources can only be used by their specific owner thread.,Any instance of a resource type should satisfy a request.,Resource instances are unique and non-interchangeable.,Resources are always pre-allocated to threads.,C,The text specifies that 'Any instance of a resource type should satisfy a request'.
Which of the following is NOT explicitly given as an example of a resource type or class in the text?,CPU cycles,Files,I/O devices,Mutex locks,User input,E,"CPU cycles, files, and I/O devices are given as examples of resource types. Mutex locks are stated to be 'common sources of deadlock' and 'Each lock instance is typically its own resource class'. User input is not mentioned as a resource type."
What are two common synchronization tools explicitly mentioned as sources of deadlock?,Message queues and pipes,Mutex locks and semaphores,Event flags and condition variables,Spinlocks and atomic operations,Monitors and barriers,B,"The text states, 'Mutex locks and semaphores are common sources of deadlock'."
What is the correct sequence of steps for a thread utilizing a resource?,"Use, Request, Release","Release, Request, Use","Request, Use, Release","Request, Release, Use","Use, Release, Request",C,"The 'Resource Utilization Sequence' is listed as 1. Request, 2. Use, 3. Release."
"During the 'Request' step of resource utilization, what happens if the requested resource is not immediately available?",The thread immediately terminates.,The thread proceeds without the resource.,The thread waits.,The operating system grants the resource anyway.,The resource is forcibly taken from another thread.,C,The description for the 'Request' step states: 'Thread requests a resource. Waits if not immediately available'.
Which of the following is explicitly mentioned as a mechanism for threads to request and release resources via system management?,Direct memory manipulation,Command-line interface commands,System calls like request() and release(),Inter-process communication via sockets,Hardware interrupts,C,"The text states: 'Request/release can be system calls (request(), release(), open(), close(), allocate(), free())'."
How does the Operating System (OS) check for resource allocation?,By polling all active threads.,Through a system table.,By directly inspecting hardware registers.,By receiving notifications from applications.,By user configuration files.,B,The text mentions that 'OS checks for resource allocation via a system table'.
What information does the OS system table track regarding resources?,Only the total number of resources.,Only resources currently in use.,Free/allocated resources and the owning thread.,The performance metrics of resource usage.,Historical logs of resource requests.,C,The system table 'tracks free/allocated resources and the owning thread'.
"What are the main events involved when a set of threads enters a deadlocked state, as described in the system model?",Only resource release.,Only CPU scheduling.,Resource acquisition and release.,Network communication.,Disk I/O operations.,C,"The text states that in a 'Deadlocked State', the 'Main events: resource acquisition and release'."
"Which classic problem is given as an example to illustrate a deadlocked state where threads exhibit a circular wait (e.g., holding one resource and waiting for another)?",Producer-consumer problem,Reader-writer problem,Dining-philosophers problem,Bounded-buffer problem,Sleeping barber problem,C,"The Dining-philosophers problem is specifically mentioned as an example of a deadlocked state: 'Each philosopher holds one chopstick and waits for another, creating a circular wait'."
What is a key responsibility of a developer regarding deadlock possibilities?,To ignore them as the OS handles all deadlocks.,To ensure locks are always acquired in an arbitrary order.,To be aware of them and manage lock acquisition/release carefully.,To use as many locks as possible without concern.,To delegate all locking to external libraries.,C,"Under 'Developer Responsibility', it states: 'Must be aware of deadlock possibilities' and 'require careful management of lock acquisition/release to avoid deadlocks'."
"While locking tools are effective in preventing race conditions, what specific management is required from developers to avoid deadlocks?",Minimizing the number of locks used.,Using only reentrant locks.,Careful management of lock acquisition/release.,Relying on hardware-level atomicity.,Disabling preemption.,C,The text advises that locking tools 'require careful management of lock acquisition/release to avoid deadlocks'.
"According to the section glossary, what defines a deadlock?",A situation where a process consumes all available CPU cycles.,The state in which two processes or threads are stuck waiting for an event that can only be caused by one of the processes or threads.,An error where a process attempts to access invalid memory.,A condition where a system runs out of disk space.,An infinite loop within a single thread.,B,The section glossary defines 'deadlock' as 'The state in which two processes or threads are stuck waiting for an event that can only be caused by one of the processes or threads'.
What is the primary function of the `pthread_mutex_init()` function in Pthreads?,Acquires a mutex lock.,Releases a mutex lock.,Initializes an unlocked mutex.,Destroys a mutex.,Blocks if a lock is held.,C,The text states that `pthread_mutex_init()` initializes an unlocked mutex.
What happens when a thread calls `pthread_mutex_lock()` on a mutex that is currently held by another thread?,It immediately acquires the lock.,It returns an error code.,It blocks until the lock is released.,It initializes a new mutex.,It releases the lock it holds.,C,The text states that `pthread_mutex_lock()` acquires a lock and 'blocks if the lock is held'.
What is the purpose of the `pthread_mutex_unlock()` function?,To attempt to acquire a lock without blocking.,To release a mutex lock.,To initialize a mutex.,To check the status of a mutex.,To destroy a mutex.,B,The text explicitly states that `pthread_mutex_unlock()` releases a lock.
"In the Pthreads example demonstrating deadlock, how many mutex locks and threads are involved in the scenario?","One mutex, two threads.","Two mutexes, one thread.","Two mutexes, two threads.","Three mutexes, two threads.","One mutex, one thread.",C,"The deadlock scenario description mentions 'Two mutex locks created: `first_mutex`, `second_mutex`' and 'Two threads, `thread_one` and `thread_two`'."
Which locking order between `thread_one` and `thread_two` is described as leading to a potential deadlock in the provided example?,`thread_one` locks `first_mutex` then `second_mutex`; `thread_two` also locks `first_mutex` then `second_mutex`.,`thread_one` locks `first_mutex` then `second_mutex`; `thread_two` locks `second_mutex` then `first_mutex`.,`thread_one` locks `second_mutex` then `first_mutex`; `thread_two` locks `first_mutex` then `second_mutex`.,Both threads attempt to lock both mutexes simultaneously.,Both threads lock `second_mutex` then `first_mutex`.,B,"The text states: '`thread_one` locks in order: (1) `first_mutex`, (2) `second_mutex`' and '`thread_two` locks in order: (1) `second_mutex`, (2) `first_mutex`'."
What specific condition must occur for a deadlock to be possible in the given Pthreads example?,Both threads acquire both `first_mutex` and `second_mutex` successfully in their specified order.,"`thread_one` acquires `first_mutex` and `thread_two` acquires `second_mutex`, leading both to block waiting for the other's lock.",One thread acquires and releases both locks before the other thread starts execution.,Neither thread is able to acquire any mutex lock.,Both threads acquire `second_mutex` and then `first_mutex`.,B,"The text explains the deadlock is possible 'If `thread_one` acquires `first_mutex` and `thread_two` acquires `second_mutex`, both threads will block waiting for the other's lock'."
Why is it often difficult to identify and test for deadlocks in multithreaded applications?,"Deadlocks always cause immediate system crashes, preventing analysis.",Deadlock detection tools are not available for multithreaded environments.,The occurrence of deadlock is intermittent and depends on the CPU scheduler.,"Deadlocks only manifest on specific hardware architectures, not in testing environments.","Deadlocks only occur when applications are under extremely high load, making replication hard.",C,The text states: 'Deadlock might not occur if one thread acquires and releases both locks before the other thread starts.' and 'Occurrence depends on the CPU scheduler.' which 'Makes identifying and testing for deadlocks difficult'.
Which characteristic distinguishes livelock from deadlock?,"In livelock, threads are permanently blocked and cannot execute.",Livelock applies only to single-threaded applications.,"In livelock, threads are actively attempting operations but fail to make progress.",Livelock results in resources being continuously acquired and released productively.,"Livelock is a type of resource starvation, not a liveness failure.",C,"The text states livelock is 'Similar to deadlock, but threads are not blocked' and illustrates with the analogy of two people 'They are active but make no progress'."
"According to the provided text, what is the core condition that defines livelock?",A thread becomes permanently blocked while waiting for a resource.,A thread continuously attempts an action that fails.,A thread repeatedly acquires and releases a lock successfully.,A thread is unable to acquire any resource due to other threads holding them indefinitely.,A thread enters an infinite loop performing meaningful work.,B,The text defines livelock as a 'Condition: A thread continuously attempts an action that fails' and the glossary also states this.
What is the behavior of `pthread_mutex_trylock()` when it attempts to acquire a lock that is already held by another thread?,It blocks the calling thread until the lock becomes available.,It forces the lock to be released by the current holder.,"It attempts to acquire the lock and returns immediately, indicating success or failure, without blocking.",It initializes a new mutex if the requested one is unavailable.,It causes a deadlock if the lock is held.,C,"The text states `pthread_mutex_trylock()` 'attempts to acquire a lock without blocking'. If it cannot acquire, it will indicate failure, allowing the thread to proceed without waiting."
"In the Pthreads livelock scenario involving `pthread_mutex_trylock()`, what sequence of events leads to livelock?",Both threads successfully acquire their first mutex and then block indefinitely on the second mutex.,"`thread_one` acquires `first_mutex`, `thread_two` acquires `second_mutex`; both fail to acquire the other's mutex using `trylock`, release their own, and repeat indefinitely.","One thread acquires both locks and completes its work, allowing the other thread to proceed.","Both threads attempt to acquire all locks simultaneously, causing a system error.","Threads acquire locks in a random order, eventually resolving the contention.",B,"The text describes the livelock scenario: '`thread_one` acquires `first_mutex`, `thread_two` acquires `second_mutex`. Both then call `trylock` on the other mutex, which fails. They release their locks and repeat indefinitely.'"
What is a common strategy mentioned to avoid livelock?,Ensuring all threads acquire locks in a predefined global order.,Having threads retry failing operations at random times.,Using blocking lock acquisition mechanisms exclusively.,Minimizing the number of shared resources between threads.,Implementing a watchdog timer to terminate non-progressing threads.,B,The text states that livelock 'Can be avoided by having threads retry at random times'.
"The Ethernet example, where hosts involved in a network collision 'backoff' for a random period before retransmitting, is used to illustrate a method for avoiding which concurrency issue?",Deadlock.,Race condition.,Starvation.,Livelock.,Data inconsistency.,D,"This example is provided directly under the 'Avoidance' section for Livelock, showing how random backoff helps prevent threads from repeatedly failing at the same time."
"Compared to deadlock, what is stated about the commonness of livelock in concurrent application design?",It is far more common than deadlock.,It is equally common as deadlock.,It is less common than deadlock.,It is a theoretical concept that does not occur in real-world applications.,Its commonness depends entirely on the operating system used.,C,"The text explicitly states that livelock is 'Less common than deadlock, but still a challenge'."
"According to the Section Glossary, what is the definition of livelock?","A condition in which two or more threads are permanently blocked, waiting for each other.",A condition in which a thread continuously attempts an action that fails.,"A situation where a thread holds a resource indefinitely, preventing others from acquiring it.","A state where multiple threads try to access a shared resource simultaneously, leading to incorrect data.","A scenario where a thread is repeatedly preempted by the scheduler, preventing it from making progress.",B,The glossary defines 'livelock' as 'A condition in which a thread continuously attempts an action that fails'.
What is a fundamental requirement for a deadlock situation to arise in a system?,At least two conditions must hold simultaneously.,Only the circular-wait condition is strictly necessary.,"All four specified conditions (Mutual exclusion, Hold and wait, No preemption, and Circular wait) must hold concurrently.",Deadlocks can arise even if only one condition is met.,Deadlocks are only possible if resources are sharable.,C,"The text states, ""A deadlock situation can arise if the following four conditions hold simultaneously in a system."""
Which of the following conditions for deadlock states that at least one resource must be held in a nonsharable mode?,Hold and wait,No preemption,Circular wait,Mutual exclusion,Resource allocation,D,"Mutual exclusion is defined as ""At least one resource must be held in a nonsharable mode."""
"In the context of deadlock conditions, what does ""Hold and wait"" mean?",A thread is waiting for resources but holds none.,A thread has released all its resources and is waiting for new ones.,A thread must be holding at least one resource and waiting to acquire additional resources held by other threads.,A thread is preempting resources from another thread.,A thread is only holding resources and not waiting for any.,C,"""Hold and wait"" means ""A thread must be holding at least one resource and waiting to acquire additional resources held by other threads."""
"According to the necessary conditions for deadlock, what does ""No preemption"" imply about resource release?",A resource can be forcibly taken away from a thread by the operating system.,Resources are always preemptible if a higher-priority thread requests them.,A resource can be released only voluntarily by the thread holding it.,Resources are automatically released after a fixed time.,A thread can preempt resources from another thread if it waits long enough.,C,"""No preemption"" means ""A resource can be released only voluntarily by the thread holding it."""
"Describe the ""Circular wait"" condition for deadlock.",All threads are waiting for the same resource.,"A set of waiting threads {T_0, T_1, ..., T_n} must exist such that T_0 is waiting for a resource held by T_1, T_1 is waiting for a resource held by T_2, ..., T_{n-1} is waiting for a resource held by T_n, and T_n is waiting for a resource held by T_0.",Threads are waiting in a linear sequence for resources.,A thread is waiting for a resource it previously held.,Threads are waiting for resources that are not currently available anywhere in the system.,B,The definition of circular wait explicitly states this chain of waiting threads.
Which of the following conditions is implied by the circular-wait condition?,Mutual exclusion,No preemption,Hold and wait,Resource starvation,Deadlock avoidance,C,"The text states, ""The circular-wait condition implies the hold-and-wait condition."""
What is the primary purpose of a system resource-allocation graph?,To visualize thread execution order.,To describe deadlocks precisely.,To manage memory allocation.,To represent network topology.,To monitor CPU utilization.,B,"The text and glossary define it as ""A directed graph for precise description of deadlocks."""
What are the two types of vertices that partition the set V in a system resource-allocation graph?,Edges and Nodes,Processes and Resources,Active threads and Resource types,Input and Output,Mutexes and Semaphores,C,Vertices V are partitioned into two types: T (active threads) and R (resource types).
"In a system resource-allocation graph, what does a directed edge from thread T_i to resource type R_j (T_i \rightarrow R_j) represent?",Resource R_j is allocated to thread T_i.,Thread T_i has released resource R_j.,Thread T_i has requested an instance of R_j.,Resource R_j is available for T_i.,Thread T_i is preempting resource R_j.,C,"An edge T_i \rightarrow R_j is a request edge, signifying that T_i has requested an instance of R_j."
What does a directed edge from resource type R_j to thread T_i (R_j \rightarrow T_i) signify in a system resource-allocation graph?,Thread T_i is requesting resource R_j.,An instance of R_j has been allocated to T_i.,Resource R_j is about to be released by T_i.,Thread T_i is waiting for R_j.,Resource R_j is being shared by T_i and other threads.,B,"An edge R_j \rightarrow T_i is an assignment edge, signifying that an instance of R_j has been allocated to T_i."
What can be definitively concluded if a system resource-allocation graph contains no cycles?,A deadlock may still exist.,All threads are actively running.,No thread is deadlocked.,All resources are fully utilized.,"The system is in a safe state, but deadlocks are still possible.",C,"The text states, ""If the graph contains no cycles, no thread is deadlocked."""
"If a system resource-allocation graph contains a cycle and each resource type has exactly one instance, what is the implication?","A deadlock is possible, but not certain.",No deadlock can occur.,A deadlock has occurred.,The system is in a safe state.,All resources are sharable.,C,"The text specifies, ""If each resource type has exactly one instance, a cycle implies a deadlock has occurred."""
"When a system resource-allocation graph contains a cycle, but each resource type has several instances, what does the cycle indicate?",A deadlock is guaranteed.,The system is deadlock-free.,A cycle is a necessary but not a sufficient condition for deadlock.,The system will recover from the deadlock automatically.,All resources are currently available.,C,"The text specifies, ""If each resource type has several instances, a cycle is a necessary but not a sufficient condition for deadlock."""
What are the three fundamental approaches to handling deadlocks mentioned in the text?,"Prevention, Detection, and Recovery.","Ignore, Prevent/Avoid, and Detect/Recover.","Avoidance, Resolution, and Preemption.","Monitoring, Logging, and Restarting.","Scheduling, Prioritizing, and Terminating.",B,"The text lists 'Ignore problem', 'Prevent/Avoid', and 'Detect/Recover' as the three ways to deal with deadlocks."
Which deadlock handling method is most commonly adopted by operating systems like Linux and Windows?,Deadlock Prevention.,Deadlock Avoidance.,Deadlock Detection and Recovery.,Ignoring the problem.,A combination of Prevention and Avoidance.,D,"The text states that 'Ignore problem' is common due to the infrequency of deadlocks and the cost of other methods, specifically mentioning Linux and Windows."
Why is ignoring the deadlock problem a common solution in many operating systems?,It is the most efficient method to prevent deadlocks from occurring.,Deadlocks are very frequent but easily resolved by users.,"Deadlocks occur infrequently, and other methods are costly.",It guarantees that the system never enters a deadlocked state.,It allows the system to automatically recover without user intervention.,C,The text explicitly states that 'ignoring' is common due to 'infrequency of deadlocks and cost of other methods'.
Which deadlock handling strategy explicitly allows the system to enter a deadlocked state before taking action?,Deadlock Prevention.,Deadlock Avoidance.,Ignoring the problem.,Deadlock Detection and Recovery.,Resource preemption.,D,"The 'Detect/Recover' method is described as allowing the system to 'enter deadlocked state, then detect and recover'."
Which type of systems are specifically mentioned as typically employing the Deadlock Detection and Recovery method?,General-purpose desktop operating systems.,Real-time embedded systems.,Database systems.,Mobile operating systems.,Web servers.,C,The text provides 'databases' as an example of systems that use 'Detect/Recover'.
"What is the primary goal of Deadlock Prevention, as defined in the text?",To provide advance information to the OS about resource requests.,To allow the system to enter a deadlocked state for later recovery.,To ensure at least one necessary condition for deadlock cannot hold.,To detect deadlocks quickly after they occur.,To manually restart the system upon deadlock detection.,C,The glossary defines 'deadlock prevention' as 'Methods to ensure at least one necessary condition for deadlock cannot hold.'
How does Deadlock Prevention prevent deadlocks from occurring?,By providing the OS with advance information on resource use.,By examining the system state to determine if a deadlock occurred.,By constraining resource request methods.,By allowing resources to be preempted from processes.,By recovering the system after a deadlock has formed.,C,The text states Deadlock Prevention 'Prevents deadlocks by constraining resource request methods'.
"For Deadlock Avoidance, what kind of information is provided to the OS in advance?",Current CPU utilization of all threads.,Memory usage limits for each thread.,The resources a thread will request/use.,The priority levels of various system processes.,Network bandwidth requirements for future operations.,C,Deadlock Avoidance is described as the OS being 'given advance info on resources a thread will request/use'.
"When the OS employs Deadlock Avoidance, which of the following is NOT one of the factors it considers to decide if a resource request can be satisfied or delayed?",Currently available resources.,Resources allocated to each thread.,Future requests/releases of each thread.,The total number of CPU cores in the system.,Information provided in advance by the threads.,D,"The text explicitly lists 'Currently available resources', 'Resources allocated to each thread', and 'Future requests/releases of each thread' as factors considered by the OS. The number of CPU cores is not mentioned."
What is the definition of 'deadlock avoidance' according to the provided glossary?,Methods to ensure at least one necessary condition for deadlock cannot hold.,"Allowing the system to enter a deadlocked state, then detecting and recovering.",OS method where processes inform OS of resource use; system approves/denies requests to avoid deadlock.,A common approach in most OS due to the infrequency of deadlocks.,Algorithms designed to examine system state to determine if deadlock occurred and recover from it.,C,The glossary defines 'deadlock avoidance' as 'OS method where processes inform OS of resource use; system approves/denies requests to avoid deadlock.'
Under what circumstances would a system primarily rely on Deadlock Detection and Recovery?,As a primary proactive measure to prevent all deadlocks.,When deadlocks are exceptionally rare and insignificant.,If no prevention or avoidance methods are currently in place.,To minimize the cost associated with resource allocation.,When the system design mandates immediate resolution of all resource conflicts.,C,"The text states: 'If no prevention/avoidance, deadlock may arise,' implying detection and recovery is used in such cases."
The algorithms provided by a system for Deadlock Detection and Recovery are designed to perform which two main functions?,Constrain resource requests and allocate resources safely.,Receive advance information and approve/deny requests.,Examine system state to determine if deadlock occurred and recover from it.,Ignore deadlocks and then restart the system manually.,Prioritize threads and preempt resources when necessary.,C,The text specifies that the algorithms are for 'Examine system state to determine if deadlock occurred' and 'Recover from deadlock'.
Which of the following is a primary outcome if a deadlock remains undetected in a system?,The system automatically and immediately resolves the resource conflicts.,Improved overall system performance due to efficient resource locking.,Resources are automatically released after a short timeout period.,"System performance deteriorates, resources remain held, leading eventually to a manual restart.",The system enters a safe state where no new deadlocks can form spontaneously.,D,"The text explicitly states that 'Undetected deadlock: system performance deteriorates, resources held, more threads deadlock. Eventually, manual restart needed.'"
"What other type of system failure's manual recovery method might be applied for deadlock recovery, according_to the text?",System crash due to hardware failure.,Memory leak leading to out-of-memory errors.,"Livelock, which is a type of liveness failure.",Data corruption during file operations.,Process starvation due to low priority.,C,"The text mentions: 'Manual recovery for other liveness failures (e.g., livelock) may be used for deadlock recovery.'"
Under what circumstances does deadlock occur?,If any one of the four necessary conditions holds.,Only if the mutual exclusion and no preemption conditions hold.,If all four necessary conditions hold simultaneously.,When a thread requests resources in increasing order of enumeration.,If resources are allocated but remain unused for long periods.,C,The text states: 'Deadlock occurs if all four necessary conditions hold.'
What is the primary goal of deadlock prevention?,To detect deadlocks quickly and recover from them.,To ensure that at least one of the necessary conditions for deadlock cannot hold.,To allow threads to request resources only when they are holding none.,To predefine a safe sequence for resource allocation.,To maximize resource utilization and prevent starvation.,B,The text states: 'Prevent deadlock by ensuring at least one condition cannot hold.' The glossary also defines 'deadlock prevention' as 'A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.'
"Which type of resource, due to its nature, cannot be involved in a deadlock because it does not require mutual exclusion?",Mutex locks,Semaphores,CPU registers,Read-only files,Database transactions,D,"The text states: 'Sharable resources (e.g., read-only files) do not require mutual exclusion, thus cannot be involved in deadlock.'"
Why is denying the mutual-exclusion condition generally not a viable strategy for preventing deadlocks?,It leads to low resource utilization.,It causes threads to wait indefinitely for popular resources.,"Some resources are intrinsically nonsharable, like mutex locks.","It only prevents circular wait, not other conditions.",It requires threads to release all current resources before requesting more.,C,"The text states: 'Cannot generally prevent deadlocks by denying mutual-exclusion, as some resources are intrinsically nonsharable (e.g., mutex locks).'"
What is Protocol 1 for preventing the 'hold and wait' condition?,Threads must release all current resources before requesting more.,Threads must request and allocate all resources before execution begins.,Threads' currently held resources are preempted if a new request must wait.,Threads are required to request resources in an increasing order of enumeration.,The operating system denies requests if they lead to an unsafe state.,B,The text describes Protocol 1 for hold-and-wait prevention as: 'Thread requests/allocates all resources before execution.'
Which of the following describes Protocol 2 for preventing the 'hold and wait' condition?,A thread acquires all necessary resources in a single atomic operation.,A thread may request resources only when it is not holding any other resources.,"If a thread cannot get a requested resource, it releases all held resources and tries again.",Resources are preempted from a waiting thread and allocated to a requesting thread.,Resources are allocated based on a predefined hierarchical ordering.,B,The text describes Protocol 2 for hold-and-wait prevention as: 'Thread requests resources only when holding none. Must release all current resources before requesting more.'
What is a common disadvantage of both protocols designed to prevent the 'hold and wait' condition?,Increased system overhead due to frequent preemption.,High resource utilization as resources are quickly released.,"Low resource utilization, as resources may be allocated but unused for long periods.",Inability to apply to sharable resources.,Complexity in imposing a total ordering of resource types.,C,The text lists 'Low resource utilization: resources allocated but unused for long periods' as a disadvantage of both hold-and-wait protocols.
Another disadvantage common to both 'hold and wait' prevention protocols is:,They require mutual exclusion to be denied.,They are impractical for static resource allocation.,They lead to an increase in deadlocks.,"Starvation is possible, where a thread waits indefinitely for popular resources.",They are only applicable to mutex locks and semaphores.,D,The text lists 'Starvation possible: thread waits indefinitely for popular resources' as a disadvantage of both hold-and-wait protocols.
"In one protocol to prevent 'no preemption', what happens if a thread requests a resource and must wait?",The thread's request is immediately denied to prevent deadlock.,All resources currently held by that thread are preempted (implicitly released).,The thread is put into a queue and waits for all its requested resources to become available without releasing any current ones.,The operating system checks if other threads can release resources to satisfy the request.,The thread is immediately terminated to free up resources.,B,"Protocol 1 for no-preemption states: 'If thread requests resource and must wait, all currently held resources are preempted (implicitly released).'"
Which type of resources are often suitable for implementing deadlock prevention protocols based on 'no preemption'?,Mutex locks and semaphores,"Resources whose state cannot be saved or restored, like printers.","Resources whose state can be saved and restored, such as CPU registers or database transactions.",Sharable resources like read-only files.,Network connections that are continuously in use.,C,"The text states that no-preemption protocols are 'Often applied to resources whose state can be saved/restored (e.g., CPU registers, database transactions).'"
Deadlock prevention protocols based on 'no preemption' generally cannot be applied to which of the following?,CPU registers,Database transactions,Memory pages,Mutex locks and semaphores,Files that support exclusive write access,D,The text states: 'Cannot generally apply to mutex locks and semaphores (where deadlocks commonly occur).'
What is the practical solution mentioned for preventing the 'circular wait' condition?,Ensuring all resources are requested before execution.,Preempting resources from threads that are waiting.,Imposing a total ordering of all resource types.,Denying mutual exclusion for all resources.,Ensuring that no thread holds resources while waiting for another.,C,The text states: 'Practical solution: impose total ordering of all resource types.'
"When preventing 'circular wait' by imposing a total ordering of resource types, what rule must threads follow when requesting resources?",Threads must request resources in decreasing order of enumeration.,"Threads can request resources in any order, but must release them in increasing order.",Threads must request resources in increasing order of enumeration.,Threads must request all resources of the same type in separate requests.,Threads are only allowed to request resources they do not currently hold.,C,The text states: 'Require threads to request resources in increasing order of enumeration.'
"According to the total ordering protocol for circular wait prevention, what should a thread do if it needs multiple instances of the same resource type?",It must issue separate requests for each instance.,It must issue a single request for all instances needed.,It should only request one instance at a time to avoid complex ordering.,It must release all other resources before requesting multiple instances.,This scenario is not covered by the total ordering protocol.,B,"The text specifies: 'If multiple instances of same resource type needed, single request for all must be issued.'"
What is a known challenge in implementing the total ordering protocol for deadlock prevention?,The protocol does not guarantee deadlock prevention.,It often leads to high resource utilization.,It is difficult to apply to sharable resources.,Developing a consistent and effective ordering can be difficult for many locks.,"It requires threads to release all resources before requesting more, which is inefficient.",D,The text notes: 'Developing ordering can be difficult for many locks.'
Which Java mechanism is mentioned as being used for lock acquisition ordering in the context of preventing circular wait?,synchronized keyword,java.util.concurrent.locks.ReentrantLock,System.identityHashCode(Object),Object.wait() and Object.notify(),java.util.concurrent.Semaphore,C,The text states: 'Java uses `System.identityHashCode(Object)` for lock acquisition ordering.'
What is the definition of 'deadlock prevention' as provided in the glossary?,An operating system method where processes inform the OS of resources they will use during their lifetimes.,A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.,A technique to detect deadlocks as they occur and recover gracefully.,A strategy to minimize resource allocation overhead.,A method to prioritize resource requests to avoid starvation.,B,The glossary defines 'deadlock prevention' as 'A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.'
What is the definition of 'deadlock avoidance' as provided in the glossary?,A method to strictly enforce a total ordering of all resource types.,A technique where threads allocate all resources before execution begins.,An operating system method in which processes inform the operating system of which resources they will use during their lifetimes so the system can approve or deny requests to avoid deadlock.,A protocol that preempts resources from waiting threads to satisfy new requests.,A strategy to ensure that mutual exclusion never holds for any resource.,C,The glossary defines 'deadlock avoidance' as 'An operating system method in which processes inform the operating system of which resources they will use during their lifetimes so the system can approve or deny requests to avoid deadlock.'
"Which of the following is an alternative rule for preventing circular wait using total ordering, as mentioned in the text?",A thread requesting resource R_j must also request all R_i with F(R_i) < F(R_j).,A thread requesting R_j must have released any R_i such that F(R_i) >= F(R_j).,A thread requesting R_j must acquire R_j before any R_i where F(R_i) > F(R_j).,A thread requesting R_j must ensure F(R_j) is the highest function value among its held resources.,A thread must only request R_j if no other thread is holding any R_i.,B,"The text states: 'Alternatively, thread requesting R_j must have released any R_i such that F(R_i) >= F(R_j).'"
When does lock ordering NOT guarantee deadlock prevention?,When resources are requested in decreasing order of enumeration.,When multiple instances of the same resource type are needed.,"If locks are acquired dynamically (e.g., in a transaction function).",If the `System.identityHashCode(Object)` method is used for ordering.,When resource utilization is low.,C,"The text states: 'Lock ordering does not guarantee deadlock prevention if locks acquired dynamically (e.g., `transaction()` function example).'"
Which of the following is a side effect of deadlock prevention mechanisms?,Increased system throughput,Higher device utilization,Reduced system throughput,Elimination of all resource request errors,Automatic detection of unsafe states,C,"Deadlock prevention limits how requests are made, which can lead to side effects such as low device utilization and reduced system throughput."
What additional information does a deadlock-avoidance algorithm typically require compared to deadlock prevention?,The current CPU utilization of each thread,A priori knowledge of the maximum resources each thread may need,The history of all resource requests made by threads,The priority level of each thread,The total number of threads currently in the system,B,"Deadlock avoidance requires additional information, specifically that the system needs to know the maximum resources each thread may need (a priori information)."
What is the primary goal of a deadlock-avoidance algorithm regarding the resource-allocation state?,To maximize device utilization regardless of deadlock potential,To ensure that all resource requests are immediately granted,To dynamically examine the resource-allocation state to prevent circular-wait,To convert all request edges into assignment edges,To reduce the complexity of resource allocation to O(n) operations,C,"A deadlock-avoidance algorithm dynamically examines the resource-allocation state to prevent circular-wait, which is a necessary condition for deadlock."
How is the resource-allocation state defined in the context of deadlock avoidance?,By the number of active threads and their priorities,By the amount of free memory and disk space,"By the available and allocated resources, and the maximum demands of each thread",By the historical success rate of resource requests,By the total system uptime and number of system calls,C,"The resource-allocation state is defined by the available and allocated resources, and the maximum demands of each thread."
What characterizes a 'safe state' in deadlock avoidance?,A state where no thread is currently holding any resources.,A state where the system can allocate resources to each thread (up to its maximum) in some order and avoid deadlock.,A state where all resource requests are immediately denied to prevent future issues.,A state where the system has detected a cycle in its resource-allocation graph.,A state where no new threads are allowed to enter the system.,B,A state is safe if the system can allocate resources to each thread (up to its maximum) in some order and avoid deadlock.
When is a system considered to be in a 'safe state'?,Only when no threads are currently executing.,If a safe sequence of threads exists.,If the current resource utilization is below 50%.,If no new resource requests have been made in the last minute.,If the system has sufficient memory to run all processes simultaneously.,B,A system is safe if a safe sequence exists.
"What defines a 'safe sequence' $<T_1, T_2, \dots, T_n>$?",Each $T_i$ finishes execution before $T_{i+1}$ begins.,"For each $T_i$, its resource requests can be met by currently available resources plus resources held by all $T_j$ where $j < i$.",All $T_i$ have exactly the same resource needs.,"The sequence is ordered by thread priority, from highest to lowest.",No thread in the sequence ever makes a resource request.,B,"A safe sequence is one where for each $T_i$, its resource requests can be met by currently available resources plus resources held by all $T_j$ where $j < i$."
"Which statement accurately describes the relationship between safe, unsafe, and deadlocked states?",All unsafe states are deadlocks.,A deadlocked state can be a safe state.,"A safe state is not deadlocked, and a deadlocked state is unsafe.",Unsafe states always lead to deadlock.,Only safe states can experience deadlocks.,C,"A safe state is not deadlocked; a deadlocked state is unsafe. While not all unsafe states are deadlocks, unsafe states may lead to deadlock."
"In an unsafe state, who or what controls whether a deadlock occurs?","The operating system, by enforcing strict resource limits.","The system administrator, by manually reallocating resources.","The thread behavior, as the OS cannot prevent deadlocks.",External hardware controllers.,"The resource-allocation-graph algorithm, which automatically resolves cycles.",C,"In an unsafe state, the OS cannot prevent deadlocks; thread behavior controls unsafe states."
The Resource-Allocation-Graph algorithm for deadlock avoidance is applicable to systems with:,Multiple instances of each resource type.,Only one instance of each resource type.,Only two resource types in total.,An unlimited number of resources.,Resources that are never released.,B,The Resource-Allocation-Graph algorithm is specifically for systems with only one instance of each resource type.
What does a 'claim edge' ($T_i 	o R_j$ dashed line) signify in a Resource-Allocation-Graph for deadlock avoidance?,Thread $T_i$ currently holds resource $R_j$.,Resource $R_j$ is currently available to $T_i$.,Thread $T_i$ may request resource $R_j$ in the future.,Resource $R_j$ is permanently assigned to $T_i$.,Thread $T_i$ has released resource $R_j$.,C,A claim edge ($T_i 	o R_j$ dashed line) indicates that $T_i$ may request $R_j$ in the future.
"In the Resource-Allocation-Graph algorithm, when does a claim edge $T_i 	o R_j$ get converted to a request edge?",When $T_i$ releases $R_j$.,When $R_j$ is allocated to $T_i$.,When $T_i$ requests $R_j$.,When $R_j$ becomes available.,When a new thread enters the system.,C,A claim edge $T_i 	o R_j$ is converted to a request edge when $T_i$ requests $R_j$.
"According to the Resource-Allocation-Graph algorithm, when is a resource request granted?","Always, as long as the resource is available.",Only if no other thread is waiting for the same resource.,Only if no cycle is formed in the graph after the hypothetical allocation.,If the requesting thread has the highest priority.,Only if the graph contains no claim edges.,C,"A request is granted only if no cycle is formed in the graph, which is checked by a cycle-detection algorithm."
What does the presence of a cycle in the Resource-Allocation-Graph indicate in the context of deadlock avoidance?,A safe state.,An efficient resource allocation.,"An unsafe state, potentially leading to deadlock.",That all resources are fully utilized.,That a thread has finished its execution.,C,"A cycle indicates an unsafe state, meaning that the system could potentially enter a deadlocked state."
What is the time complexity of the Resource-Allocation-Graph algorithm for deadlock avoidance?,$O(n)$ operations,$O(m 	imes n)$ operations,$O(n^2)$ operations,$O(m^2)$ operations,$O(log n)$ operations,C,"The algorithm complexity for the Resource-Allocation-Graph algorithm is $O(n^2)$ operations, where $n$ is the number of threads."
The Banker's algorithm is specifically designed for systems with:,Only one instance of each resource type.,Multiple instances of each resource type.,A fixed number of threads.,No resource sharing.,Resource types that cannot be claimed a priori.,B,The Banker's algorithm is applicable to systems with multiple instances of each resource type.
How does the efficiency of the Banker's algorithm compare to the Resource-Allocation-Graph scheme?,It is generally more efficient.,It is generally less efficient.,They have comparable efficiency.,Efficiency depends solely on the number of resource types.,Efficiency depends solely on the number of threads.,B,The Banker's algorithm is described as 'Less efficient than resource-allocation graph scheme'.
What information must a new thread declare when it enters a system using the Banker's algorithm?,Its current CPU usage.,Its maximum demand for instances of each resource type.,The total time it expects to run.,Its priority level.,Whether it will ever release resources.,B,"When a new thread enters, it declares the maximum instances of each resource type needed (which cannot exceed total system resources)."
"Under the Banker's algorithm, a resource request is granted only if:",The requested resources are immediately available.,The allocation leaves the system in a safe state.,The requesting thread has the highest priority.,No other thread is currently waiting for any resource.,The system's total resource utilization is below 80%.,B,A request is granted only if allocation leaves the system in a safe state.
"In the Banker's algorithm, what does the `Available` vector represent?",The maximum number of instances of each resource type in the system.,The number of resources of each type currently allocated to threads.,The number of available resources of each type.,The remaining resource need of each thread.,The total number of threads waiting for resources.,C,`Available` is a vector of length $m$ representing the number of available resources of each type.
Which data structure in the Banker's algorithm represents the maximum demand of each thread?,Allocation,Need,Work,Max,Available,D,`Max` is an $n 	imes m$ matrix representing the max demand of each thread.
"In the Banker's algorithm, the `Need` matrix is calculated as:",`Need[i][j] = Available[j] - Allocation[i][j]`,`Need[i][j] = Max[i][j] + Allocation[i][j]`,`Need[i][j] = Max[i][j] - Allocation[i][j]`,`Need[i][j] = Allocation[i][j] - Available[j]`,`Need[i][j] = Work[j] - Max[i][j]`,C,The `Need` matrix represents the remaining resource need of each thread and is calculated as `Need[i][j] = Max[i][j] - Allocation[i][j]`.
What is the first step in the Banker's Safety Algorithm?,Find an index `i` such that `Finish[i] == false`.,Initialize `Work = Available` and `Finish[i] = false` for all threads.,Check if `Request_i <= Need_i`.,Grant the resource request.,Restore the old state of resources.,B,"The first step of the Safety Algorithm is to 'Initialize Work = Available, Finish[i] = false for i = 0, 1, ..., n-1'."
"In the Banker's Safety Algorithm, if no index `i` can be found such that `Finish[i] == false` and `Need_i <= Work`, what happens next?",The system is declared safe.,The algorithm restarts from step 1.,The algorithm proceeds to check if `Finish[i] == true` for all `i`.,A deadlock is immediately declared.,The `Work` vector is reset to `Available`.,C,"If no such `i` is found, the algorithm proceeds to step 4: 'If Finish[i] == true for all i, system is in safe state.'."
What is the time complexity of the Banker's Safety Algorithm?,$O(n)$ operations,$O(m + n)$ operations,$O(n^2)$ operations,$O(m 	imes n^2)$ operations,$O(m^2 	imes n)$ operations,D,The algorithm complexity for the Banker's Safety Algorithm is $O(m 	imes n^2)$ operations.
"When a thread $T_i$ makes a resource request $Request_i$ in the Banker's Resource-request algorithm, what is the first condition checked?",If $Request_i \le Available$,If the resulting state is safe.,If $Request_i \le Need_i$,If $Allocation_i + Request_i \le Max_i$,If $Need_i$ is zero.,C,"The first step is: 'If $Request_i \le Need_i$, go to step 2. Else, error (thread exceeded max claim).'"
"In the Banker's Resource-request algorithm, if $Request_i \le Available$ is false, what happens to thread $T_i$?",$T_i$ is immediately terminated.,The request is granted without further checks.,$T_i$ must wait.,The system enters an unsafe state.,The resource matrices are updated with the request.,C,"If $Request_i \le Available$ is false, it means the resources are currently unavailable, so '$T_i$ must wait'."
What happens during the 'pretend allocation' step in the Banker's Resource-request algorithm?,The system calculates the maximum possible future requests.,"The `Available` resources are increased, and `Allocation_i` is decreased.","The `Available`, `Allocation_i`, and `Need_i` matrices are updated as if the request were granted.",The algorithm checks for cycles in the resource graph.,The system asks for user confirmation to proceed.,C,"Pretend allocation involves updating `Available = Available - Request_i`, `Allocation_i = Allocation_i + Request_i`, and `Need_i = Need_i - Request_i`."
"If the state resulting from a 'pretend allocation' in the Banker's Resource-request algorithm is found to be unsafe, what action is taken?","The request is granted, but a warning is issued.",The system immediately initiates a deadlock recovery process.,"The request is granted, and the system moves to an unsafe state.","$T_i$ waits, and the old state of the resource allocation is restored.",All other threads are temporarily suspended.,D,"If the resulting state is unsafe (using the Safety Algorithm), then '$T_i$ waits, restore old state'."
Under what circumstances is a deadlock detection algorithm typically employed in a system?,When the system uses aggressive deadlock prevention mechanisms.,When the system exclusively relies on deadlock avoidance strategies.,When the system does not implement deadlock-prevention or deadlock-avoidance techniques.,Only in real-time operating systems where deadlocks are strictly forbidden.,During system startup to identify potential resource conflicts.,C,"Deadlock detection algorithms are used in systems that do not employ deadlock-prevention or deadlock-avoidance, requiring an algorithm to determine if deadlock has occurred and another to recover from it."
What are the primary components involved when a system uses a deadlock detection approach?,A resource preemption mechanism and a rollback strategy.,An algorithm to detect deadlock and an algorithm to recover from it.,A method for safe sequence generation and a resource request denial mechanism.,A system for resource ordering and a method for breaking mutual exclusion.,A Banker's algorithm for resource allocation and a wait-for graph.,B,"If a system doesn't use deadlock-prevention or deadlock-avoidance, it needs both an algorithm to determine if a deadlock occurred and an algorithm to recover from it."
What is a significant overhead associated with deadlock detection and recovery?,Increased memory consumption for data structures.,Higher CPU utilization due to frequent context switching.,Run-time costs for detection and potential losses from recovery.,Complexity in implementing resource preemption.,The need for user intervention during recovery.,C,The text states that detection-and-recovery overhead includes run-time costs and potential losses from recovery.
Which graph is used for deadlock detection when there is a single instance of each resource type?,Resource-allocation graph.,Process-resource graph.,Wait-for graph.,Dependency graph.,Allocation matrix.,C,"For single instances of each resource type, the wait-for graph is used, which is a variant of the resource-allocation graph."
How is a wait-for graph obtained from a resource-allocation graph?,By adding resource nodes and new edges.,By removing resource nodes and collapsing edges.,By reversing all existing edges.,By adding a separate node for each available resource instance.,By only including threads that are currently holding resources.,B,A wait-for graph is obtained by removing resource nodes and collapsing edges from the resource-allocation graph.
"In a wait-for graph, what does an edge from thread $T_i$ to thread $T_j$ ($T_i 	o T_j$) signify?",$T_i$ has allocated a resource to $T_j$.,$T_j$ is waiting for a resource held by $T_i$.,$T_i$ is waiting for $T_j$ to release a resource $T_i$ needs.,$T_i$ and $T_j$ are in a safe state.,$T_j$ is a child process of $T_i$.,C,An edge $T_i 	o T_j$ in a wait-for graph implies thread $T_i$ is waiting for thread $T_j$ to release a resource $R_q$ that $T_i$ needs.
"When detecting deadlocks using a wait-for graph, what condition indicates the presence of a deadlock?",The graph is empty.,The graph contains a directed cycle.,All threads are connected to each other.,The graph is a tree structure.,There is a direct edge from every thread to itself.,B,Deadlock exists if the wait-for graph contains a cycle.
"What is the computational complexity of cycle detection in a wait-for graph, where $n$ is the number of vertices?",$O(n)$,$O(n \log n)$,$O(n^2)$,$O(n^3)$,$O(2^n)$,C,"Cycle detection in a wait-for graph has a complexity of $O(n^2)$ operations, where $n$ is the number of vertices."
Which tool from the BCC toolkit is mentioned for detecting deadlocks in Pthreads mutex locks on Linux?,`pthread_analyzer`,`mutex_monitor`,`deadlock_detector`,`resource_tracker`,`lock_debugger`,C,The `deadlock_detector` tool from the BCC toolkit is specifically mentioned for Pthreads mutex locks on Linux.
How does the `deadlock_detector` tool identify deadlocks?,By analyzing system call logs for mutex timeouts.,By simulating thread execution paths.,"By inserting probes to trace `pthread_mutex_lock()` and `pthread_mutex_unlock()` calls, constructing a wait-for graph, and detecting cycles.",By directly inspecting thread stack traces for blocked calls.,By monitoring CPU utilization patterns for anomalies.,C,"The `deadlock_detector` tool inserts probes to trace `pthread_mutex_lock()` and `pthread_mutex_unlock()`, constructs a wait-for graph, and reports deadlock if a cycle is detected."
"When a system has several instances of a resource type, why is the wait-for graph scheme not applicable for deadlock detection?",It becomes too complex to draw.,It only works for a single resource type.,The graph representation cannot effectively model multiple instances of a resource.,Resource nodes cannot be collapsed when multiple instances exist.,The cycle detection algorithm is not efficient for this scenario.,C,"The text states that the wait-for graph scheme is not applicable for several instances of a resource type, implying that its simplified representation is insufficient for the more complex resource allocation involving multiple instances."
"What are the three main data structures used in the deadlock detection algorithm for several instances of a resource type, similar to the Banker's algorithm?","Total, Max, Need.","Available, Allocation, Request.","Work, Finish, Safe.","Resources, Processes, States.","Graph, Cycle, Path.",B,"The algorithm uses `Available` (vector), `Allocation` (n x m matrix), and `Request` (n x m matrix)."
"In the deadlock detection algorithm for multiple resource instances, what does `Request[i][j] = k` signify?",Thread $T_i$ has $k$ instances of resource $R_j$ allocated.,Thread $T_i$ requests $k$ more instances of resource type $R_j$.,There are $k$ total instances of resource $R_j$ available.,Resource $R_j$ is needed by $k$ threads.,Thread $T_j$ requests $k$ instances of resource $R_i$.,B,`Request[i][j] = k` means thread $T_i$ requests $k$ more instances of resource type $R_j$.
What is the first step in the deadlock detection algorithm for several instances of a resource type?,Find an index $i$ such that `Finish[i] == false` and `Request_i <= Work`.,Update `Work` by adding `Allocation_i`.,Initialize `Work` = `Available` and `Finish` array based on `Allocation`.,Check if `Finish[i] == false` for any $i$.,Select a victim thread to terminate.,C,"Step 1 of the algorithm is to Initialize `Work` = `Available` and set `Finish[i]` to `false` if `Allocation_i` is not zero, or `true` otherwise."
"In the deadlock detection algorithm for multiple resource instances, if no index $i$ is found where `Finish[i] == false` and `Request_i <= Work`, what is the next action?",Assume the system is in a safe state.,Go back to Step 1 and reinitialize.,Proceed to the step that checks for deadlocked threads.,Grant the pending resource request to a thread.,Rollback the last transaction.,C,"If no such $i$ exists (in step 2), the algorithm proceeds to step 4, which is where it determines if any threads are deadlocked."
"According to the deadlock detection algorithm for multiple resource instances, how is a deadlocked thread identified?",A thread is deadlocked if its `Request` matrix is non-zero.,A thread is deadlocked if its `Allocation` is greater than `Available`.,A thread $T_i$ is deadlocked if `Finish[i] == false` after the algorithm completes.,A thread $T_i$ is deadlocked if it is found in a cycle in the wait-for graph.,A thread $T_i$ is deadlocked if its resources cannot be reclaimed by other threads.,C,"Step 4 states: 'If `Finish[i] == false` for some $i$, $0 \leq i < n$, then thread $T_i$ is deadlocked.'"
What is the computational complexity of the deadlock detection algorithm for several instances of a resource type?,$O(n+m)$,$O(n 	imes m)$,$O(m 	imes n^2)$,$O(n^2)$,$O(m^2 	imes n)$,C,The algorithm complexity is stated as $O(m 	imes n^2)$ operations.
What 'optimistic attitude' is assumed by the deadlock detection algorithm for multiple resource instances?,That all resource requests will eventually be granted.,"That if a thread's `Request` is less than or equal to `Work`, it will complete and return its resources.",That deadlocks are rare and can be ignored.,That all threads will eventually release their allocated resources.,That resources are infinite and always available.,B,"The algorithm assumes an optimistic attitude: if `Request_i <= Work`, it assumes $T_i$ will complete and return resources."
"Given the initial state in the example for multiple instances (5 threads, 3 resource types, specific allocations and requests), what sequence of threads leads to all `Finish[i]` being true, indicating no deadlock?","$<T_4, T_1, T_3, T_2, T_0>$","$<T_0, T_2, T_3, T_1, T_4>$","$<T_1, T_0, T_4, T_2, T_3>$","$<T_2, T_3, T_0, T_1, T_4>$","$<T_0, T_1, T_2, T_3, T_4>$",B,"The text explicitly states: 'Sequence $<T_0, T_2, T_3, T_1, T_4>$ results in Finish[i] == true for all i', indicating no initial deadlock."
"If thread $T_2$ requests 1 additional instance of resource C in the provided example, which threads become involved in the deadlock?","$T_0, T_1, T_2$","$T_1, T_2, T_3, T_4$","$T_0, T_3, T_4$","$T_0, T_1, T_2, T_3, T_4$",No deadlock occurs.,B,"The text states: 'New claim: system is deadlocked. Can reclaim $T_0$'s resources, but not enough for others. Deadlock involves $T_1, T_2, T_3, T_4$."
What two factors determine when a deadlock detection algorithm should be invoked?,System uptime and available memory.,The complexity of the algorithm and the number of resource types.,How often a deadlock is likely to occur and how many threads will be affected.,The current CPU utilization and disk I/O rate.,The size of the wait-for graph and the number of cycles detected previously.,C,The decision of when to invoke depends on 'How often is a deadlock likely to occur?' and 'How many threads will be affected by deadlock when it happens?'
What is a consequence of not frequently invoking a deadlock detection algorithm when deadlocks are likely to occur?,Increased system throughput.,Reduced computational overhead.,"Resources allocated to deadlocked threads become idle, and the number of threads in the deadlock cycle may grow.",Faster recovery times once a deadlock is eventually detected.,Improved responsiveness for non-deadlocked threads.,C,"If deadlocks are frequent and detection is not, 'Resources allocated to deadlocked threads become idle; number of threads in deadlock cycle may grow.'"
What is the main advantage of invoking a deadlock detection algorithm every time a resource request cannot be granted immediately?,It ensures the lowest possible computational overhead.,It allows for easier selection of a victim thread.,It identifies deadlocked threads and the specific thread that 'caused' the deadlock.,It guarantees that no deadlock will ever occur.,It is simpler to implement than periodic checks.,C,Invoking the algorithm every time a request cannot be granted 'Identifies deadlocked threads and the specific thread that 'caused' the deadlock.'
"What is a disadvantage of invoking a deadlock detection algorithm at defined intervals (e.g., hourly or when CPU utilization drops)?",It has very high computational overhead.,It might not identify the 'causing' thread.,It cannot detect deadlocks involving multiple resource types.,It requires manual intervention to start the detection process.,It prevents resources from becoming idle.,B,The text states that invoking at defined intervals 'May not identify the 'causing' thread.'
How do database systems typically manage deadlocks?,By preventing them entirely through careful transaction design.,By avoiding them using a strict ordering protocol.,By using deadlock detection and recovery mechanisms.,By preempting transactions that hold too many locks.,By limiting the number of concurrent transactions.,C,Database systems manage deadlock using detection and recovery.
"In database systems, what happens after a deadlock is detected?",All transactions involved in the deadlock are immediately terminated.,The system pauses until manual intervention resolves the deadlock.,"A victim transaction is selected, aborted, rolled back, and then reissued.",All locks held by deadlocked transactions are automatically released without rollback.,The database is put into a read-only state until the deadlock clears.,C,"When a deadlock is detected: a victim transaction is selected, aborted and rolled back (releasing its locks), remaining transactions are freed, and the aborted transaction is reissued."
"In the context of database deadlocks, what is a common criterion for selecting a victim transaction?",The transaction that has been running the longest.,The transaction that holds the most locks.,"The transaction that has modified the fewest rows (e.g., in MySQL).",The transaction with the highest priority.,The transaction that was started most recently.,C,"For victim choice, the text provides an example: 'e.g., MySQL minimizes rows inserted, updated, or deleted.'"
What is the definition of a 'wait-for graph' in the context of deadlock detection?,A graph showing which resources are currently available.,A graph illustrating the flow of data between threads.,"A variant of the resource-allocation graph with resource nodes removed, indicating a deadlock if it contains a cycle.","A graph used exclusively for deadlock avoidance, not detection.",A graph representing the historical usage of resources by threads.,C,"The glossary defines 'wait-for graph' as 'In deadlock detection, a variant of the resource-allocation graph with resource nodes removed; indicates a deadlock if the graph contains a cycle.'"
"What is a 'thread dump' and for what purpose is it useful, especially in Java?",A utility to delete inactive threads from memory.,A method to reorder thread execution for performance optimization.,"A snapshot of the state of all threads in an application, useful for debugging deadlocks.",A process of transferring threads between different CPU cores.,A tool for automatically resolving deadlocks without user intervention.,C,"The glossary defines 'thread dump' as 'In Java, a snapshot of the state of all threads in an application; a useful debugging tool for deadlocks.'"
"When a deadlock is detected in a system, what are the two primary high-level options for recovery?",Increase system resources or perform a system reboot.,Inform the operator for manual intervention or allow the system to recover automatically.,Implement a resource ordering scheme or decrease the number of active processes.,Initiate a full system backup or restart all services.,Isolate the deadlocked threads or implement a timeout mechanism.,B,"The text states that when deadlock is detected, the options are to 'Inform operator (manual recovery)' or for the 'System recovers automatically.'"
Which two specific methods are identified for actively breaking a detected deadlock?,Implementing a banker's algorithm and resource allocation graph.,Increasing process priorities and allowing threads to self-terminate.,"Aborting one or more threads, or preempting resources from deadlocked threads.",Rolling back all transactions and forcing a context switch.,Reducing the number of available resources and blocking new process creation.,C,The text explicitly lists 'Abort one or more threads (break circular wait)' and 'Preempt resources from deadlocked threads' as the two options for breaking deadlock.
"When a process or thread is aborted as a method to eliminate a deadlock, what happens to the resources it was holding?",They remain allocated to the aborted process for a grace period.,They are immediately reallocated to other waiting processes.,The system reclaims all resources held by the aborted entity.,They are put into a pending state until manual intervention.,They are transferred to a quarantine area to prevent further issues.,C,"The text states, 'System reclaims all resources' when a process/thread is aborted."
What is a significant drawback of choosing to 'abort all deadlocked processes' as a deadlock recovery method?,It may not break the deadlock cycle immediately.,It leads to low overhead as all processes are treated uniformly.,It is expensive due to discarded computations and the need for recomputation.,"It primarily affects only the resources, not the processes themselves.",It requires continuous deadlock detection after each abort.,C,"The text states that 'Abort all deadlocked processes' is 'expensive (discarded computations, recomputation needed).'"
Why does the method of 'abort one process at a time until deadlock eliminated' have high overhead?,It requires complex resource preemption strategies.,It involves discarding all system-wide computations.,It necessitates deadlock-detection after each individual abort.,It often results in file and shared data integrity issues.,It can lead to system-wide starvation of processes.,C,The text indicates that 'Abort one process at a time until deadlock eliminated' has 'High overhead (deadlock-detection after each abort).'
What issue can arise if a process that is currently updating a file is aborted during deadlock recovery?,The file will be permanently deleted from the system.,The file may remain in an incorrect or inconsistent state.,The system will automatically create a backup of the file.,The file's access permissions will be corrupted.,"The file will be locked indefinitely, preventing any further access.",B,The text lists 'File in incorrect state if updating' as an issue when aborting processes.
"If a process updating shared data while holding a mutex lock is aborted during deadlock recovery, what is a primary concern?",The mutex lock will be permanently lost.,Other processes will immediately gain access to the data.,"Shared data integrity issues may occur, and the lock status must be restored.",The system will automatically reinitialize all shared data.,It will trigger a complete system reboot.,C,The text notes 'Shared data integrity issues if updating while holding mutex lock (must restore lock status)' as a concern.
"In the context of partial termination for deadlock recovery, how is the specific process to be terminated typically determined?",Randomly selected by the system.,The process that has been running the longest.,"Based on a policy decision, often economic in nature.",The process that is holding the fewest resources.,The process with the lowest CPU utilization.,C,"The text states that determining which process to terminate is a 'policy decision, economic.'"
"Which of the following is explicitly listed as a factor for choosing a victim process to terminate during deadlock recovery, aiming to minimize cost?",The process's network bandwidth usage.,The process's input/output operations per second.,The process's priority.,The process's total memory footprint.,The process's average response time.,C,'Process priority' is explicitly listed as a factor for choosing a victim to minimize cost.
"When selecting a victim process to terminate, what aspect of 'computation time' is considered to minimize cost?",Only the future projected computation time.,Only the past historical average computation time.,How long the process has computed and how much longer it needs.,The peak computation time achieved by the process.,The time spent waiting for I/O operations.,C,"The text specifies 'Computation time (how long computed, how much longer)' as a factor for choosing a victim."
"Which characteristic of 'Resources used' is relevant when choosing a victim for deadlock termination, aiming for minimum cost?",The absolute monetary value of the resources.,The types of resources and their ease of preemption.,Whether the resources are shared or exclusive.,The total number of unique resources held.,The age of the resources allocated.,B,"The text lists 'Resources used (types, ease of preemption)' as a factor for choosing a victim."
"In the context of deadlock recovery, what does 'resource preemption' primarily involve?",Preventing processes from acquiring new resources.,Allowing processes to voluntarily release resources.,Successively taking resources from processes and giving them to others until the deadlock is broken.,Limiting the total number of resources available in the system.,Reordering resource requests to avoid circular wait.,C,"The text defines resource preemption as 'Successively preempt resources from processes, give to others until deadlock broken.'"
"When performing resource preemption, what is the primary objective when 'selecting a victim' process or resource?",To ensure the highest priority process is always selected.,"To minimize the cost, such as resources held or time consumed.",To select the process that has used the least amount of CPU time.,To always preempt resources that are easy to reclaim.,To avoid selecting any process that is performing I/O.,B,"The text states, 'Selecting a victim: Which resources/processes to preempt? Minimize cost (e.g., resources held, time consumed).'"
"If a process has its resources preempted during deadlock recovery, what is the immediate consequence regarding its execution?",It can continue normal execution but with reduced performance.,It must roll back to a safe state and restart its operation.,It is immediately terminated without any further action.,It waits indefinitely for the preempted resources to become available.,It enters a recovery mode where it can request new resources.,B,"The text states that a preempted process 'Cannot continue normal execution (missing resource)' and must 'Roll back to safe state, restart.'"
What is considered the simplest method for rollback when a process has its resources preempted?,Partial rollback to the last checkpoint.,Selective restoration of only critical resources.,"Total rollback, which involves aborting and restarting the process.",Waiting for the system to automatically restore the process state.,Initiating a recovery mode boot.,C,"The text describes 'Simplest: total rollback (abort, restart).'"
"For a more effective rollback strategy in resource preemption, what is generally required from the system?",Less system state information.,The ability to roll back only as necessary.,A simpler recovery mode.,Avoiding any form of process restart.,Preempting all resources from all processes.,B,"The text states, 'More effective: roll back only as necessary (requires more state info).'"
What is a common solution to prevent starvation when continuously preempting resources from processes during deadlock recovery?,Randomly selecting processes for preemption.,Setting a maximum limit on the number of resources a process can hold.,Including the number of rollbacks in the cost factor for victim selection.,"Implementing a first-come, first-served resource allocation policy.",Prioritizing processes that have never been preempted before.,C,"The text suggests, 'Common solution: include number of rollbacks in cost factor' to ensure a process is picked as a victim a finite number of times."
"According to the provided glossary, what is the primary purpose of 'recovery mode'?",To provide full system services for normal operation.,To allow users to create new system configurations.,To enable system administrators to repair system problems and debug system startup.,To automatically restore data from the last backup.,To monitor system performance under heavy load.,C,The glossary defines 'recovery mode' as 'A system boot state providing limited services and designed to enable the system admin to repair system problems and debug system startup.'
"In the context of operating systems, what is the definition of a deadlock?",A state where a process continuously acquires and releases resources without making progress.,A set of processes where each process is waiting for an event that can only be caused by another process within that same set.,An error state where a process terminates unexpectedly due to a resource conflict.,"A condition where a single process holds all available resources, preventing others from running.",A mechanism used by the operating system to prioritize important processes over less critical ones.,B,"The text defines a deadlock as a 'set of processes, each waiting for event caused by another process in set.'"
Which of the following is NOT listed as one of the four necessary conditions for a deadlock to occur?,Mutual exclusion,Hold and wait,Resource sharing,No preemption,Circular wait,C,"The four necessary conditions for deadlock are Mutual exclusion, Hold and wait, No preemption, and Circular wait. Resource sharing is not one of them."
"For a deadlock to be possible, which of the following statements must be true regarding the four necessary conditions?",At least one of the conditions must be present for a deadlock to initiate.,Only two of the four conditions are strictly required for a deadlock to form.,All four conditions must be present simultaneously for a deadlock to be possible.,"The conditions are only relevant for deadlock prevention, not for the occurrence itself.",The presence of any single condition is enough to guarantee a deadlock.,C,"The text explicitly states, 'Deadlock only possible if all four conditions present.'"
"How are deadlocks typically modeled, and what characteristic within this model indicates the presence of a deadlock?",Using process flowcharts; a linear progression without branches.,Using resource-allocation graphs; the presence of a cycle.,Using system call tables; a high number of repeated system calls.,Using memory usage diagrams; a significant spike in memory consumption.,Using CPU scheduling algorithms; a consistently low CPU utilization rate.,B,"The text states, 'Deadlocks modeled with resource-allocation graphs; cycle indicates deadlock.'"
"Which necessary condition for deadlock implies that at least one resource must be held in a non-sharable mode, meaning only one process at a time can use it?",Hold and wait,No preemption,Circular wait,Mutual exclusion,Resource availability,D,"Mutual exclusion refers to resources that cannot be shared simultaneously, meaning only one process can use them at a time."
A process currently holds a file lock and is waiting to acquire access to a database record that is currently held by another process. This scenario exemplifies which necessary condition for deadlock?,Circular wait,No preemption,Mutual exclusion,Hold and wait,Resource preemption,D,Hold and wait means a process holds at least one resource and is waiting to acquire additional resources held by other processes.
Which necessary condition for deadlock dictates that resources cannot be forcibly taken from a process; they must be released voluntarily by the process holding them upon completion?,Mutual exclusion,Hold and wait,No preemption,Circular wait,Resource sharing,C,No preemption means resources cannot be forcibly taken from a process; they must be released voluntarily.
"In a system, Process P1 is waiting for a resource held by P2, P2 is waiting for a resource held by P3, and P3 is waiting for a resource held by P1. This chain represents which necessary condition for deadlock?",Mutual exclusion,Hold and wait,No preemption,Resource preemption,Circular wait,E,"Circular wait describes a chain of processes, each waiting for a resource held by the next process in the chain, forming a closed loop."
What is the fundamental approach of deadlock prevention?,To detect deadlocks once they occur and initiate a recovery procedure.,To allow deadlocks to happen but ensure a rapid and efficient recovery process.,To ensure that at least one of the four necessary conditions for deadlock cannot occur.,To always grant resource requests as long as resources are physically available.,To run a detection algorithm periodically to find and log deadlocked states.,C,Deadlock prevention strategies aim to 'ensure one of four conditions cannot occur.'
Which of the four necessary conditions for deadlock is explicitly mentioned as the most practical to eliminate in a deadlock prevention strategy?,Mutual exclusion,Hold and wait,No preemption,Circular wait,Resource preemption,D,The text specifies 'Practical prevention: eliminate circular wait.'
Which algorithm is specifically mentioned as being used for deadlock avoidance?,"First-Come, First-Served (FCFS) algorithm",Round Robin (RR) algorithm,Banker's algorithm,Priority Scheduling algorithm,Least Recently Used (LRU) algorithm,C,Deadlock avoidance is implemented using the 'banker's algorithm'.
The core principle guiding resource allocation in deadlock avoidance is to:,Allow processes to hold resources indefinitely until explicitly released.,Grant resource requests only if doing so will not lead the system into an unsafe state.,Preempt resources from any process that has been waiting for a resource for a prolonged period.,Immediately terminate any process identified as being part of a circular wait.,Always grant resource requests to maximize system throughput and resource utilization.,B,Deadlock avoidance involves not granting resources if doing so 'leads to unsafe state'.
What is the primary function of a deadlock detection algorithm?,To prevent any of the four necessary deadlock conditions from occurring in the first place.,To dynamically allocate resources in a way that avoids entering an unsafe state.,To evaluate processes and resources on a running system to identify if a deadlocked state currently exists.,To recover from a deadlock by automatically aborting all involved processes.,To ensure mutual exclusion for all critical resources in the system.,C,Deadlock detection involves an 'algorithm evaluates processes/resources on running system to find deadlocked state'.
Which of the following is a direct method for deadlock recovery?,Implementing a strict preemption policy for all resources.,Continuously checking for safe states using the Banker's algorithm.,Aborting one process that is part of the circular wait condition.,Allowing processes to complete their execution regardless of their state.,Increasing the number of available resources dynamically.,C,One recovery method listed is 'Abort one process in circular wait'.
"In addition to aborting processes, what is another method of deadlock recovery mentioned?","Granting all pending resource requests immediately, even if it leads to an unsafe state.",Disabling mutual exclusion for all resources system-wide.,Preempting resources that have been assigned to a deadlocked process.,Restarting the entire operating system to clear all resource allocations.,Delaying all new process creations until the system becomes idle.,C,The other recovery method listed is 'Preempt resources assigned to deadlocked process'.
