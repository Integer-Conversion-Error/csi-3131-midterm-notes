Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
What is the primary function of the `pthread_mutex_init()` function in Pthreads?,Acquires a mutex lock.,Releases a mutex lock.,Initializes an unlocked mutex.,Destroys a mutex.,Blocks if a lock is held.,C,The text states that `pthread_mutex_init()` initializes an unlocked mutex.
What happens when a thread calls `pthread_mutex_lock()` on a mutex that is currently held by another thread?,It immediately acquires the lock.,It returns an error code.,It blocks until the lock is released.,It initializes a new mutex.,It releases the lock it holds.,C,The text states that `pthread_mutex_lock()` acquires a lock and 'blocks if the lock is held'.
What is the purpose of the `pthread_mutex_unlock()` function?,To attempt to acquire a lock without blocking.,To release a mutex lock.,To initialize a mutex.,To check the status of a mutex.,To destroy a mutex.,B,The text explicitly states that `pthread_mutex_unlock()` releases a lock.
"In the Pthreads example demonstrating deadlock, how many mutex locks and threads are involved in the scenario?","One mutex, two threads.","Two mutexes, one thread.","Two mutexes, two threads.","Three mutexes, two threads.","One mutex, one thread.",C,"The deadlock scenario description mentions 'Two mutex locks created: `first_mutex`, `second_mutex`' and 'Two threads, `thread_one` and `thread_two`'."
Which locking order between `thread_one` and `thread_two` is described as leading to a potential deadlock in the provided example?,`thread_one` locks `first_mutex` then `second_mutex`; `thread_two` also locks `first_mutex` then `second_mutex`.,`thread_one` locks `first_mutex` then `second_mutex`; `thread_two` locks `second_mutex` then `first_mutex`.,`thread_one` locks `second_mutex` then `first_mutex`; `thread_two` locks `first_mutex` then `second_mutex`.,Both threads attempt to lock both mutexes simultaneously.,Both threads lock `second_mutex` then `first_mutex`.,B,"The text states: '`thread_one` locks in order: (1) `first_mutex`, (2) `second_mutex`' and '`thread_two` locks in order: (1) `second_mutex`, (2) `first_mutex`'."
What specific condition must occur for a deadlock to be possible in the given Pthreads example?,Both threads acquire both `first_mutex` and `second_mutex` successfully in their specified order.,"`thread_one` acquires `first_mutex` and `thread_two` acquires `second_mutex`, leading both to block waiting for the other's lock.",One thread acquires and releases both locks before the other thread starts execution.,Neither thread is able to acquire any mutex lock.,Both threads acquire `second_mutex` and then `first_mutex`.,B,"The text explains the deadlock is possible 'If `thread_one` acquires `first_mutex` and `thread_two` acquires `second_mutex`, both threads will block waiting for the other's lock'."
Why is it often difficult to identify and test for deadlocks in multithreaded applications?,"Deadlocks always cause immediate system crashes, preventing analysis.",Deadlock detection tools are not available for multithreaded environments.,The occurrence of deadlock is intermittent and depends on the CPU scheduler.,"Deadlocks only manifest on specific hardware architectures, not in testing environments.","Deadlocks only occur when applications are under extremely high load, making replication hard.",C,The text states: 'Deadlock might not occur if one thread acquires and releases both locks before the other thread starts.' and 'Occurrence depends on the CPU scheduler.' which 'Makes identifying and testing for deadlocks difficult'.
Which characteristic distinguishes livelock from deadlock?,"In livelock, threads are permanently blocked and cannot execute.",Livelock applies only to single-threaded applications.,"In livelock, threads are actively attempting operations but fail to make progress.",Livelock results in resources being continuously acquired and released productively.,"Livelock is a type of resource starvation, not a liveness failure.",C,"The text states livelock is 'Similar to deadlock, but threads are not blocked' and illustrates with the analogy of two people 'They are active but make no progress'."
"According to the provided text, what is the core condition that defines livelock?",A thread becomes permanently blocked while waiting for a resource.,A thread continuously attempts an action that fails.,A thread repeatedly acquires and releases a lock successfully.,A thread is unable to acquire any resource due to other threads holding them indefinitely.,A thread enters an infinite loop performing meaningful work.,B,The text defines livelock as a 'Condition: A thread continuously attempts an action that fails' and the glossary also states this.
What is the behavior of `pthread_mutex_trylock()` when it attempts to acquire a lock that is already held by another thread?,It blocks the calling thread until the lock becomes available.,It forces the lock to be released by the current holder.,"It attempts to acquire the lock and returns immediately, indicating success or failure, without blocking.",It initializes a new mutex if the requested one is unavailable.,It causes a deadlock if the lock is held.,C,"The text states `pthread_mutex_trylock()` 'attempts to acquire a lock without blocking'. If it cannot acquire, it will indicate failure, allowing the thread to proceed without waiting."
"In the Pthreads livelock scenario involving `pthread_mutex_trylock()`, what sequence of events leads to livelock?",Both threads successfully acquire their first mutex and then block indefinitely on the second mutex.,"`thread_one` acquires `first_mutex`, `thread_two` acquires `second_mutex`; both fail to acquire the other's mutex using `trylock`, release their own, and repeat indefinitely.","One thread acquires both locks and completes its work, allowing the other thread to proceed.","Both threads attempt to acquire all locks simultaneously, causing a system error.","Threads acquire locks in a random order, eventually resolving the contention.",B,"The text describes the livelock scenario: '`thread_one` acquires `first_mutex`, `thread_two` acquires `second_mutex`. Both then call `trylock` on the other mutex, which fails. They release their locks and repeat indefinitely.'"
What is a common strategy mentioned to avoid livelock?,Ensuring all threads acquire locks in a predefined global order.,Having threads retry failing operations at random times.,Using blocking lock acquisition mechanisms exclusively.,Minimizing the number of shared resources between threads.,Implementing a watchdog timer to terminate non-progressing threads.,B,The text states that livelock 'Can be avoided by having threads retry at random times'.
"The Ethernet example, where hosts involved in a network collision 'backoff' for a random period before retransmitting, is used to illustrate a method for avoiding which concurrency issue?",Deadlock.,Race condition.,Starvation.,Livelock.,Data inconsistency.,D,"This example is provided directly under the 'Avoidance' section for Livelock, showing how random backoff helps prevent threads from repeatedly failing at the same time."
"Compared to deadlock, what is stated about the commonness of livelock in concurrent application design?",It is far more common than deadlock.,It is equally common as deadlock.,It is less common than deadlock.,It is a theoretical concept that does not occur in real-world applications.,Its commonness depends entirely on the operating system used.,C,"The text explicitly states that livelock is 'Less common than deadlock, but still a challenge'."
"According to the Section Glossary, what is the definition of livelock?","A condition in which two or more threads are permanently blocked, waiting for each other.",A condition in which a thread continuously attempts an action that fails.,"A situation where a thread holds a resource indefinitely, preventing others from acquiring it.","A state where multiple threads try to access a shared resource simultaneously, leading to incorrect data.","A scenario where a thread is repeatedly preempted by the scheduler, preventing it from making progress.",B,The glossary defines 'livelock' as 'A condition in which a thread continuously attempts an action that fails'.
