Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
Under what circumstances does deadlock occur?,If any one of the four necessary conditions holds.,Only if the mutual exclusion and no preemption conditions hold.,If all four necessary conditions hold simultaneously.,When a thread requests resources in increasing order of enumeration.,If resources are allocated but remain unused for long periods.,C,The text states: 'Deadlock occurs if all four necessary conditions hold.'
What is the primary goal of deadlock prevention?,To detect deadlocks quickly and recover from them.,To ensure that at least one of the necessary conditions for deadlock cannot hold.,To allow threads to request resources only when they are holding none.,To predefine a safe sequence for resource allocation.,To maximize resource utilization and prevent starvation.,B,The text states: 'Prevent deadlock by ensuring at least one condition cannot hold.' The glossary also defines 'deadlock prevention' as 'A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.'
"Which type of resource, due to its nature, cannot be involved in a deadlock because it does not require mutual exclusion?",Mutex locks,Semaphores,CPU registers,Read-only files,Database transactions,D,"The text states: 'Sharable resources (e.g., read-only files) do not require mutual exclusion, thus cannot be involved in deadlock.'"
Why is denying the mutual-exclusion condition generally not a viable strategy for preventing deadlocks?,It leads to low resource utilization.,It causes threads to wait indefinitely for popular resources.,"Some resources are intrinsically nonsharable, like mutex locks.","It only prevents circular wait, not other conditions.",It requires threads to release all current resources before requesting more.,C,"The text states: 'Cannot generally prevent deadlocks by denying mutual-exclusion, as some resources are intrinsically nonsharable (e.g., mutex locks).'"
What is Protocol 1 for preventing the 'hold and wait' condition?,Threads must release all current resources before requesting more.,Threads must request and allocate all resources before execution begins.,Threads' currently held resources are preempted if a new request must wait.,Threads are required to request resources in an increasing order of enumeration.,The operating system denies requests if they lead to an unsafe state.,B,The text describes Protocol 1 for hold-and-wait prevention as: 'Thread requests/allocates all resources before execution.'
Which of the following describes Protocol 2 for preventing the 'hold and wait' condition?,A thread acquires all necessary resources in a single atomic operation.,A thread may request resources only when it is not holding any other resources.,"If a thread cannot get a requested resource, it releases all held resources and tries again.",Resources are preempted from a waiting thread and allocated to a requesting thread.,Resources are allocated based on a predefined hierarchical ordering.,B,The text describes Protocol 2 for hold-and-wait prevention as: 'Thread requests resources only when holding none. Must release all current resources before requesting more.'
What is a common disadvantage of both protocols designed to prevent the 'hold and wait' condition?,Increased system overhead due to frequent preemption.,High resource utilization as resources are quickly released.,"Low resource utilization, as resources may be allocated but unused for long periods.",Inability to apply to sharable resources.,Complexity in imposing a total ordering of resource types.,C,The text lists 'Low resource utilization: resources allocated but unused for long periods' as a disadvantage of both hold-and-wait protocols.
Another disadvantage common to both 'hold and wait' prevention protocols is:,They require mutual exclusion to be denied.,They are impractical for static resource allocation.,They lead to an increase in deadlocks.,"Starvation is possible, where a thread waits indefinitely for popular resources.",They are only applicable to mutex locks and semaphores.,D,The text lists 'Starvation possible: thread waits indefinitely for popular resources' as a disadvantage of both hold-and-wait protocols.
"In one protocol to prevent 'no preemption', what happens if a thread requests a resource and must wait?",The thread's request is immediately denied to prevent deadlock.,All resources currently held by that thread are preempted (implicitly released).,The thread is put into a queue and waits for all its requested resources to become available without releasing any current ones.,The operating system checks if other threads can release resources to satisfy the request.,The thread is immediately terminated to free up resources.,B,"Protocol 1 for no-preemption states: 'If thread requests resource and must wait, all currently held resources are preempted (implicitly released).'"
Which type of resources are often suitable for implementing deadlock prevention protocols based on 'no preemption'?,Mutex locks and semaphores,"Resources whose state cannot be saved or restored, like printers.","Resources whose state can be saved and restored, such as CPU registers or database transactions.",Sharable resources like read-only files.,Network connections that are continuously in use.,C,"The text states that no-preemption protocols are 'Often applied to resources whose state can be saved/restored (e.g., CPU registers, database transactions).'"
Deadlock prevention protocols based on 'no preemption' generally cannot be applied to which of the following?,CPU registers,Database transactions,Memory pages,Mutex locks and semaphores,Files that support exclusive write access,D,The text states: 'Cannot generally apply to mutex locks and semaphores (where deadlocks commonly occur).'
What is the practical solution mentioned for preventing the 'circular wait' condition?,Ensuring all resources are requested before execution.,Preempting resources from threads that are waiting.,Imposing a total ordering of all resource types.,Denying mutual exclusion for all resources.,Ensuring that no thread holds resources while waiting for another.,C,The text states: 'Practical solution: impose total ordering of all resource types.'
"When preventing 'circular wait' by imposing a total ordering of resource types, what rule must threads follow when requesting resources?",Threads must request resources in decreasing order of enumeration.,"Threads can request resources in any order, but must release them in increasing order.",Threads must request resources in increasing order of enumeration.,Threads must request all resources of the same type in separate requests.,Threads are only allowed to request resources they do not currently hold.,C,The text states: 'Require threads to request resources in increasing order of enumeration.'
"According to the total ordering protocol for circular wait prevention, what should a thread do if it needs multiple instances of the same resource type?",It must issue separate requests for each instance.,It must issue a single request for all instances needed.,It should only request one instance at a time to avoid complex ordering.,It must release all other resources before requesting multiple instances.,This scenario is not covered by the total ordering protocol.,B,"The text specifies: 'If multiple instances of same resource type needed, single request for all must be issued.'"
What is a known challenge in implementing the total ordering protocol for deadlock prevention?,The protocol does not guarantee deadlock prevention.,It often leads to high resource utilization.,It is difficult to apply to sharable resources.,Developing a consistent and effective ordering can be difficult for many locks.,"It requires threads to release all resources before requesting more, which is inefficient.",D,The text notes: 'Developing ordering can be difficult for many locks.'
Which Java mechanism is mentioned as being used for lock acquisition ordering in the context of preventing circular wait?,synchronized keyword,java.util.concurrent.locks.ReentrantLock,System.identityHashCode(Object),Object.wait() and Object.notify(),java.util.concurrent.Semaphore,C,The text states: 'Java uses `System.identityHashCode(Object)` for lock acquisition ordering.'
What is the definition of 'deadlock prevention' as provided in the glossary?,An operating system method where processes inform the OS of resources they will use during their lifetimes.,A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.,A technique to detect deadlocks as they occur and recover gracefully.,A strategy to minimize resource allocation overhead.,A method to prioritize resource requests to avoid starvation.,B,The glossary defines 'deadlock prevention' as 'A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.'
What is the definition of 'deadlock avoidance' as provided in the glossary?,A method to strictly enforce a total ordering of all resource types.,A technique where threads allocate all resources before execution begins.,An operating system method in which processes inform the operating system of which resources they will use during their lifetimes so the system can approve or deny requests to avoid deadlock.,A protocol that preempts resources from waiting threads to satisfy new requests.,A strategy to ensure that mutual exclusion never holds for any resource.,C,The glossary defines 'deadlock avoidance' as 'An operating system method in which processes inform the operating system of which resources they will use during their lifetimes so the system can approve or deny requests to avoid deadlock.'
"Which of the following is an alternative rule for preventing circular wait using total ordering, as mentioned in the text?",A thread requesting resource R_j must also request all R_i with F(R_i) < F(R_j).,A thread requesting R_j must have released any R_i such that F(R_i) >= F(R_j).,A thread requesting R_j must acquire R_j before any R_i where F(R_i) > F(R_j).,A thread requesting R_j must ensure F(R_j) is the highest function value among its held resources.,A thread must only request R_j if no other thread is holding any R_i.,B,"The text states: 'Alternatively, thread requesting R_j must have released any R_i such that F(R_i) >= F(R_j).'"
When does lock ordering NOT guarantee deadlock prevention?,When resources are requested in decreasing order of enumeration.,When multiple instances of the same resource type are needed.,"If locks are acquired dynamically (e.g., in a transaction function).",If the `System.identityHashCode(Object)` method is used for ordering.,When resource utilization is low.,C,"The text states: 'Lock ordering does not guarantee deadlock prevention if locks acquired dynamically (e.g., `transaction()` function example).'"
