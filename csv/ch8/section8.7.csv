Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
Under what circumstances is a deadlock detection algorithm typically employed in a system?,When the system uses aggressive deadlock prevention mechanisms.,When the system exclusively relies on deadlock avoidance strategies.,When the system does not implement deadlock-prevention or deadlock-avoidance techniques.,Only in real-time operating systems where deadlocks are strictly forbidden.,During system startup to identify potential resource conflicts.,C,"Deadlock detection algorithms are used in systems that do not employ deadlock-prevention or deadlock-avoidance, requiring an algorithm to determine if deadlock has occurred and another to recover from it."
What are the primary components involved when a system uses a deadlock detection approach?,A resource preemption mechanism and a rollback strategy.,An algorithm to detect deadlock and an algorithm to recover from it.,A method for safe sequence generation and a resource request denial mechanism.,A system for resource ordering and a method for breaking mutual exclusion.,A Banker's algorithm for resource allocation and a wait-for graph.,B,"If a system doesn't use deadlock-prevention or deadlock-avoidance, it needs both an algorithm to determine if a deadlock occurred and an algorithm to recover from it."
What is a significant overhead associated with deadlock detection and recovery?,Increased memory consumption for data structures.,Higher CPU utilization due to frequent context switching.,Run-time costs for detection and potential losses from recovery.,Complexity in implementing resource preemption.,The need for user intervention during recovery.,C,The text states that detection-and-recovery overhead includes run-time costs and potential losses from recovery.
Which graph is used for deadlock detection when there is a single instance of each resource type?,Resource-allocation graph.,Process-resource graph.,Wait-for graph.,Dependency graph.,Allocation matrix.,C,"For single instances of each resource type, the wait-for graph is used, which is a variant of the resource-allocation graph."
How is a wait-for graph obtained from a resource-allocation graph?,By adding resource nodes and new edges.,By removing resource nodes and collapsing edges.,By reversing all existing edges.,By adding a separate node for each available resource instance.,By only including threads that are currently holding resources.,B,A wait-for graph is obtained by removing resource nodes and collapsing edges from the resource-allocation graph.
"In a wait-for graph, what does an edge from thread $T_i$ to thread $T_j$ ($T_i 	o T_j$) signify?",$T_i$ has allocated a resource to $T_j$.,$T_j$ is waiting for a resource held by $T_i$.,$T_i$ is waiting for $T_j$ to release a resource $T_i$ needs.,$T_i$ and $T_j$ are in a safe state.,$T_j$ is a child process of $T_i$.,C,An edge $T_i 	o T_j$ in a wait-for graph implies thread $T_i$ is waiting for thread $T_j$ to release a resource $R_q$ that $T_i$ needs.
"When detecting deadlocks using a wait-for graph, what condition indicates the presence of a deadlock?",The graph is empty.,The graph contains a directed cycle.,All threads are connected to each other.,The graph is a tree structure.,There is a direct edge from every thread to itself.,B,Deadlock exists if the wait-for graph contains a cycle.
"What is the computational complexity of cycle detection in a wait-for graph, where $n$ is the number of vertices?",$O(n)$,$O(n \log n)$,$O(n^2)$,$O(n^3)$,$O(2^n)$,C,"Cycle detection in a wait-for graph has a complexity of $O(n^2)$ operations, where $n$ is the number of vertices."
Which tool from the BCC toolkit is mentioned for detecting deadlocks in Pthreads mutex locks on Linux?,`pthread_analyzer`,`mutex_monitor`,`deadlock_detector`,`resource_tracker`,`lock_debugger`,C,The `deadlock_detector` tool from the BCC toolkit is specifically mentioned for Pthreads mutex locks on Linux.
How does the `deadlock_detector` tool identify deadlocks?,By analyzing system call logs for mutex timeouts.,By simulating thread execution paths.,"By inserting probes to trace `pthread_mutex_lock()` and `pthread_mutex_unlock()` calls, constructing a wait-for graph, and detecting cycles.",By directly inspecting thread stack traces for blocked calls.,By monitoring CPU utilization patterns for anomalies.,C,"The `deadlock_detector` tool inserts probes to trace `pthread_mutex_lock()` and `pthread_mutex_unlock()`, constructs a wait-for graph, and reports deadlock if a cycle is detected."
"When a system has several instances of a resource type, why is the wait-for graph scheme not applicable for deadlock detection?",It becomes too complex to draw.,It only works for a single resource type.,The graph representation cannot effectively model multiple instances of a resource.,Resource nodes cannot be collapsed when multiple instances exist.,The cycle detection algorithm is not efficient for this scenario.,C,"The text states that the wait-for graph scheme is not applicable for several instances of a resource type, implying that its simplified representation is insufficient for the more complex resource allocation involving multiple instances."
"What are the three main data structures used in the deadlock detection algorithm for several instances of a resource type, similar to the Banker's algorithm?","Total, Max, Need.","Available, Allocation, Request.","Work, Finish, Safe.","Resources, Processes, States.","Graph, Cycle, Path.",B,"The algorithm uses `Available` (vector), `Allocation` (n x m matrix), and `Request` (n x m matrix)."
"In the deadlock detection algorithm for multiple resource instances, what does `Request[i][j] = k` signify?",Thread $T_i$ has $k$ instances of resource $R_j$ allocated.,Thread $T_i$ requests $k$ more instances of resource type $R_j$.,There are $k$ total instances of resource $R_j$ available.,Resource $R_j$ is needed by $k$ threads.,Thread $T_j$ requests $k$ instances of resource $R_i$.,B,`Request[i][j] = k` means thread $T_i$ requests $k$ more instances of resource type $R_j$.
What is the first step in the deadlock detection algorithm for several instances of a resource type?,Find an index $i$ such that `Finish[i] == false` and `Request_i <= Work`.,Update `Work` by adding `Allocation_i`.,Initialize `Work` = `Available` and `Finish` array based on `Allocation`.,Check if `Finish[i] == false` for any $i$.,Select a victim thread to terminate.,C,"Step 1 of the algorithm is to Initialize `Work` = `Available` and set `Finish[i]` to `false` if `Allocation_i` is not zero, or `true` otherwise."
"In the deadlock detection algorithm for multiple resource instances, if no index $i$ is found where `Finish[i] == false` and `Request_i <= Work`, what is the next action?",Assume the system is in a safe state.,Go back to Step 1 and reinitialize.,Proceed to the step that checks for deadlocked threads.,Grant the pending resource request to a thread.,Rollback the last transaction.,C,"If no such $i$ exists (in step 2), the algorithm proceeds to step 4, which is where it determines if any threads are deadlocked."
"According to the deadlock detection algorithm for multiple resource instances, how is a deadlocked thread identified?",A thread is deadlocked if its `Request` matrix is non-zero.,A thread is deadlocked if its `Allocation` is greater than `Available`.,A thread $T_i$ is deadlocked if `Finish[i] == false` after the algorithm completes.,A thread $T_i$ is deadlocked if it is found in a cycle in the wait-for graph.,A thread $T_i$ is deadlocked if its resources cannot be reclaimed by other threads.,C,"Step 4 states: 'If `Finish[i] == false` for some $i$, $0 \leq i < n$, then thread $T_i$ is deadlocked.'"
What is the computational complexity of the deadlock detection algorithm for several instances of a resource type?,$O(n+m)$,$O(n 	imes m)$,$O(m 	imes n^2)$,$O(n^2)$,$O(m^2 	imes n)$,C,The algorithm complexity is stated as $O(m 	imes n^2)$ operations.
What 'optimistic attitude' is assumed by the deadlock detection algorithm for multiple resource instances?,That all resource requests will eventually be granted.,"That if a thread's `Request` is less than or equal to `Work`, it will complete and return its resources.",That deadlocks are rare and can be ignored.,That all threads will eventually release their allocated resources.,That resources are infinite and always available.,B,"The algorithm assumes an optimistic attitude: if `Request_i <= Work`, it assumes $T_i$ will complete and return resources."
"Given the initial state in the example for multiple instances (5 threads, 3 resource types, specific allocations and requests), what sequence of threads leads to all `Finish[i]` being true, indicating no deadlock?","$<T_4, T_1, T_3, T_2, T_0>$","$<T_0, T_2, T_3, T_1, T_4>$","$<T_1, T_0, T_4, T_2, T_3>$","$<T_2, T_3, T_0, T_1, T_4>$","$<T_0, T_1, T_2, T_3, T_4>$",B,"The text explicitly states: 'Sequence $<T_0, T_2, T_3, T_1, T_4>$ results in Finish[i] == true for all i', indicating no initial deadlock."
"If thread $T_2$ requests 1 additional instance of resource C in the provided example, which threads become involved in the deadlock?","$T_0, T_1, T_2$","$T_1, T_2, T_3, T_4$","$T_0, T_3, T_4$","$T_0, T_1, T_2, T_3, T_4$",No deadlock occurs.,B,"The text states: 'New claim: system is deadlocked. Can reclaim $T_0$'s resources, but not enough for others. Deadlock involves $T_1, T_2, T_3, T_4$."
What two factors determine when a deadlock detection algorithm should be invoked?,System uptime and available memory.,The complexity of the algorithm and the number of resource types.,How often a deadlock is likely to occur and how many threads will be affected.,The current CPU utilization and disk I/O rate.,The size of the wait-for graph and the number of cycles detected previously.,C,The decision of when to invoke depends on 'How often is a deadlock likely to occur?' and 'How many threads will be affected by deadlock when it happens?'
What is a consequence of not frequently invoking a deadlock detection algorithm when deadlocks are likely to occur?,Increased system throughput.,Reduced computational overhead.,"Resources allocated to deadlocked threads become idle, and the number of threads in the deadlock cycle may grow.",Faster recovery times once a deadlock is eventually detected.,Improved responsiveness for non-deadlocked threads.,C,"If deadlocks are frequent and detection is not, 'Resources allocated to deadlocked threads become idle; number of threads in deadlock cycle may grow.'"
What is the main advantage of invoking a deadlock detection algorithm every time a resource request cannot be granted immediately?,It ensures the lowest possible computational overhead.,It allows for easier selection of a victim thread.,It identifies deadlocked threads and the specific thread that 'caused' the deadlock.,It guarantees that no deadlock will ever occur.,It is simpler to implement than periodic checks.,C,Invoking the algorithm every time a request cannot be granted 'Identifies deadlocked threads and the specific thread that 'caused' the deadlock.'
"What is a disadvantage of invoking a deadlock detection algorithm at defined intervals (e.g., hourly or when CPU utilization drops)?",It has very high computational overhead.,It might not identify the 'causing' thread.,It cannot detect deadlocks involving multiple resource types.,It requires manual intervention to start the detection process.,It prevents resources from becoming idle.,B,The text states that invoking at defined intervals 'May not identify the 'causing' thread.'
How do database systems typically manage deadlocks?,By preventing them entirely through careful transaction design.,By avoiding them using a strict ordering protocol.,By using deadlock detection and recovery mechanisms.,By preempting transactions that hold too many locks.,By limiting the number of concurrent transactions.,C,Database systems manage deadlock using detection and recovery.
"In database systems, what happens after a deadlock is detected?",All transactions involved in the deadlock are immediately terminated.,The system pauses until manual intervention resolves the deadlock.,"A victim transaction is selected, aborted, rolled back, and then reissued.",All locks held by deadlocked transactions are automatically released without rollback.,The database is put into a read-only state until the deadlock clears.,C,"When a deadlock is detected: a victim transaction is selected, aborted and rolled back (releasing its locks), remaining transactions are freed, and the aborted transaction is reissued."
"In the context of database deadlocks, what is a common criterion for selecting a victim transaction?",The transaction that has been running the longest.,The transaction that holds the most locks.,"The transaction that has modified the fewest rows (e.g., in MySQL).",The transaction with the highest priority.,The transaction that was started most recently.,C,"For victim choice, the text provides an example: 'e.g., MySQL minimizes rows inserted, updated, or deleted.'"
What is the definition of a 'wait-for graph' in the context of deadlock detection?,A graph showing which resources are currently available.,A graph illustrating the flow of data between threads.,"A variant of the resource-allocation graph with resource nodes removed, indicating a deadlock if it contains a cycle.","A graph used exclusively for deadlock avoidance, not detection.",A graph representing the historical usage of resources by threads.,C,"The glossary defines 'wait-for graph' as 'In deadlock detection, a variant of the resource-allocation graph with resource nodes removed; indicates a deadlock if the graph contains a cycle.'"
"What is a 'thread dump' and for what purpose is it useful, especially in Java?",A utility to delete inactive threads from memory.,A method to reorder thread execution for performance optimization.,"A snapshot of the state of all threads in an application, useful for debugging deadlocks.",A process of transferring threads between different CPU cores.,A tool for automatically resolving deadlocks without user intervention.,C,"The glossary defines 'thread dump' as 'In Java, a snapshot of the state of all threads in an application; a useful debugging tool for deadlocks.'"
