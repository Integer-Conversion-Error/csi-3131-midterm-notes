Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
How are pages typically allocated when a user-mode process requests memory?,From a dedicated user-mode heap.,Directly from physically contiguous memory.,From the kernel's free page frame list.,By allocating entire slabs from the kernel pool.,Via the buddy system allocator.,C,The text states that 'User-mode process requests memory -> pages allocated from kernel's free page frame list.'
"What is a common consequence of a user-mode process requesting a small amount of memory (e.g., a single byte) when pages are allocated from the kernel's free page frame list?",External fragmentation.,Memory thrashing.,Internal fragmentation.,Page fault.,Memory leak.,C,The text explains: 'Single byte request -> entire page frame granted -> internal fragmentation.'
How is the kernel's free page frame list primarily populated?,By kernel module insertions.,Through the process of booting the system.,By page-replacement algorithms.,By user-mode application memory releases.,By the system's power-of-2 allocator.,C,"The text specifies: 'List populated by page-replacement algorithms (e.g., Section 10.4).'"
Which characteristic describes the physical location of free pages available to user-mode processes?,They are always physically contiguous.,They are typically scattered throughout physical memory.,"They are reserved in a single, large block.",They are allocated in fixed-size segments only.,They are always located at the start of physical memory.,B,The text states: 'Free pages scattered throughout physical memory.'
Which of the following is a primary reason why kernel memory is often allocated from a different free-memory pool than user-mode memory?,To prevent user-mode processes from accessing kernel data.,"Kernel requests are always for very large, fixed-size blocks.","Kernel requests often involve varying data structure sizes, some less than a page.","User-mode processes require physically contiguous memory, unlike the kernel.",Kernel memory is volatile and frequently swapped out.,C,"One stated reason is: 'Kernel requests varying data structure sizes, some less than a page. Must use memory conservatively, minimize fragmentation waste.'"
What is a common practice in many operating systems regarding kernel code and data in relation to paging?,They are always subjected to aggressive paging.,They are typically not subjected to paging.,They are paged out only under extreme memory pressure.,They reside exclusively in swap space.,They are fragmented across many non-contiguous pages.,B,The text notes: 'Many OS do not subject kernel code/data to paging.'
"Why might kernel memory sometimes require physically contiguous pages, even though user-mode pages don't necessarily need them?",For improved cache performance.,To simplify virtual memory address translation for the kernel.,Because hardware devices often interact directly with physical memory without a virtual memory interface.,To ensure better security isolation between kernel modules.,To facilitate faster context switching between kernel threads.,C,The text states: 'Hardware devices interact directly with physical memory (no virtual memory interface). May require physically contiguous pages.'
Which two strategies are specifically mentioned for managing kernel free memory?,Paging and Segmentation.,First-fit and Best-fit.,Buddy system and Slab allocation.,Swapping and Demand Paging.,External fragmentation and Internal fragmentation.,C,"The text lists: 'Strategies for managing kernel free memory: ""buddy system"" and ""slab allocation"".'"
From what kind of memory segment does the buddy system primarily allocate memory?,Fixed-size segments of virtually contiguous pages.,Dynamically sized segments from a global heap.,Fixed-size segments of physically contiguous pages.,Variable-size pages from the user-mode pool.,Smallest available page frames from scattered physical memory.,C,The text states the buddy system 'Allocates memory from fixed-size segment of physically contiguous pages.'
What does a 'power-of-2 allocator' in the buddy system imply about how memory requests are satisfied?,Requests are always rounded down to the nearest power of 2.,Memory is allocated in units that are multiples of 2.,Requests are satisfied in units sized as a power of 2.,"The system can only allocate 2, 4, 8, 16, or 32 KB segments.",It uses a binary tree structure for allocation tracking.,C,The text and glossary define 'power-of-2 allocator' as satisfying 'requests in units sized as a power of 2.'
"If a memory request in a buddy system is not appropriately sized (e.g., 11 KB), how is it satisfied?",It is rejected due to invalid size.,It is rounded down to the next lowest power of 2.,It is satisfied with an exact match from a pre-allocated pool.,It is rounded up to the next highest power of 2.,It is split into multiple smaller requests.,D,The text states: 'Request not appropriately sized -> rounded up to next highest power of 2. Example: 11 KB request -> satisfied with 16-KB segment.'
What is the primary advantage of the coalescing technique in the buddy system?,It reduces external fragmentation by compacting memory.,It allows for quick combination of adjacent buddies to form larger segments.,It ensures that all allocated memory is physically contiguous.,It minimizes the overhead of tracking free memory blocks.,It pre-allocates memory to specific kernel data structures.,B,The text states: 'Advantage: quickly combine adjacent buddies to form larger segments using coalescing.'
What is a significant drawback of the buddy system related to memory utilization?,It suffers from severe external fragmentation.,It cannot allocate physically contiguous memory.,It causes internal fragmentation due to rounding up requests.,It has high overhead for memory allocation and deallocation.,It is only suitable for very small memory requests.,C,The text identifies 'rounding up to next highest power of 2 causes internal fragmentation' as a drawback.
"If a 33-KB memory request is made to a buddy system allocator, what size segment will typically be allocated, leading to internal fragmentation?",32 KB.,48 KB.,64 KB.,128 KB.,An exact 33 KB segment.,C,The text provides this specific example: 'Example: 33-KB request -> 64-KB segment allocated.'
"In the buddy system, what is the maximum percentage of an allocated unit that cannot be guaranteed to be *less* than wasted due to internal fragmentation?",10%,25%,50%,75%,100%,C,The text states: 'Cannot guarantee less than 50% of allocated unit wasted.'
"In the context of slab allocation, what is a 'slab'?",A single object that has been freed.,A temporary data copy used for performance.,One or more physically contiguous pages.,A queue of available kernel objects.,A block of memory of a power-of-2 size.,C,The text and glossary define a 'slab' as 'one or more physically contiguous pages.'
"According to the text, what does a 'cache' consist of within the slab allocation system?",A single kernel object.,One or more slabs.,A collection of diverse kernel data structures.,A power-of-2 sized memory segment.,A list of free page frames.,B,The text and glossary define a 'cache' as 'one or more slabs.'
For what purpose is a single cache typically created in slab allocation?,For all available free memory.,For each unique kernel data structure.,For user-mode process page tables.,For temporary file system buffers.,For physically contiguous memory blocks only.,B,"The text states: 'Single cache for each unique kernel data structure (e.g., process descriptors, file objects, semaphores).'"
What are caches in the slab allocation system populated with?,Empty memory pages.,Pointers to physically contiguous blocks.,"Objects, which are instantiations of kernel data structures.",Binary trees representing free memory.,Power-of-2 sized memory chunks.,C,The text states: 'Each cache populated with objects (instantiations of kernel data structure).'
"When a cache is created in the slab allocation algorithm, what is the initial state of the objects allocated to it?",All objects are marked `used`.,"Some objects are `used`, and some are `free`.",All objects are initially `free`.,Objects are only allocated upon request.,Objects are pending deletion.,C,The text states: 'Cache created -> objects (initially `free`) allocated to cache.'
"When a new object is needed in the slab allocation algorithm, how does the allocator fulfill the request?",By allocating a brand new page frame.,By creating a new slab and placing the object there.,By assigning any `free` object from the cache and marking it `used`.,By searching for a power-of-2 sized block.,By deallocating an existing `used` object.,C,The text explains: 'New object needed -> allocator assigns any `free` object from cache. Object marked `used`.'
"In Linux's slab states, what does it mean for a slab to be classified as 'Full'?",It has exhausted its contiguous physical memory.,All objects within that slab are marked `used`.,It contains both `used` and `free` objects.,It is awaiting new objects to be allocated.,Its cache is entirely full.,B,The text defines 'Full' as: 'All objects in slab `used`.'
What is the characteristic of a slab classified as 'Empty' in Linux's slab allocator?,It is ready to be deallocated.,All objects in the slab are marked `free`.,It has at least one `used` object.,It has been recently created but has no objects yet.,It has insufficient contiguous pages.,B,The text defines 'Empty' as: 'All objects in slab `free`.'
A slab is in the 'Partial' state in Linux when:,It has some free space but is mostly full.,It has not yet been assigned to a specific cache.,It has both `used` and `free` objects.,It contains only objects that are partially initialized.,It requires more physically contiguous pages.,C,The text defines 'Partial' as: 'Slab has both `used` and `free` objects.'
"When the slab allocator needs to satisfy a request, what is its first priority for obtaining a free object?",Allocating a new slab from contiguous physical pages.,Requesting memory from the buddy system.,Finding a free object in an empty slab.,Finding a free object in a partial slab.,Waiting for an object to be released and returned to the cache.,D,The text outlines the order: 'First: free object in a partial slab.'
"If the slab allocator cannot find a free object in a partial slab, what is its next step to satisfy a request?",It allocates a new slab.,It searches for an object in another cache.,It looks for a free object from an empty slab.,It triggers a page fault to get more memory.,It rounds up the request to the next power of 2.,C,The text outlines the order: 'If none [partial slab objects]: free object from an empty slab.'
Under what circumstances does the slab allocator allocate a new slab from contiguous physical pages to satisfy a request?,Whenever a `used` object is released.,Only for very large kernel data structures.,If there are no free objects in partial or empty slabs.,When the system is booting up.,When a cache becomes 'Full.',C,"The text outlines the order: 'If no empty slabs: new slab allocated from contiguous physical pages, assigned to cache; object memory allocated from new slab.'"
Which benefit is directly associated with the slab allocator's approach to memory management regarding fragmentation?,It eliminates external fragmentation by compacting memory.,It minimizes internal fragmentation by rounding up requests.,"No memory is wasted due to fragmentation, as exact amounts are returned.",It converts internal fragmentation into external fragmentation.,It uses a power-of-2 allocator to reduce fragmentation.,C,The text lists as a main benefit: 'No memory wasted due to fragmentation. ... Kernel requests memory -> exact amount returned.'
Another key benefit of the slab allocator is its ability to satisfy memory requests quickly. Why is this possible?,It relies on page replacement algorithms for fast page retrieval.,It combines adjacent free memory blocks instantly.,Objects are created in advance and readily available in caches.,It uses a smaller total memory footprint than other allocators.,It avoids interactions with hardware devices.,C,The text states: 'Memory requests satisfied quickly. ... Objects created in advance -> quickly allocated from cache.'
In which operating system kernel did the slab allocator first appear?,Linux 2.2+,Windows NT,Solaris 2.4,macOS (OS X),UNIX System V,C,The text states: 'First appeared in Solaris 2.4 kernel.'
For what specific type of systems is the SLOB allocator in Linux designed?,High-performance servers with ample memory.,"Systems with limited memory, such as embedded systems.",Multi-processor systems requiring per-CPU queues.,Systems primarily running user-mode applications.,Systems that use virtual memory extensively.,B,"The text states: 'SLOB allocator: for systems with limited memory (e.g., embedded systems).'"
Which of the following describes the memory lists maintained by the SLOB allocator for different object sizes?,"Small (<1 KB), Medium (<4 KB), Large (>4 KB).","Tiny (<128 bytes), Small (<512 bytes), Medium (<2 KB).","Small (<256 bytes), Medium (<1,024 bytes), Large (other objects < page size).","Blocks (fixed-size), Pages (variable-size), Slabs (contiguous).","Allocated, Free, Partial.",C,"The text specifies: 'Maintains three lists: `small` (<256 bytes), `medium` (<1,024 bytes), `large` (other objects < page size).'"
What allocation policy does the SLOB allocator use to fulfill requests from its internal lists?,Best-fit.,Worst-fit.,First-fit.,Next-fit.,Buddy system.,C,The text states: 'Allocates from appropriate list using first-fit policy.'
What is the current status of the SLUB allocator in the Linux kernel (Version 2.6.24+)?,It is an optional allocator for specific hardware.,"It is the default allocator, having replaced SLAB.",It is used only for very large memory allocations.,It is deprecated and no longer maintained.,It is primarily for user-mode memory management.,B,"The text states: 'SLUB allocator: default for Linux kernel (Version 2.6.24+), replaced SLAB.'"
One way SLUB reduced SLAB overhead was by storing metadata where?,With each object in the slab.,"In a separate, dedicated metadata cache.","In the `page` structure, not with each slab.",In per-CPU queues.,In the kernel's virtual address space.,C,The text states: 'Stores metadata in `page` structure (not with each slab).'
"Which significant memory saving feature does SLUB offer, particularly beneficial on multi-processor systems, compared to SLAB?",Reduced internal fragmentation for small objects.,Elimination of external fragmentation.,No per-CPU queues for objects.,Dynamic resizing of slabs.,Faster coalescing of freed memory.,C,The text states: 'No per-CPU queues for objects (significant memory saving on multi-processor systems).'
"How does the SLUB allocator generally perform, especially in systems with more processors, compared to SLAB?",It has slightly worse performance due to increased complexity.,It shows no significant difference in performance.,It provides better performance with more processors.,Its performance degrades with an increasing number of processors.,It is optimized for single-processor systems only.,C,The text states: 'Better performance with more processors.'
"In the context of the buddy system, what are 'buddies'?",Memory requests that are rounded up to the next power of 2.,Two adjacent memory segments of unequal size.,Pairs of equal size in buddy memory allocation.,Kernel objects stored in a cache.,Memory blocks that are permanently allocated.,C,The glossary defines 'buddies' as 'Pairs of equal size in buddy memory allocation.'
Which of the following best describes the process of 'coalescing' in memory management?,Breaking down a large memory segment into smaller power-of-2 units.,Satisfying a memory request by rounding it up to the next highest power of 2.,Combining freed memory in adjacent buddies into larger segments.,Allocating pre-initialized objects from a cache.,Moving active memory pages to secondary storage.,C,The glossary defines 'coalescing' as 'Combining freed memory in adjacent buddies into larger segments.'
What is the fundamental principle of 'slab allocation' as a memory management method?,Allocating memory in power-of-2 sized blocks only.,Splitting a slab into object-sized chunks to eliminate fragmentation.,Relocating non-contiguous memory blocks to form larger segments.,Always returning an entire page frame for any request size.,Using a first-fit policy for all memory requests.,B,"The glossary defines 'slab allocation' as a 'Memory allocation method; slab split into object-sized chunks, eliminating fragmentation.'"
"In the context of kernel memory allocation, what does 'object' refer to?",A physically contiguous block of memory.,A power-of-2 sized memory unit.,An instance of a class or data structure.,A freed memory segment in the buddy system.,A virtual memory page.,C,The glossary defines 'object' as an 'Instance of a class or data structure.'
The text mentions `struct task_struct` as an example. What kind of kernel object is `struct task_struct`?,A file object.,A semaphore.,A process descriptor.,A cache.,A slab.,C,"The text states: 'Scenario: kernel requests memory for process descriptor (struct task_struct, ~1.7 KB).'"
