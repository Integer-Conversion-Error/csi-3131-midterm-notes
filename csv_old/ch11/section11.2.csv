Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
What is a primary responsibility of the operating system concerning hardware?,To maximize hardware cost.,To minimize hardware usage.,To use hardware efficiently.,To replace hardware frequently.,To ignore hardware interactions.,C,The text states that an OS responsibility is to 'use hardware efficiently'.
Which two primary goals are pursued by the operating system for managing Hard Disk Drives (HDDs)?,Maximize access time and minimize data transfer bandwidth.,Minimize access time and minimize data transfer bandwidth.,Maximize data transfer bandwidth and maximize access time.,Minimize access time and maximize data transfer bandwidth.,Standardize drive interfaces and increase seek time.,D,"For HDDs, the OS aims to 'minimize access time, maximize data transfer bandwidth'."
What is 'seek time' in the context of HDD access time?,The time it takes for the platter to rotate to the desired sector.,The total time from the first request to the last transfer completion.,The time for the device arm to move heads to the desired cylinder.,The time required to read data from a sector.,The time spent waiting for an I/O request to be processed.,C,Seek time is defined as 'time for device arm to move heads to desired cylinder'.
What is 'rotational latency' in the context of HDD access time?,The time for the device arm to move heads to the desired cylinder.,The time taken for data to be transferred from the disk to memory.,The additional time for the platter to rotate the desired sector to the head.,The delay caused by disk scheduling algorithms.,The time it takes for the disk to spin up from a stopped state.,C,Rotational latency is defined as 'additional time for platter to rotate desired sector to head'.
What are the two main components that constitute access time for HDDs?,Read time and write time.,Seek time and transfer time.,Seek time and rotational latency.,Rotational latency and caching time.,Bandwidth and throughput.,C,Access time for HDDs is composed of 'seek time' and 'rotational latency'.
How is 'device bandwidth' defined in the context of HDD performance?,The number of I/O requests processed per second.,The maximum data transfer rate of the disk interface.,Total bytes transferred divided by total time (first request to last transfer completion).,The capacity of the storage device in bytes.,The time it takes to move the head from one end of the disk to the other.,C,Device bandwidth is defined as 'total bytes transferred / total time (first request to last transfer completion)'.
How can the OS improve HDD access time and bandwidth?,By increasing the disk's rotational speed.,By reducing the size of I/O requests.,By managing the order of storage I/O requests.,By adding more memory to the system.,By disabling disk caching.,C,The text states that 'Improve access time and bandwidth: manage order of storage I/O requests'.
What action does a process take when it needs I/O from a storage device?,It directly accesses the hardware.,It issues a system call to the OS.,It sends a signal to another process.,It waits for the device to become available.,It terminates itself.,B,"When a process needs I/O, it 'issues system call to OS'."
What information does an I/O request typically specify to the OS?,Only the memory address and amount of data.,Only the open file handle and input/output type.,"Input/output type, open file handle, memory address, and amount of data.",The physical sector number and track number.,The desired rotational speed and seek time.,C,"A request specifies: 'input/output, open file handle, memory address, amount of data'."
What happens to an I/O request if the drive or controller is immediately available?,It is placed in a queue for later processing.,It is immediately serviced.,It is rejected by the OS.,It is converted to a different format.,It triggers a system error.,B,If the 'Drive/controller available: request serviced immediately'.
Where are new I/O requests placed if the drive or controller is busy?,They are discarded.,They are sent to another drive.,They are placed in a queue.,They cause a system crash.,They are processed out of order.,C,If the 'Drive/controller busy: new requests placed in queue'.
"In a multiprogramming system, what is commonly found in the device queue?",Only completed requests.,Only system errors.,Pending requests.,Configuration settings.,Hardware drivers.,C,"In a multiprogramming system, the 'device queue often has pending requests'."
What is a key benefit of allowing device drivers to manage a queue of I/O requests?,It simplifies hardware design.,It completely eliminates all seek time.,"It allows drivers to improve performance via ordering, avoiding head seeks.",It ensures that all requests are processed simultaneously.,It transfers all scheduling responsibility to the user.,C,A 'Queue of requests: allows device drivers to improve performance via ordering (avoiding head seeks)'.
How did past HDD interfaces typically handle physical addressing for I/O requests?,They used Logical Block Addressing (LBA) internally.,The host specified track and head locations.,They relied solely on operating system scheduling.,They automatically mapped requests to optimal physical locations.,They exposed no controls to the host.,B,In 'Past HDD interfaces: host specified track/head; much effort on disk scheduling'.
How do modern drives typically handle the mapping of Logical Block Addresses (LBA) to physical addresses?,They expose physical controls directly to the host OS.,The host OS directly specifies track/head/sector.,They map LBA to physical addresses internally and do not expose controls.,"They use a fixed, unchangeable mapping from LBA to physical addresses.",They rely on the OS to perform all physical addressing calculations.,C,"Modern drives 'do not expose these controls, map LBA to physical addresses internally'."
Which of the following are current goals for disk scheduling?,"Maximizing seek time, minimizing bandwidth.","Fairness, timeliness, and optimizations like bunching sequential I/O.","Eliminating rotational latency, ignoring fairness.","Ensuring optimal ordering for all request types, regardless of computational cost.",Supporting only random I/O patterns.,B,"Current disk scheduling goals include 'fairness, timeliness, optimizations (e.g., bunching sequential reads/writes)'."
What type of I/O do drives typically perform best with?,Random I/O.,Sequential I/O.,"Small, fragmented I/O.",Concurrent I/O from many processes.,Write-heavy I/O.,B,"The text states, 'Drives perform best with sequential I/O'."
"Is it generally possible to have absolute knowledge of head, physical block, or cylinder locations on modern drives?","Yes, this information is fully exposed to the OS.","No, it is generally not possible.",Only for Solid State Drives (SSDs).,Only if the drive is directly connected via IDE.,"Yes, through advanced debugging tools.",B,Absolute knowledge of head/physical block/cylinder locations is 'generally not possible on modern drives'.
How do modern systems approximate physical proximity on HDDs using Logical Block Addresses (LBAs)?,They assume increasing LBAs always mean decreasing physical addresses.,"They assume that close LBAs equate to physical proximity, and increasing LBAs mean increasing physical addresses.",They randomly assign LBAs to physical addresses.,They do not use LBAs to infer physical proximity.,They require the user to provide physical mapping tables.,B,The approximation is that 'increasing LBAs mean increasing physical addresses; close LBAs equate to physical proximity'.
Which disk scheduling algorithm is described as the simplest?,SCAN.,C-SCAN.,"First-Come, First-Served (FCFS).",Shortest Seek Time First (SSTF).,Deadline scheduler.,C,"The text states that 'Simplest disk scheduling: First-Come, First-Served (FCFS) or FIFO'."
"What is a characteristic of the First-Come, First-Served (FCFS) disk scheduling algorithm in terms of fairness?",It is intrinsically unfair.,"It prioritizes short requests, leading to unfairness.",It ensures starvation for some requests.,It is intrinsically fair.,Fairness depends on the disk load.,D,FCFS is described as 'Intrinsically fair'.
"How does First-Come, First-Served (FCFS) generally perform regarding service speed?",It always provides the fastest service.,It generally does not provide the fastest service.,It provides the fastest service only for sequential requests.,Its speed is unpredictable.,It is only fast for very heavy disk loads.,B,FCFS 'Generally does not provide fastest service'.
"Given the FCFS example with requests for cylinders 98, 183, 37, 122, 14, 124, 65, 67 and an initial head position at 53, what is the total head movement?",300 cylinders.,450 cylinders.,640 cylinders.,720 cylinders.,510 cylinders.,C,The example explicitly states the 'Total head movement: 640 cylinders'.
What is the primary problem highlighted by the FCFS scheduling example (53 -> 98 -> 183 -> 37 -> ...)?,Requests are unfairly prioritized.,The head remains stationary for too long.,"It involves 'wild swings' of the disk head, leading to inefficient movement.",It fails to service any requests.,It only services requests moving in one direction.,C,"The problem is described as 'wild swing (e.g., 122 to 14 then back to 124)', indicating inefficient movement."
"Based on the FCFS example provided, what action would decrease head movement and improve performance?",Servicing requests for 122 and 124 before 37 and 14.,Servicing requests for 37 and 14 together (before/after 122/124).,Ignoring requests for cylinders greater than 100.,Increasing the initial head position.,Processing requests in reverse order.,B,"The text suggests that 'Servicing requests for 37 and 14 together (before/after 122/124) would decrease head movement, improve performance'."
How does the SCAN algorithm typically operate?,"It services requests in the order they arrive, regardless of cylinder location.","The disk arm starts at one end, moves to the other servicing requests, then reverses direction.",The disk arm always services the closest request next.,"It services requests only while moving in one direction, then immediately returns to the beginning.",It prioritizes read requests over write requests.,B,"The SCAN algorithm: 'disk arm starts at one end, moves to other, servicing requests. Reaches other end: direction reversed, servicing continues'."
What happens when the disk arm reaches one end of the disk in the SCAN algorithm?,It stops and waits for new requests.,It immediately returns to the beginning without servicing.,"Its direction is reversed, and servicing continues.",It switches to FCFS mode.,It jumps to the other end without moving through cylinders.,C,"In SCAN, when it 'Reaches other end: direction reversed, servicing continues'."
Which of the following is another common name for the SCAN algorithm?,FIFO algorithm.,Shortest Seek Time First (SSTF).,Elevator algorithm.,C-LOOK algorithm.,Deadline algorithm.,C,The SCAN algorithm is 'Also called elevator algorithm'.
"Given an initial head at 53 moving toward 0, and requests at 98, 183, 37, 122, 14, 124, 65, 67, what is the correct servicing order for the SCAN algorithm, starting from 53?",53 -> 65 -> 67 -> 98 -> 122 -> 124 -> 183 -> 14 -> 37 -> 0.,53 -> 37 -> 14 -> 0 -> 65 -> 67 -> 98 -> 122 -> 124 -> 183.,53 -> 98 -> 183 -> 37 -> 122 -> 14 -> 124 -> 65 -> 67.,53 -> 14 -> 37 -> 65 -> 67 -> 98 -> 122 -> 124 -> 183 -> 0.,53 -> 0 -> 14 -> 37 -> 65 -> 67 -> 98 -> 122 -> 124 -> 183.,B,The example states the SCAN servicing order for these parameters as: '53 -> 37 -> 14 -> 0 (reverse) -> 65 -> 67 -> 98 -> 122 -> 124 -> 183'.
"In the SCAN algorithm, how quickly are requests that are just in front of the disk head serviced?",They wait until the arm reaches the end and reverses.,They are serviced almost immediately.,They are only serviced after all requests behind the head are completed.,Their service time depends on the disk's rotational latency.,They are prioritized only if they are read requests.,B,A 'Request just in front of head: serviced almost immediately'.
"In the SCAN algorithm, how long might a request located just behind the disk head wait to be serviced?",It is serviced immediately.,"It waits until the arm moves to the end, reverses, and comes back.",It is serviced after all requests in front of the head are done.,It is never serviced if new requests keep arriving.,Its wait time is negligible.,B,"A 'Request just behind head: waits until arm moves to end, reverses, comes back'."
"After a reversal of direction in the SCAN algorithm, with a uniform distribution of requests, what is observed about the density of requests immediately in front of the head?",There is a heavy density of new requests.,There are many requests that waited the longest.,"There are few requests, as they were recently serviced.",The density remains uniform.,All requests are immediately serviced.,C,"With uniform distribution, there are 'few requests immediately in front of head after reversal (recently serviced)'."
"Where is the heaviest density of requests typically found in the SCAN algorithm, due to requests waiting the longest?",Immediately in front of the head.,At the beginning of the disk.,At the middle of the disk.,At the other end of the disk.,Uniformly distributed across the disk.,D,The 'Heaviest density of requests: at other end of disk (waited longest)'.
"What is Circular SCAN (C-SCAN) scheduling, and what is its primary goal?","It's a variant of FCFS, aiming for fastest service.","It's a variant of SCAN, designed for more uniform wait time.","It's an older algorithm, used only for magnetic tapes.","It's a method to prioritize write requests, ensuring minimal seek time.",It's an algorithm that services requests only while returning to the start.,B,C-SCAN is a 'variant of SCAN for more uniform wait time'.
What is a key difference in how C-SCAN handles reaching the end of the disk compared to SCAN?,C-SCAN reverses direction and services requests on the return trip.,C-SCAN stops at the end until new requests arrive.,C-SCAN immediately returns to the beginning of the disk without servicing requests on the return trip.,C-SCAN jumps to the middle of the disk.,C-SCAN switches to FCFS mode.,C,"C-SCAN 'Reaches other end: immediately returns to beginning of disk, no servicing on return trip'."
Does the C-SCAN algorithm service requests on its return trip from one end of the disk to the beginning?,"Yes, always.","No, it returns without servicing requests.",Only if there are urgent requests.,Only if the disk is idle.,It depends on the specific implementation.,B,"C-SCAN 'immediately returns to beginning of disk, no servicing on return trip'."
How does Circular SCAN (C-SCAN) conceptually treat the cylinders of the disk?,As a linear list where the head moves back and forth.,As a random access memory space.,"As a circular list, moving in one direction and wrapping around.",As an unordered collection of sectors.,As a stack where requests are popped off the top.,C,C-SCAN 'Essentially treats cylinders as circular list'.
"Given an initial head at 53, moving from 0 to 199, and requests at 98, 183, 37, 122, 14, 124, 65, 67, what is the next cylinder serviced after 183 in the C-SCAN algorithm?",37,14,"199 (return to 0, then 14)",67,98,C,"The example shows the C-SCAN servicing order: '53 -> 65 -> 67 -> 98 -> 122 -> 124 -> 183 -> 199 (return to 0) -> 14 -> 37'. So, after 183, the head moves to 199 (end), then 'returns to 0' and picks up 14 and 37."
Are many complex disk-scheduling algorithms commonly used in practice?,"Yes, they are all widely adopted.","No, many exist but are rarely used.",Only in highly specialized systems.,They are preferred over simpler algorithms in most scenarios.,Their usage depends on the disk type.,B,"The text states: 'Many disk-scheduling algorithms exist, rarely used'."
Is the computation of an optimal disk scheduling order always justified by the savings it provides?,"Yes, an optimal order always provides significant savings.","No, the computation may not justify savings over simpler algorithms like SCAN.",Only for very small request lists.,It depends on the type of disk being used.,Optimal order is impossible to define.,B,Optimal order: 'computation may not justify savings over SCAN'.
What factors heavily influence the performance of a disk scheduling algorithm?,The color of the disk drive.,The age of the operating system.,The number and types of requests.,The CPU speed only.,The amount of available RAM.,C,Performance depends heavily on 'number and types of requests'.
Under what specific condition will all disk scheduling algorithms behave like FCFS?,When the disk load is very heavy.,When the disk head is continuously moving.,When the queue has only one outstanding request.,When the system is CPU-bound.,When the operating system is Linux.,C,Example: 'queue with one outstanding request => all algorithms behave like FCFS'.
Which two disk scheduling algorithms are generally better for heavy disk loads and less likely to cause starvation?,FCFS and SSTF.,FCFS and C-SCAN.,SCAN and C-SCAN.,NOOP and CFQ.,Deadline and FCFS.,C,"SCAN and C-SCAN are 'better for heavy disk load, less likely to cause starvation'."
Why was the Linux 'deadline' scheduler created?,To be the simplest possible scheduler.,To ensure starvation for some processes.,Because starvation was still possible with SCAN/C-SCAN.,To only prioritize write requests.,To eliminate the need for queues.,C,Starvation 'still possible: Linux created deadline scheduler'.
What type of queues does the Linux 'deadline' scheduler maintain?,A single FCFS queue for all requests.,Separate read and write queues.,Queues based on process ID.,Only queues for kernel I/O.,"Two queues: one for LBA, one for FCFS, for both reads and writes combined.",B,The Deadline scheduler 'Maintains separate read and write queues'.
Why does the Linux 'deadline' scheduler give priority to read requests?,Reads are always faster than writes.,Processes are more likely to block on a read operation.,Write requests are less important.,It's a historical legacy from older systems.,To ensure fairness for all request types.,B,It 'Gives reads priority (processes more likely to block on read)'.
"How are the queues in the Linux 'deadline' scheduler primarily sorted, and what disk scheduling algorithm does this sorting implement?","By arrival time, implementing FCFS.","Randomly, implementing no specific algorithm.","In LBA order, implementing C-SCAN.","By request size, implementing SSTF.","By process priority, implementing a custom algorithm.",C,Queues are 'sorted in LBA order (implements C-SCAN)'.
How are I/O requests generally sent to the disk in the Linux 'deadline' scheduler?,"One by one, as they arrive.",In a continuous stream without any sorting.,Only when the queue is completely full.,"In a batch, sorted in LBA order.",In reverse LBA order.,D,All I/O requests are 'sent in batch in LBA order'.
How many queues does the Linux 'deadline' I/O scheduler maintain internally?,One.,"Two (one read, one write).","Three (real time, best effort, idle).","Four (two read, two write).",Five (one for each I/O type).,D,"It 'Keeps four queues: two read, two write (one sorted by LBA, other by FCFS)'."
How does the Linux 'deadline' scheduler prevent starvation for FCFS requests?,It periodically empties all FCFS queues.,It automatically converts FCFS requests to LBA-sorted requests.,"It checks if FCFS requests are older than a configured age (e.g., 500 ms) and prioritizes them.",It entirely ignores FCFS requests if LBA requests are present.,It uses a separate thread to handle only FCFS requests.,C,It 'Checks after each batch: FCFS requests older than configured age (default 500 ms)? If so: LBA queue (read/write) with old request selected for next batch'.
Which I/O scheduler was the default in Linux RedHat 7?,FCFS.,NOOP.,Completely Fair Queueing (CFQ).,Deadline I/O scheduler.,SCAN.,D,Deadline I/O scheduler was the 'default in Linux RedHat 7'.
For which type of systems and storage is the NOOP scheduler preferred in RHEL 7?,Disk-bound systems with traditional HDDs.,CPU-bound systems using fast storage (NVM devices).,Systems with very high rotational latency.,Systems prioritizing fairness above all else.,Mobile devices with limited battery life.,B,NOOP is 'preferred for CPU-bound systems using fast storage (NVM devices)'.
What was the default scheduler for SATA drives in RHEL 7?,Deadline.,NOOP.,Completely Fair Queueing (CFQ).,FCFS.,SCAN.,C,Completely Fair Queueing scheduler (CFQ) was the 'default for SATA drives' in RHEL 7.
What does CFQ stand for in the context of Linux I/O schedulers?,Continuous Fast Queueing.,Completely Fair Queueing.,Circular FIFO Queue.,Combined Flexible Queues.,Cylinder-First Queuing.,B,CFQ stands for 'Completely Fair Queueing scheduler'.
Which of the following queues are maintained by the Completely Fair Queueing (CFQ) scheduler?,Read and Write queues.,"Short, Medium, and Long queues.","Real time, best effort, and idle queues.","Priority 1, Priority 2, and Priority 3 queues.",Incoming and Outgoing queues.,C,"CFQ 'maintains three queues (insertion sort, LBA order): real time, best effort (default), idle'."
What is the default queue for requests in the Completely Fair Queueing (CFQ) scheduler?,Real time.,Idle.,Best effort.,FCFS.,LBA order.,C,"CFQ maintains 'real time, best effort (default), idle' queues, with best effort being the default."
What is the priority order among the queues maintained by the Completely Fair Queueing (CFQ) scheduler?,Idle > Best effort > Real time.,Best effort > Real time > Idle.,Real time > Best effort > Idle.,All queues have equal priority.,Priority is dynamic and changes based on disk load.,C,The priority is 'real time > best effort > idle'.
Is starvation possible with the Completely Fair Queueing (CFQ) scheduler?,"No, it's designed to be completely fair and prevent starvation.","Yes, starvation is possible.",Only for idle priority requests.,Only if the system is under extremely light load.,It's impossible to tell without more information.,B,The text states: 'starvation possible' for CFQ.
What does the CFQ scheduler use to anticipate if a process will issue more I/O requests soon?,Real-time clock data.,User-defined configuration files.,Historical data.,The current CPU temperature.,The total disk capacity.,C,CFQ 'Uses historical data: anticipates if process will issue more I/O requests soon'.
"If the CFQ scheduler anticipates that a process will issue more I/O requests soon, what action does it take?",It immediately switches to FCFS for that process.,"It idles, waiting for new I/O, and ignores other queued requests to minimize seek time.",It sends all other queued requests to a different disk.,It prioritizes read requests from all other processes.,It reduces the process's priority to prevent resource monopolization.,B,"If CFQ anticipates more I/O, it 'idles waiting for new I/O, ignores other queued requests (minimizes seek time, assumes locality of reference per process)'."
