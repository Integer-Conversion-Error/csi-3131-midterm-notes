Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
"In the context of transforming I/O requests to hardware operations, how does an application primarily refer to data?",By a unique hardware address.,By a process ID.,By a file name.,By a memory-mapped register.,By a device driver's internal ID.,C,"Applications typically refer to data using logical file names, which are then translated by the operating system."
What is the primary role of the file system in connecting application requests to hardware for disk operations?,To directly send commands to the disk controller.,To manage network protocols for data transfer.,To map a file name through directories to space allocation on the disk.,To handle interrupt requests from hardware devices.,To perform kernel recompilation for new devices.,C,The file system is responsible for translating the logical file name into physical disk locations (space allocation).
"How does MS-DOS, particularly for FAT file systems, map a file name to disk blocks?",The file name directly indicates the sector address.,"The file name is mapped to an inode number, which contains allocation info.","The first part of the file name identifies the hardware device, then a table indicates blocks.","The name maps to a number, which indicates an entry in a file-access table, telling which disk blocks are allocated.",It uses a mount table to associate the name with a device.,D,"In MS-DOS with FAT, the file name maps to a numerical entry in a file-access table, which then points to the allocated disk blocks."
"In UNIX-like systems, what is the primary mechanism by which a file name is mapped to space allocation information?",The file name is directly translated into a physical disk address.,"It maps to a device number, which then leads to a port address.","The file name maps to an inode number, and the inode contains space-allocation information.",A global directory table directly lists disk block addresses for each file.,It uses a colon separator in the file name to identify the device and then the blocks.,C,"UNIX systems map file names to inode numbers, and the inode itself stores the space allocation details for the file."
What is the ultimate goal of the complex translation process from an application's file name request?,To recompile the kernel for specific hardware.,To associate extra functionality like spooling.,To connect the file name to the disk controller via a hardware port address or memory-mapped registers.,To place the process onto a wait queue.,To identify the correct device driver based on a major device number.,C,All the mapping and lookup stages aim to translate the logical file name into the physical addresses that the hardware controller understands to perform I/O.
"How does MS-DOS identify the hardware device within a file name for I/O requests, such as 'C:drive'?",By the entire file name as a unique device identifier.,Through an inode number associated with the device.,"The first part of the file name, before the colon, identifies the hardware device.",It uses a mount table to look up the device name.,The device is identified by its major and minor device numbers embedded in the file name.,C,"In MS-DOS, the part of the file name before the colon (e.g., 'C:') is used to identify the hardware device."
"In MS-DOS, what is 'C:' typically mapped to for I/O operations?",A unique inode number.,A specific process ID.,A network path.,A specific port address via a device table.,The root directory of the file system.,D,MS-DOS maps device identifiers like 'C:' to a specific port address using a device table.
"Which operating system typically maintains a separate name space for hardware devices from its regular file-system name space, often indicated by a colon separator?",UNIX,Linux,macOS,Windows NT,MS-DOS,E,"MS-DOS uses a colon separator (e.g., 'C:') to clearly separate the device name space from the file-system name space."
What advantage is cited for MS-DOS's approach of having a separate device name space?,It allows for faster file access.,It simplifies kernel recompilation.,It makes it easy to associate extra functionality like spooling for printer files.,It enables dynamic loading of device drivers.,It inherently supports multiple stages of lookup tables.,C,"The text states that MS-DOS's separate device name space makes it easy to associate extra functionality, such as spooling for printer files."
How does UNIX integrate device names into its file system structure?,It uses a dedicated partition for all device files.,Device names are incorporated into the regular file-system name space.,Each device has a unique network address.,Devices are identified by their hardware interrupt lines.,Device names are managed by a separate hardware abstraction layer outside the file system.,B,"UNIX incorporates device names directly into its regular file-system name space, often as special files in directories like /dev."
What data structure does UNIX use to associate path name prefixes with specific device names for I/O resolution?,An inode table.,A file-access table.,A device-control register.,A mount table.,An interrupt-vector table.,D,"UNIX uses a mount table to associate path name prefixes with specific device names, which are also part of the file-system name space."
"When resolving a path name in UNIX to find a device, what is the lookup process in the mount table?",It directly searches for the exact device name.,It looks up the shortest matching prefix.,It looks up the longest matching prefix.,It searches for an inode number first.,It queries the network for available devices.,C,UNIX resolves path names by looking up the longest matching prefix in the mount table.
What information does a mount table entry typically provide in UNIX when resolving a device name?,The physical disk block addresses.,The inode number of the device.,The device name (also in file-system name space).,The memory address of the I/O buffer cache.,The CPU core assigned to the device.,C,"A mount table entry provides the device name, which is itself integrated into the file-system name space."
"When a device name is looked up in UNIX, what is typically found instead of an inode number?",A process ID.,A major and minor device number.,A port address.,A memory-mapped register address.,A network interface card (NIC) MAC address.,B,"Lookup of a device name in UNIX results in finding a <major, minor> device number pair, not an inode."
What is the primary purpose of the 'major device number' in UNIX?,To index into the device table for port addresses.,To identify the specific instance of a device.,To identify the device driver responsible for handling I/O.,To specify the size of the kernel buffer.,To indicate whether a device supports DMA.,C,The major device number is used to identify which device driver is responsible for managing I/O operations for that type of device.
What is the function of the 'minor device number' in UNIX?,"It identifies the type of device (e.g., disk, printer).",It is passed to the device driver to index into a device table for specific device instances.,It indicates the priority of I/O requests.,It determines the interrupt line for the device.,"It specifies the file system type (e.g., ext4, XFS).",B,"The minor device number is passed to the device driver, allowing it to differentiate between multiple instances of the same type of device by indexing into a device-specific table."
What information is provided by a device-table entry when performing I/O?,The file's creation date.,The CPU utilization of the device.,The port address or memory-mapped address of the device controller.,The current I/O queue length.,The type of file system used on the device.,C,The device-table entry ultimately provides the physical address (port or memory-mapped) used to communicate directly with the device controller.
Which characteristic applies to modern operating systems in terms of how they handle device naming and lookup?,They primarily rely on direct hardware addressing.,"They use a single, flat lookup table for all devices.",They feature multiple stages of lookup tables for flexibility.,They require kernel recompilation for every new device.,They hardcode device drivers into the kernel at compile time.,C,"Modern operating systems are designed with flexibility, often employing multiple stages of lookup tables to manage devices."
A key advantage of the general mechanisms for passing requests between applications and drivers in modern OS is:,Reduced memory footprint for drivers.,Elimination of the need for device controllers.,The ability to introduce new devices and drivers without kernel recompilation.,Simplification of the boot process.,Direct access to hardware from user space applications.,C,The general nature of these mechanisms means that new devices and their drivers can be integrated into the system without requiring the kernel to be recompiled.
How do some operating systems manage the loading of device drivers to enhance flexibility?,They require all drivers to be statically linked into the kernel at compile time.,They load device drivers only during the initial system installation.,They load device drivers on demand.,They store drivers exclusively in ROM.,They always require manual intervention to load drivers.,C,"To improve flexibility and resource utilization, some operating systems load device drivers only when they are needed (on demand)."
What happens regarding device drivers during system boot time in some operating systems?,All possible device drivers are loaded regardless of connected hardware.,"The system probes buses and loads necessary drivers, either immediately or on first request.",Drivers are only loaded after a user logs in.,The boot loader loads drivers directly from the network.,"Only essential CPU drivers are loaded, peripheral drivers are never loaded at boot.",B,"At boot time, the system typically probes the buses to detect connected hardware and loads the corresponding drivers, either immediately or when the device is first accessed."
"How does the kernel typically handle the loading of drivers for devices added to the system after boot time (e.g., hot-plugged devices)?",It ignores them until the next system reboot.,It requires manual loading by a system administrator.,"The device is detected by an error, then the kernel inspects and loads the driver dynamically.",It always requires kernel recompilation.,It sends a network request to download the driver.,C,"For devices added after boot, the system often detects them (sometimes initially by an error event), and the kernel then inspects the device and dynamically loads the appropriate driver."
What is a consequence of dynamic loading and unloading of device drivers?,It simplifies kernel algorithms.,It eliminates the need for interrupt handling.,"It introduces more complex kernel algorithms, device-structure locking, and error handling.",It makes the system less stable.,It removes the need for hardware-specific registers.,C,"While offering flexibility, dynamic loading and unloading of drivers add significant complexity to the kernel, requiring sophisticated algorithms for resource management, locking, and robust error handling."
What is the very first step a process takes when initiating a blocking read request for an opened file?,Allocating kernel buffer space.,Checking the buffer cache for data.,Issuing a `read()` system call to a file descriptor.,Being removed from the run queue.,Sending commands to the device controller.,C,The life cycle begins with the application process issuing a `read()` system call to request data from an opened file.
"During a blocking read request, what happens immediately if the requested data is found in the buffer cache?",The process is placed on a wait queue.,Physical I/O is performed.,"The data is returned to the process, and the I/O operation is completed without further steps.",The device driver is signaled.,An interrupt is generated by the DMA controller.,C,"If data is found in the buffer cache, it's a cache hit, and the data is immediately returned, completing the I/O without needing physical device access."
"If physical I/O is required for a blocking read request, what happens to the requesting process in the operating system?",It continues to execute on the run queue.,It is immediately terminated.,It is moved from the run queue and placed on a wait queue for the device.,It signals the device driver directly.,It allocates additional memory for the request.,C,"When physical I/O is necessary, the process cannot continue until the I/O is complete, so it is removed from the run queue and placed on a wait queue associated with the device."
How does the I/O subsystem send an I/O request to the device driver?,By directly writing to the device's hardware registers.,Through a network socket connection.,As a subroutine call or an in-kernel message.,By generating a hardware interrupt.,By modifying the process's page table entries.,C,The I/O subsystem typically communicates with the device driver using either a direct subroutine call within the kernel or by sending an in-kernel message.
What is a primary action taken by the device driver after receiving an I/O request from the kernel I/O subsystem?,It immediately unblocks the requesting process.,It allocates kernel buffer space and schedules the I/O.,It sends the data directly to the application's address space.,It waits for an interrupt before any further action.,It recompiles the kernel for the specific device.,B,"Upon receiving the request, the device driver's first tasks include allocating buffer space in the kernel and scheduling the actual I/O operation."
How does the device driver communicate commands to the device controller?,By sending messages over a network.,By shouting commands through the speaker.,By writing directly to device-control registers.,By issuing another system call.,By sending a signal to the kernel I/O subsystem.,C,Device drivers interact with hardware controllers by writing specific values to their memory-mapped or port-mapped control registers.
"After initiating a data transfer with the device controller, what are two common methods a device driver might employ to determine status or obtain data?",Sending data to the buffer cache or terminating the process.,Polling for status or setting up a DMA transfer.,Signaling the kernel I/O subsystem or modifying the file system.,Moving the process to the ready queue or the wait queue.,Checking inode numbers or accessing mount tables.,B,"Device drivers either continuously poll the device for status updates or configure a DMA transfer, which then generates an interrupt upon completion."
What component is responsible for generating an interrupt upon the completion of a DMA transfer?,The CPU.,The device driver.,The DMA controller.,The kernel I/O subsystem.,The application process.,C,"The Direct Memory Access (DMA) controller, once configured, handles the data transfer independently and signals its completion by generating an interrupt."
How does the operating system locate the correct interrupt handler after an interrupt is generated by a device?,By querying the device driver directly.,Through a binary search of all available handlers.,Via the interrupt-vector table.,By guessing based on the interrupt frequency.,The device sends the handler's address along with the interrupt.,C,The interrupt-vector table is a data structure that maps interrupt numbers to the addresses of their corresponding interrupt service routines (handlers).
"After the interrupt handler receives an interrupt and stores the data, what is its next action related to the I/O request life cycle?",It immediately transfers data to the process's address space.,It signals the device driver.,It moves the process from the wait queue to the ready queue.,It issues a new read system call.,It unblocks the process directly.,B,"Once the interrupt handler has dealt with the immediate hardware interaction (like storing data), it signals the device driver that the I/O completion event has occurred."
"Once the device driver determines the I/O request is completed and its status, whom does it signal?",The application process directly.,The CPU scheduler.,The kernel I/O subsystem.,Another device controller.,The boot loader.,C,The device driver reports the completion and status of the I/O operation back to the kernel I/O subsystem for further processing.
What two key actions does the kernel perform after receiving the I/O completion signal from the device driver?,It terminates the process and reboots the system.,It allocates more kernel buffer space and sends commands to the controller.,It transfers data/return codes to the requesting process's address space and moves the process from the wait queue to the ready queue.,It signals the interrupt handler and sets up DMA.,It issues a new system call and probes buses.,C,"Upon I/O completion notification, the kernel transfers the results to the application's memory and unblocks the process by moving it from the wait queue to the ready queue."
What is the immediate effect of moving a process from the wait queue to the ready queue following I/O completion?,The process immediately starts executing.,The process is terminated.,"It unblocks the process, making it eligible for CPU assignment by the scheduler.",It triggers another I/O request.,It deletes the associated file descriptor.,C,"Moving the process to the ready queue signifies that it is no longer waiting for I/O and can now compete for CPU time, effectively unblocking it."
"According to the glossary, what is a 'mount table'?",A physical table in the CPU for memory management.,"An in-memory data structure with information about each mounted volume, tracking file systems and access.",A database on disk storing all file names and their corresponding block addresses.,A hardware component that translates logical addresses to physical addresses.,A list of all device drivers loaded at boot time.,B,"The glossary defines a mount table as an 'In-memory data structure with info about each mounted volume, tracks file systems and access.'"
