Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
What is a characteristic feature of a multiprogramming environment as described in the system model?,Single thread execution is prioritized.,Resources are always infinite and readily available.,Multiple threads compete for finite resources.,Threads never enter a waiting state.,Only one process can run at a time.,C,The text states that in a 'Multiprogramming Environment: Multiple threads compete for finite resources'.
"According to the system model, what happens when a thread requests a resource that is currently unavailable?",The thread immediately crashes.,The resource is forcibly allocated to the thread.,The thread enters a waiting state.,The system reboots to free up resources.,The request is automatically canceled.,C,"The text explains, 'Resource Request: Threads request resources. If unavailable, thread enters a waiting state.'"
Which of the following best describes a 'deadlock' situation according to the introduction?,A thread successfully acquires all its requested resources.,A waiting thread changes state by acquiring new resources.,A situation where a waiting thread can never change state because its requested resources are held by other waiting threads.,A system crash due to immediate resource exhaustion.,Threads voluntarily release resources to prevent contention.,C,The text defines 'Deadlock' as 'A situation where a waiting thread can never change state because its requested resources are held by other waiting threads.'
What is the formal definition of a deadlock as provided in the introduction?,All processes are actively executing without any resource contention.,Every process in a set is waiting for an event that can only be caused by another process in the set.,Processes are waiting for external input from a user.,A single process holds all available resources.,Processes are competing for an infinite supply of resources.,B,The text provides the 'Formal Definition' of deadlock as 'Every process in a set is waiting for an event that can only be caused by another process in the set.'
How are resources characterized in the system composition section of the system model?,As infinite and unlimited entities.,As unlimited and unmanaged by the system.,As finite in number and distributed among competing threads.,"As always available to a single, dedicated thread.","As used exclusively by the operating system, not by threads.",C,The text describes 'System Composition' as 'Finite number of resources distributed among competing threads.'
What is true about instances within a specific resource type (or class) according to the system model?,Each instance is unique and serves a different purpose.,Instances are all identical and any instance of a resource type should satisfy a request.,"Instances must be acquired in a specific, predefined order.",Only one instance can exist for a given resource type.,Instances are managed independently of their resource type.,B,"The text states that resources are 'partitioned into types (classes), each with identical instances' and 'Any instance of a resource type should satisfy a request.'"
Which of the following are listed as examples of resource types in the system model?,User interfaces and network protocols.,Application programs and operating system kernels.,"CPU cycles, files, and I/O devices.",System logs and configuration files.,Memory addresses and disk partitions only.,C,"The text provides 'Examples: CPU cycles, files, I/O devices.'"
"If a system has 4 CPUs, how many instances would the resource type 'CPU' typically have according to the system model?",1 instance.,2 instances.,4 instances.,8 instances.,Infinite instances.,C,"The text explicitly states, 'If a system has 4 CPUs, resource type CPU has 4 instances.'"
What common synchronization tools are specifically mentioned as frequent sources of deadlock?,Timers and event handlers.,Mutex locks and semaphores.,Message queues and pipes.,Sockets and network connections.,Shared memory segments and file descriptors.,B,The text states under 'Synchronization Tools as Resources': 'Mutex locks and semaphores are common sources of deadlock.'
How are individual lock instances typically categorized within the system model's resource types?,They are all considered part of a single generic 'lock' resource type.,Each lock instance is typically its own distinct resource class.,Locks are not considered resources in this model.,They are grouped into resource types based on the data they protect.,"Locks are only managed by user applications, not the system.",B,"The text specifies, 'Each lock instance is typically its own resource class (e.g., one lock for a queue, another for a linked list).'"
What is the correct sequence of resource utilization by a thread as outlined in the system model?,"Use, Request, Release.","Release, Use, Request.","Request, Use, Release.","Acquire, Operate, Free.","Allocate, Consume, Discard.",C,"The 'Resource Utilization Sequence' is listed as: '1. Request, 2. Use, 3. Release.'"
"In the 'Request' phase of resource utilization, what happens if the requested resource is not immediately available?",The thread aborts its execution.,The thread proceeds without the resource.,The thread enters a waiting state.,The system grants a partial resource.,The resource is automatically destroyed.,C,"Under the 'Request' phase, the text says: 'Thread requests a resource. Waits if not immediately available.'"
"Which of the following are listed as ways a thread can initiate resource requests and releases, excluding synchronization operations?",Sending email notifications.,"System calls like `request()`, `release()`, `open()`, `close()`, `allocate()`, `free()`.",Hardware interrupts.,Direct memory access to resource tables.,Network packets to other systems.,B,"The text states, 'Request/release can be system calls (request(), release(), open(), close(), allocate(), free()).'"
"Besides system calls, what specific semaphore and mutex lock operations are mentioned for managing resource acquisition and release?",`print()` and `scan()`.,`start()` and `stop()`.,"`wait()` and `signal()` for semaphores, and `acquire()` and `release()` for mutex locks.",`read()` and `write()`.,`create()` and `destroy()`.,C,"The text lists 'semaphore operations (wait(), signal()) and mutex locks (acquire(), release()).'"
How does the operating system typically check for resource allocation?,By querying individual threads directly.,By consulting a network database.,Via a system table.,By random guesswork.,By physically inspecting hardware components.,C,"The text states, 'OS checks for resource allocation via a system table.'"
What information does the OS's system table track regarding resources?,User login times and system uptime.,Free/allocated resources and the owning thread.,Network bandwidth usage and data transfer rates.,Application error logs and debugger information.,CPU clock speed and temperature.,B,"The text specifies, 'Table tracks free/allocated resources and the owning thread.'"
"When resources are unavailable and threads enter a waiting state, where are these waiting threads typically placed?",They are terminated immediately by the OS.,They are sent to a separate server for processing.,They are queued for requested resources.,They are put into a dormant state indefinitely.,"They are given alternative, non-resource-dependent tasks.",C,"The text mentions, 'Waiting threads are queued for requested resources.'"
Which statement accurately defines a deadlocked state specifically concerning a set of threads?,Every thread in a set is actively executing without interruption.,Every thread in a set is waiting for an event that can only be caused by another thread in the set.,Threads are competing for an infinite number of resources.,A single thread holds all system resources.,Threads are synchronized to complete tasks simultaneously.,B,The text describes a 'Deadlocked State' as: 'Every thread in a set is waiting for an event that can only be caused by another thread in the set.'
"What are the primary events that threads typically wait for in a deadlocked state, as highlighted in the text?",User input and output operations.,Network communication and data transfer.,Resource acquisition and release.,System reboots and shutdown commands.,Code compilation and debugging processes.,C,The text identifies the 'Main events' for which threads wait in a deadlocked state as 'resource acquisition and release.'
"Which classic problem is given as an example to illustrate a deadlocked state, specifically involving a circular wait?",The Producer-Consumer Problem.,The Reader-Writer Problem.,The Dining-Philosophers Problem.,The Sleeping Barber Problem.,The Bounded-Buffer Problem.,C,"The text explicitly mentions, 'Example: Dining-philosophers problem. Each philosopher holds one chopstick and waits for another, creating a circular wait.'"
What is a key responsibility highlighted for developers concerning deadlocks?,"To ignore deadlock possibilities, as they are handled by the OS.",To be aware of deadlock possibilities.,To ensure infinite resources are available to prevent deadlocks.,To write only single-threaded applications to avoid deadlocks entirely.,To rely solely on the operating system for automatic deadlock resolution.,B,The text states under 'Developer Responsibility': 'Must be aware of deadlock possibilities.'
"What is the relationship between locking tools, race conditions, and deadlocks as described for developers?",Locking tools prevent deadlocks and cause race conditions.,Locking tools prevent race conditions and automatically avoid deadlocks.,Locking tools prevent race conditions but require careful management of lock acquisition/release to avoid deadlocks.,Locking tools cause both race conditions and deadlocks.,Locking tools are irrelevant to race conditions or deadlocks.,C,"The text explains, 'Locking tools prevent race conditions but require careful management of lock acquisition/release to avoid deadlocks.'"
"According to the Section Glossary, what is the definition of 'deadlock'?",A state where processes are constantly running without interruption.,The state in which two processes or threads are stuck waiting for an event that can only be caused by one of the processes or threads.,A situation where resources are abundant and freely available to all processes.,A condition where processes communicate directly without shared resources.,The successful completion of all process tasks in parallel.,B,The 'Section glossary' defines 'deadlock' as 'The state in which two processes or threads are stuck waiting for an event that can only be caused by one of the processes or threads.'
What is the primary function of `pthread_mutex_init()` in Pthreads?,To acquire an existing mutex lock.,To release a held mutex lock.,To initialize a new mutex in an unlocked state.,To block a thread until a mutex becomes available.,To destroy a mutex that is no longer needed.,C,The text states that `pthread_mutex_init()` initializes an unlocked mutex.
What is the behavior of `pthread_mutex_lock()` when a thread attempts to acquire a mutex that is already held by another thread?,The function returns an error code immediately.,The calling thread proceeds without acquiring the lock.,The calling thread releases any locks it currently holds.,The calling thread blocks until the mutex lock is released.,The system automatically resolves the contention without blocking.,D,The text describes `pthread_mutex_lock()` as acquiring a lock and blocking if the lock is held.
Which Pthreads function is used to release a mutex lock?,`pthread_mutex_init()`,`pthread_mutex_lock()`,`pthread_mutex_release()`,`pthread_mutex_unlock()`,`pthread_mutex_destroy()`,D,The text explicitly states that `pthread_mutex_unlock()` releases a lock.
"In the described deadlock scenario, how many distinct mutex locks are created and utilized?",One,Two,Three,Four,Five,B,"The scenario details the creation of 'Two mutex locks: `first_mutex`, `second_mutex`'."
What is the specific locking order for `thread_one` in the Pthreads deadlock example?,`second_mutex` then `first_mutex`,`first_mutex` then `second_mutex`,Only `first_mutex`,No specific order is defined,The order is randomized,B,"The text states `thread_one` locks in order: (1) `first_mutex`, (2) `second_mutex`."
What is the specific locking order for `thread_two` in the Pthreads deadlock example?,`first_mutex` then `second_mutex`,`second_mutex` then `first_mutex`,Only `second_mutex`,No specific order is defined,The order is randomized,B,"The text states `thread_two` locks in order: (1) `second_mutex`, (2) `first_mutex`."
Which specific condition must be met for a deadlock to be possible in the given Pthreads example?,`thread_one` acquires `second_mutex` and `thread_two` acquires `first_mutex`.,Both `thread_one` and `thread_two` attempt to acquire the same mutex simultaneously.,`thread_one` acquires `first_mutex` and `thread_two` acquires `second_mutex`.,Both threads release all their acquired locks before attempting to acquire new ones.,Only one mutex is used across both threads.,C,"The text explains the deadlock is possible 'If `thread_one` acquires `first_mutex` and `thread_two` acquires `second_mutex`, both threads will block waiting for the other's lock.'"
What factor explicitly influences whether a deadlock occurs in the example scenario?,The total number of processes running on the system.,The amount of available system memory.,The CPU scheduler's behavior.,The version of the operating system.,The specific programming language used.,C,The text states that the 'Occurrence depends on the CPU scheduler'.
The intermittent nature of deadlocks has what primary consequence for software development?,It simplifies the compilation process of multithreaded applications.,It makes it easier to design scalable concurrent systems.,It makes identifying and testing for deadlocks difficult.,It guarantees that deadlocks will never occur in production environments.,It reduces the need for careful mutex management.,C,The text explains that the intermittent nature 'Makes identifying and testing for deadlocks difficult.'
"According to the provided text, what is the definition of livelock?",A condition where threads are completely idle and consuming no CPU time.,A state where a thread successfully completes its task but then immediately restarts it.,A condition in which a thread continuously attempts an action that fails.,A temporary pause in thread execution due to I/O operations.,A situation where a single thread monopolizes all available resources.,C,Both the main text and the glossary define livelock as 'A condition in which a thread continuously attempts an action that fails.'
How does livelock differ from deadlock in terms of thread state?,"In livelock, threads are blocked, while in deadlock, they are actively working.","In livelock, threads are not blocked, while in deadlock, threads are blocked.","Livelock only occurs in kernel mode, while deadlock occurs in user mode.","Deadlock is a temporary state, while livelock is permanent.",There is no difference; the terms are interchangeable.,B,"The text explicitly states livelock is 'Similar to deadlock, but threads are not blocked.'"
Which analogy is used to explain the concept of livelock?,A single-lane road with cars traveling in one direction.,"Two people trying to pass in a hallway, repeatedly moving into each other's way.",A group of people waiting in a line for a limited resource.,A marathon race where all runners are making progress.,A computer program successfully completing a complex calculation.,B,"The text provides the analogy: 'Two people trying to pass in a hallway, repeatedly moving into each other's way. They are active but make no progress.'"
What is the key characteristic of `pthread_mutex_trylock()` compared to `pthread_mutex_lock()`?,"`pthread_mutex_trylock()` initializes a mutex, while `pthread_mutex_lock()` acquires it.","`pthread_mutex_trylock()` acquires a lock and always blocks, while `pthread_mutex_lock()` does not block.","`pthread_mutex_trylock()` attempts to acquire a lock without blocking, while `pthread_mutex_lock()` blocks if the lock is held.","`pthread_mutex_trylock()` releases a mutex, while `pthread_mutex_lock()` acquires it.","`pthread_mutex_trylock()` is used for read-only access, while `pthread_mutex_lock()` is for write access.",C,The text defines `pthread_mutex_trylock()` as attempting 'to acquire a lock without blocking'.
"In the Pthreads livelock scenario involving `pthread_mutex_trylock()`, what is the outcome when threads fail to acquire the second mutex?",The threads immediately terminate.,The threads successfully complete their work due to retrying.,They release their currently held locks and repeat the attempt indefinitely.,"They block indefinitely, similar to a deadlock.",They exchange their held mutexes with each other.,C,"The text states: 'Both then call `trylock` on the other mutex, which fails. They release their locks and repeat indefinitely.'"
"What is a recommended strategy to avoid livelock, as mentioned in the text?","Always acquiring mutex locks in a predetermined, global order.",Implementing a fixed delay before retrying failed operations.,Having threads retry failing operations at random times.,Reducing the number of mutexes used in the application.,Increasing the CPU clock speed to speed up execution.,C,The text states livelock 'Can be avoided by having threads retry at random times.'
Which real-world example is provided to illustrate the concept of retrying operations at random times to avoid contention?,Database systems using two-phase locking.,Web servers distributing incoming requests among available instances.,Hosts involved in an Ethernet network collision backing off for a random period.,Operating system schedulers prioritizing tasks based on urgency.,Mail servers queuing emails for delivery.,C,The text uses the 'Ethernet Example: Hosts involved in a network collision backoff for a random period before retransmitting.'
How common is livelock compared to deadlock in concurrent application design?,Livelock is significantly more common than deadlock.,Livelock and deadlock occur with roughly equal frequency.,Livelock is less common than deadlock.,Livelock is a theoretical concept and rarely observed in practice.,Livelock has been completely eliminated in modern systems.,C,"The text states, 'Rarity: Less common than deadlock, but still a challenge in concurrent application design.'"
"In the `do_work_one` function of the deadlock example code, what is the order of mutex unlocking?",`first_mutex` then `second_mutex`,`second_mutex` then `first_mutex`,Only `first_mutex`,No mutexes are unlocked,The order is random,B,"The code shows `pthread_mutex_unlock(&second_mutex);` followed by `pthread_mutex_unlock(&first_mutex);`, which is the reverse of the locking order."
"In the `do_work_two` function of the deadlock example code, what is the order of mutex unlocking?",`second_mutex` then `first_mutex`,`first_mutex` then `second_mutex`,Only `second_mutex`,No mutexes are unlocked,The order is random,B,"The code shows `pthread_mutex_unlock(&first_mutex);` followed by `pthread_mutex_unlock(&second_mutex);`, which is the reverse of the locking order."
"In the livelock example code, specifically within the `do_work_one` function, what is the purpose of the `if (pthread_mutex_trylock(&second_mutex))` condition?",To check if `first_mutex` is currently available.,To attempt to acquire `second_mutex` and proceed only if successful without blocking.,To re-initialize `second_mutex` if it's in an invalid state.,To wait for `second_mutex` to become available indefinitely.,To signal to `thread_two` that `second_mutex` is needed.,B,The `pthread_mutex_trylock()` function attempts to acquire the lock without blocking. The `if` condition checks if this non-blocking attempt was successful.
"If `pthread_mutex_trylock(&second_mutex)` fails in the `do_work_one` function of the livelock example, what immediate action does `thread_one` take?",It attempts to acquire `second_mutex` using `pthread_mutex_lock()`.,It immediately exits the loop and the function.,"It releases `first_mutex`, which it currently holds.",It waits for a random amount of time before retrying.,It signals `thread_two` to release `second_mutex`.,C,"The `else` block after `if (pthread_mutex_trylock(&second_mutex))` contains `pthread_mutex_unlock(&first_mutex);`, meaning it releases the lock it already holds if the `trylock` fails."
What does the term 'liveness failure' imply in the context of livelock?,The system has crashed and is no longer operational.,Threads are actively working but not making any meaningful progress towards completion.,"The application is performing operations too quickly, leading to instability.",All threads are completely stopped and consuming no CPU cycles.,The system is unable to initiate new processes.,B,Livelock is described as a 'Liveness Failure' where threads are 'active but make no progress'.
Which of the following conditions is NOT one of the four necessary conditions for a deadlock situation to arise?,Mutual exclusion,Hold and wait,No preemption,Resource sharing,Circular wait,D,"The four necessary conditions for deadlock are Mutual exclusion, Hold and wait, No preemption, and Circular wait. Resource sharing is the opposite of Mutual exclusion in this context, where resources are nonsharable."
"For a deadlock situation to occur, what is the critical requirement regarding the four necessary conditions?",At least two conditions must hold simultaneously.,Only the Circular wait condition is strictly necessary.,All four conditions must hold simultaneously.,The conditions must occur sequentially.,Any one of the four conditions is sufficient for a deadlock.,C,The text states: 'All four conditions must hold simultaneously in a system' for a deadlock situation to arise.
"In the context of deadlock characterization, what does the 'Mutual exclusion' condition imply about resources?",All resources must be sharable among threads.,"Resources can be shared, but only one thread can access them at a time.",At least one resource must be held in a nonsharable mode.,Resources can be preempted from threads.,Resources must be released voluntarily by threads.,C,The definition of Mutual exclusion is: 'At least one resource must be held in a nonsharable mode.'
"If all resources in a system are designed to be freely sharable among multiple threads, which necessary condition for deadlock is most likely violated?",Hold and wait,No preemption,Circular wait,Mutual exclusion,Resource allocation,D,"Mutual exclusion requires that 'at least one resource must be held in a nonsharable mode'. If all resources are freely sharable, this condition cannot be met."
Which statement accurately describes the 'Hold and wait' condition for a deadlock?,A thread releases all its resources before requesting new ones.,A thread is waiting for resources but holds none.,A thread must be holding at least one resource and waiting to acquire additional resources held by other threads.,A thread requests resources that are immediately available.,A thread holds resources indefinitely without releasing them.,C,The definition of Hold and wait is: 'A thread must be holding at least one resource and waiting to acquire additional resources held by other threads.'
"Consider a scenario where a thread, T1, currently holds Resource A and is requesting Resource B, which is held by Thread T2. This scenario directly illustrates which necessary condition for deadlock?",No preemption,Mutual exclusion,Circular wait,Hold and wait,Resource sharing,D,This scenario perfectly matches the definition of Hold and wait: 'A thread must be holding at least one resource (Resource A) and waiting to acquire additional resources (Resource B) held by other threads (T2).'
The 'No preemption' condition for deadlock specifies what about resource release?,Resources can be forcibly taken from a thread.,Resources are automatically released after a fixed time.,A resource can be released only voluntarily by the thread holding it.,Resources are released upon system shutdown.,Threads can only release all resources simultaneously.,C,No preemption states: 'A resource can be released only voluntarily by the thread holding it.'
"If an operating system allows resources to be forcibly taken away from a thread (e.g., CPU time slice), which deadlock condition is being violated?",Mutual exclusion,Hold and wait,No preemption,Circular wait,Resource availability,C,"No preemption explicitly states that 'A resource can be released only voluntarily by the thread holding it.' If resources can be forcibly taken, this condition is violated."
Which of the following describes the 'Circular wait' condition for deadlock?,A thread is waiting for any resource to become available.,"A set of waiting threads exists where each thread is waiting for a resource held by the next thread in the set, and the last thread is waiting for a resource held by the first.",All threads are waiting for the same resource simultaneously.,Threads release resources in a specific order to avoid cycles.,A thread is waiting for multiple instances of the same resource type.,B,"Circular wait is defined as: 'A set of waiting threads $\{T_0, T_1, \dots, T_n\}$ must exist such that $T_0$ is waiting for a resource held by $T_1$, $T_1$ is waiting for a resource held by $T_2$, \dots, $T_{n-1}$ is waiting for a resource held by $T_n$, and $T_n$ is waiting for a resource held by $T_0$.'"
The text states that 'The circular-wait condition implies the hold-and-wait condition'. What does this mean for deadlock prevention?,"If you prevent Hold and Wait, you automatically prevent Circular Wait.",Circular Wait is a weaker condition than Hold and Wait.,"If Circular Wait is present, Hold and Wait must also be present.",These two conditions are mutually exclusive.,Preventing Circular Wait has no impact on Hold and Wait.,C,"If A implies B, then whenever A is true, B must also be true. So, if Circular Wait exists (is true), then Hold and Wait must also exist (be true)."
What type of graph is used for a precise description of deadlocks?,Flow chart,Gantt chart,State transition graph,System resource-allocation graph,Dependency graph,D,The text explicitly states: 'Deadlocks can be described using a directed graph called a system resource-allocation graph.'
A system resource-allocation graph consists of which two main components?,Threads and processes,Vertices and edges,Resources and instances,Requests and assignments,Cycles and paths,B,The graph consists of 'a set of vertices V and a set of edges E'.
"In a system resource-allocation graph, what do the vertices partitioned as 'R' represent?",Active threads,Resource types,Request edges,Assignment edges,Deadlocked processes,B,"Vertices V are partitioned into two types: 'T = {...}, the set of all active threads.' and 'R = {...}, the set of all resource types.'"
"In a system resource-allocation graph, what does a directed edge from thread $T_i$ to resource type $R_j$ ($T_i 
ightarrow R_j$) signify?",An instance of $R_j$ has been allocated to $T_i$.,$T_i$ has released an instance of $R_j$.,$T_i$ has requested an instance of $R_j$.,$R_j$ is held exclusively by $T_i$.,$R_j$ is waiting for $T_i$.,C,"A directed edge from thread $T_i$ to resource type $R_j$ ($T_i 
ightarrow R_j$) is a request edge; 'it signifies that $T_i$ has requested an instance of $R_j$.'"
"What type of edge is represented by an arrow pointing from a resource type $R_j$ to a thread $T_i$ ($R_j 
ightarrow T_i$) in a system resource-allocation graph?",Request edge,Waiting edge,Assignment edge,Dependency edge,Cycle edge,C,"A directed edge from resource type $R_j$ to thread $T_i$ ($R_j 
ightarrow T_i$) is an assignment edge."
"If a system resource-allocation graph contains no cycles, what can be definitively concluded?",A deadlock situation is imminent.,All resources are sharable.,No thread is deadlocked.,All threads are waiting for resources.,The system is experiencing high contention.,C,"The text states: 'If the graph contains no cycles, no thread is deadlocked.'"
"When a system resource-allocation graph contains a cycle, what is the immediate implication?",A deadlock has definitely occurred.,No deadlock can occur.,A deadlock may exist.,All resources are free.,The system is perfectly balanced.,C,"The text states: 'If the graph contains a cycle, a deadlock may exist.' It's not a definite conclusion unless specific conditions about resource instances are met."
Under what specific condition does a cycle in a system resource-allocation graph definitively imply a deadlock has occurred?,If each resource type has several instances.,If no thread is waiting for a resource.,If each resource type has exactly one instance.,If all resources are currently available.,If only request edges form the cycle.,C,"The text specifies: 'If each resource type has exactly one instance, a cycle implies a deadlock has occurred.'"
"If a system resource-allocation graph has a cycle, and each resource type has several instances, what is the status of the cycle regarding deadlock?",The cycle guarantees a deadlock.,The cycle indicates no possibility of deadlock.,The cycle is a necessary but not a sufficient condition for deadlock.,The cycle is a sufficient but not a necessary condition for deadlock.,The cycle is irrelevant to deadlock detection.,C,"The text states: 'If each resource type has several instances, a cycle is a necessary but not a sufficient condition for deadlock.'"
"According to the glossary, what is the primary function of a 'system resource-allocation graph'?",To visualize thread execution paths.,To manage memory allocation.,To provide a precise description of deadlocks.,To track CPU utilization.,To optimize resource access times.,C,The glossary defines 'system resource-allocation graph' as 'A directed graph for precise description of deadlocks.'
What does a 'request edge' in a system resource-allocation graph indicate?,A resource has been assigned to a thread.,A resource is being released by a thread.,A thread is waiting for another thread.,An edge (arrow) indicating a resource request.,A deadlock has occurred.,D,"The glossary defines 'request edge' as 'In a system resource-allocation graph, an edge (arrow) indicating a resource request.'"
What does an 'assignment edge' in a system resource-allocation graph indicate?,A thread is requesting a resource.,A resource is available.,An edge (arrow) indicating a resource assignment.,A resource is in a waiting state.,A thread has completed its execution.,C,"The glossary defines 'assignment edge' as 'In a system resource-allocation graph, an edge (arrow) indicating a resource assignment.'"
Which of the following scenarios would directly prevent the 'Mutual exclusion' condition from contributing to a deadlock?,Threads are designed to release all held resources before requesting new ones.,All resources in the system are sharable and can be accessed concurrently by multiple threads.,The operating system forcibly preempts resources from threads that are holding them for too long.,Resource requests are granted only if they do not create a circular wait condition.,Threads only request resources when they know they can acquire them instantly.,B,"Mutual exclusion requires 'At least one resource must be held in a nonsharable mode.' If all resources are sharable, this condition cannot hold."
"To avoid the 'Hold and wait' condition, a system might implement a policy where:",Resources are never released voluntarily.,"All required resources must be requested and allocated at once, or not at all.","Resources are granted based on their type, not availability.",Threads can only hold one resource at a time.,Threads must wait for an indefinite period before requesting resources.,B,The 'Hold and wait' condition means a thread holds some resources while waiting for others. Requiring all resources to be requested and allocated at once ensures a thread doesn't hold some while waiting for others.
A system that allows the operating system to reclaim a resource from a thread before the thread voluntarily releases it is effectively addressing which deadlock condition?,Mutual exclusion,Hold and wait,No preemption,Circular wait,Resource scarcity,C,"The 'No preemption' condition states 'A resource can be released only voluntarily by the thread holding it.' If the OS can reclaim resources, preemption is allowed, thus violating 'No preemption'."
Which of the following best represents the partition of vertices 'T' in a system resource-allocation graph?,The set of all available resource instances.,The set of all blocked threads.,The set of all active threads.,The set of all system calls.,The set of all resource types.,C,"The text states: 'Vertices V are partitioned into two types: T = {$T_1, T_2, \dots, T_n$}, the set of all active threads.'"
"Consider a system where Thread A requests Resource X, which is held by Thread B. Thread B requests Resource Y, which is held by Thread C. Thread C requests Resource Z, which is held by Thread A. This specific pattern exemplifies which necessary condition for deadlock?",Mutual exclusion,Hold and wait,No preemption,Circular wait,Resource abundance,D,"This is a classic example of circular wait, where a set of threads ($T_A, T_B, T_C$) are waiting for resources held by each other in a cycle ($T_A 
ightarrow T_B 
ightarrow T_C 
ightarrow T_A$)."
Which of the following lists represents the three primary ways to deal with deadlocks as described in the text?,"Ignore, Isolate, Restore","Prevent, Detect, Resolve","Ignore problem, Prevent/Avoid, Detect/Recover","Monitor, Predict, Correct","Avoid, Mitigate, Reset",C,"The text explicitly states the three ways to deal with deadlock are 'Ignore problem', 'Prevent/Avoid', and 'Detect/Recover'."
Which operating systems are cited as examples of those that commonly employ the 'ignore problem' approach to deadlocks?,Unix and macOS,Windows and Android,Linux and Windows,iOS and Linux,macOS and Android,C,"The text mentions 'most OS, e.g., Linux, Windows' use the 'ignore problem' approach."
"According to the text, what is the main reason the 'ignore problem' solution is common for handling deadlocks?",It guarantees system stability and high performance.,It is the most robust and secure method available.,"Deadlocks occur infrequently, and other methods are costly.",It allows for immediate automatic recovery from any deadlock.,It is a proactive method that prevents deadlocks from forming.,C,The text states this solution is common 'due to infrequency of deadlocks and cost of other methods'.
What is the explicit goal of the 'Prevent/Avoid' method for handling deadlocks?,To minimize the time a system spends in a deadlocked state.,To ensure the system NEVER enters a deadlocked state.,To quickly detect and recover from deadlocks once they occur.,To allow deadlocks but provide a way for manual intervention.,To reallocate resources to break existing deadlocks.,B,The text states 'Prevent/Avoid: use protocol to ensure system NEVER enters deadlocked state'.
Which characteristic is typical of the 'Detect/Recover' approach to handling deadlocks?,It prevents deadlocks by constraining resource requests.,It relies on advance information about resource needs.,It allows the system to enter a deadlocked state before acting.,It is primarily used in general-purpose operating systems like Linux.,"It ignores the problem altogether, assuming deadlocks are rare.",C,"The text specifies that 'Detect/Recover' allows the system to enter a deadlocked state, then detect and recover."
In which type of system are 'Detect/Recover' methods for deadlocks explicitly mentioned as being used?,General-purpose operating systems like Linux,Embedded systems with limited resources,Database systems,Real-time operating systems,Gaming consoles,C,"The text states 'some systems, e.g., databases' use the Detect/Recover approach."
"For an optimal solution, the text suggests that basic deadlock handling approaches can be combined in what manner?",Eliminated in favor of a single universal method.,Applied only to critical system resources.,Per resource class.,Replaced by hardware-level deadlock prevention.,Ignored if system performance is satisfactory.,C,The text states 'Basic approaches can be combined for optimal solution per resource class'.
What is the defining characteristic of 'deadlock prevention' according to the text and glossary?,OS method where processes inform OS of resource use to approve/deny requests.,Methods to ensure at least one necessary condition for deadlock cannot hold.,Allowing the system to enter a deadlocked state and then recovering.,Ignoring the possibility of deadlocks due to their infrequency.,Detecting deadlocks by examining the system state periodically.,B,Both the Deadlock Prevention section and the glossary define it as 'Methods to ensure at least one necessary condition for deadlock cannot hold'.
Deadlock Prevention achieves its goal primarily by doing what?,Allowing threads to request resources freely and then checking for cycles.,By scheduling threads based on their estimated resource usage patterns.,By constraining resource request methods.,By periodically reallocating all system resources.,By rolling back transactions when a potential deadlock is detected.,C,The text states Deadlock Prevention 'Prevents deadlocks by constraining resource request methods'.
What information does the OS require in advance for Deadlock Avoidance to work effectively?,The current CPU utilization and memory availability.,Advance info on resources a thread will request/use.,The history of all past resource allocations.,User preferences for resource allocation policies.,The network traffic patterns of all active processes.,B,"The text explicitly states for Deadlock Avoidance, 'OS given advance info on resources a thread will request/use'."
"When implementing Deadlock Avoidance, which factors does the OS consider to decide whether to satisfy or delay a resource request?",Only the priority level of the requesting thread.,Only the total number of resources available in the system.,"Currently available resources, resources allocated to each thread, and future requests/releases of each thread.",The historical average of resource usage by similar threads.,User feedback and system administrator preferences.,C,"The text lists 'Currently available resources', 'Resources allocated to each thread', and 'Future requests/releases of each thread' as factors the OS considers."
"As defined in the section glossary, what is 'deadlock avoidance'?",A method where the OS ignores deadlocks due to their rarity.,OS method where processes inform OS of resource use; system approves/denies requests to avoid deadlock.,An approach that focuses on detecting deadlocks after they occur and then recovering.,A technique that ensures no single necessary condition for deadlock can hold.,A strategy that relies on manual restart to resolve deadlock situations.,B,The glossary defines 'deadlock avoidance' as 'OS method where processes inform OS of resource use; system approves/denies requests to avoid deadlock'.
Under what condition is the Deadlock Detection and Recovery approach typically used?,When system resources are unlimited.,Only in embedded systems.,If no prevention or avoidance methods are employed.,As the first line of defense against all types of system failures.,In real-time systems where any delay is unacceptable.,C,"The text states 'If no prevention/avoidance, deadlock may arise,' implying detection and recovery are used in such cases."
What are the two primary functionalities provided by algorithms in a system using Deadlock Detection and Recovery?,Prevent new requests and enforce resource order.,Examine system state to determine if deadlock occurred and recover from deadlock.,Predict future resource needs and delay requests.,Isolate affected threads and restart them individually.,Log all resource accesses and generate warning alerts.,B,The text states the system provides algorithms to 'Examine system state to determine if deadlock occurred' and 'Recover from deadlock'.
What happens if a deadlock remains undetected in a system?,The system automatically reboots and resolves the issue.,System performance improves due to fewer resource conflicts.,"System performance deteriorates, resources remain held, more threads deadlock, eventually requiring a manual restart.",The operating system automatically adjusts resource allocation to break the deadlock.,"A temporary pause in operations occurs, followed by self-correction.",C,"The text states 'Undetected deadlock: system performance deteriorates, resources held, more threads deadlock. Eventually, manual restart needed'."
"For what other type of failure might manual recovery, similar to that for deadlocks, be used?",Hardware failures.,Software bugs causing crashes.,"Liveness failures (e.g., livelock).",Memory leaks.,Network connectivity issues.,C,"The text mentions 'Manual recovery for other liveness failures (e.g., livelock) may be used for deadlock recovery'."
"According to the provided text, when does a deadlock occur?",If at least one of the four necessary conditions holds.,If two or more necessary conditions hold simultaneously.,If all four necessary conditions hold.,Only when resources are preempted without notice.,Only when a circular wait condition is explicitly detected.,C,The text states: 'Deadlock occurs if all four necessary conditions hold.'
What is the primary objective of deadlock prevention methods?,To allow all four necessary conditions to hold but manage them effectively.,To ensure that at least one of the necessary conditions for deadlock cannot hold.,To detect deadlocks and recover from them efficiently.,To avoid deadlocks by dynamically analyzing resource requests.,To minimize the number of resources requested by threads.,B,The text states: 'Prevent deadlock by ensuring at least one condition cannot hold.' And the definition of 'deadlock prevention' is 'A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.'
Which condition is explicitly stated as 'must hold for deadlock'?,Hold and wait,No preemption,Circular wait,Mutual exclusion,Resource allocation,D,"Under the 'Mutual exclusion' section, the text says: 'Mutual-exclusion condition must hold for deadlock.'"
"Which type of resources, as described, do not require mutual exclusion and thus cannot be involved in a deadlock?",Nonsharable resources like mutex locks.,Intrinsically nonsharable resources.,Resources that can be preempted.,"Sharable resources (e.g., read-only files).",Resources allocated dynamically.,D,"The text states: 'Sharable resources (e.g., read-only files) do not require mutual exclusion, thus cannot be involved in deadlock.'"
Why is it generally impossible to prevent deadlocks by denying the mutual-exclusion condition?,Because mutual exclusion is only one of four conditions.,Because some resources are intrinsically nonsharable.,Because threads would never acquire resources.,Because it leads to higher resource utilization.,Because it increases the likelihood of starvation.,B,"The text states: 'Cannot generally prevent deadlocks by denying mutual-exclusion, as some resources are intrinsically nonsharable (e.g., mutex locks).'"
Which of the following describes Protocol 1 for preventing the 'hold and wait' condition?,A thread releases all current resources before requesting more.,A thread requests resources only when holding none.,A thread requests and allocates all resources before its execution begins.,A thread's held resources are preempted if it requests a resource and must wait.,Resources are requested in an increasing order of enumeration.,C,"Under 'Hold and wait', Protocol 1 is described as: 'Thread requests/allocates all resources before execution.'"
Which of the following describes Protocol 2 for preventing the 'hold and wait' condition?,A thread must request all resources at once at the start of execution.,"A thread requests resources only when holding none, and must release all current resources before requesting more.","If a thread requests a resource and must wait, all currently held resources are implicitly released.",Resources are granted based on a total ordering of resource types.,The operating system preempts resources from waiting threads and allocates them to requesting threads.,B,"Under 'Hold and wait', Protocol 2 is described as: 'Thread requests resources only when holding none. Must release all current resources before requesting more.'"
What are two significant disadvantages common to both 'hold and wait' prevention protocols?,Increased throughput and complex implementation.,Low resource utilization and potential for starvation.,High resource utilization and guaranteed fairness.,Reduced overhead and ease of debugging.,Guaranteed deadlock prevention and high concurrency.,B,The text lists two disadvantages for both protocols: 'Low resource utilization: resources allocated but unused for long periods.' and 'Starvation possible: thread waits indefinitely for popular resources.'
"In the context of 'no preemption' prevention, what happens in Protocol 1 if a thread requests a resource and must wait?","The thread's request is denied, and it tries again later.",All currently held resources by that thread are preempted (implicitly released).,"The thread is immediately granted the resource, overriding other processes.",The system checks if other threads can release their resources.,The thread is put into a queue and its resources remain held.,B,"Under 'No preemption', Protocol 1 states: 'If thread requests resource and must wait, all currently held resources are preempted (implicitly released).'"
"According to Protocol 1 for 'no preemption' prevention, when does a thread restart after its resources have been preempted?",Immediately after preemption.,When only the new requested resources are available.,When all other threads have finished their execution.,When its old and new resources are both available.,Only if the user manually restarts the process.,D,Protocol 1 for 'no preemption' states: 'Thread restarts when old and new resources are available.'
Which types of resources are often suitable for 'no preemption' prevention methods?,Mutex locks and semaphores.,Resources whose state cannot be saved or restored.,CPU registers and database transactions.,Sharable resources like read-only files.,Printers and other physical peripherals.,C,"The text states: 'Often applied to resources whose state can be saved/restored (e.g., CPU registers, database transactions).'"
Which types of resources are generally NOT suitable for 'no preemption' prevention methods?,CPU registers.,Database transactions.,Resources whose state can be saved/restored.,Mutex locks and semaphores.,Sharable read-only files.,D,The text states: 'Cannot generally apply to mutex locks and semaphores (where deadlocks commonly occur).'
What is the practical solution mentioned for preventing the 'circular wait' condition?,Ensuring all resources are requested at once.,Implementing preemption for all resource types.,Imposing a total ordering of all resource types.,Denying mutual exclusion for all resources.,Allowing threads to wait indefinitely for popular resources.,C,"Under 'Circular wait', the text says: 'Practical solution: impose total ordering of all resource types.'"
"When preventing 'circular wait' by imposing a total ordering, how are threads required to request resources?",In decreasing order of enumeration.,"In any random order, as long as all are requested at once.",In increasing order of enumeration.,Only one resource at a time.,"Based on their availability, regardless of order.",C,The text states: 'Require threads to request resources in increasing order of enumeration.'
"Consider a resource ordering where F(first_mutex) = 1 and F(second_mutex) = 5. According to the circular wait prevention protocol, in what order must a thread request these resources?",second_mutex then first_mutex.,first_mutex then second_mutex.,The order does not matter.,Both must be requested simultaneously.,Only one of them can be requested per thread.,B,"The text states: 'Example: F(first_mutex) = 1, F(second_mutex) = 5. Thread must request first_mutex then second_mutex.', which follows the rule of 'increasing order of enumeration'."
"In the circular wait prevention protocol using total ordering, if a thread needs multiple instances of the same resource type, what is required?",It must request them one by one.,It must make a single request for all instances at once.,It can request them in any order.,It must release all other resources first.,It must wait for other threads to finish using them.,B,"The text states: 'If multiple instances of same resource type needed, single request for all must be issued.'"
How does the text claim the total ordering protocol prevents circular wait?,By direct proof.,By induction.,By contradiction.,It does not guarantee prevention.,By empirical observation.,C,The text explicitly states: 'This protocol prevents circular wait (proof by contradiction).'
Which Java method is mentioned in the text as being used for lock acquisition ordering?,`System.getLockOrder()`,`System.identityHashCode(Object)`,`Object.getLockID()`,`Thread.getCurrentLock()`,`Lock.acquireOrder()`,B,The text states: 'Java uses `System.identityHashCode(Object)` for lock acquisition ordering.'
"Under what circumstance does lock ordering NOT guarantee deadlock prevention, according to the text?",If resources are sharable.,If locks are acquired dynamically.,If multiple instances of a resource type are needed.,If resource utilization is low.,If threads experience starvation.,B,"The text states: 'Lock ordering does not guarantee deadlock prevention if locks acquired dynamically (e.g., `transaction()` function example).'"
What is the definition of 'deadlock prevention' as provided in the section glossary?,An operating system method where processes inform the OS of resource use to approve/deny requests.,A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.,The process of detecting a deadlock after it has occurred and recovering from it.,Techniques for minimizing resource allocation overhead.,A protocol that prioritizes certain threads to avoid indefinite waiting.,B,The glossary defines 'deadlock prevention' as: 'A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.'
How is 'deadlock avoidance' defined in the provided glossary?,A method to preempt resources from waiting threads.,A protocol requiring threads to request all resources before execution.,An operating system method in which processes inform the operating system of which resources they will use during their lifetimes so the system can approve or deny requests to avoid deadlock.,A technique that imposes a total ordering of all resource types to prevent circular wait.,A strategy that aims to deny mutual exclusion for all sharable resources.,C,The glossary defines 'deadlock avoidance' as: 'An operating system method in which processes inform the operating system of which resources they will use during their lifetimes so the system can approve or deny requests to avoid deadlock.'
What aspect of system operation does deadlock-prevention primarily limit?,The total number of resources in the system.,How resource requests are made.,The number of concurrent threads.,The speed of resource allocation.,The amount of memory available to each thread.,B,Deadlock-prevention specifically limits how requests are made to ensure no necessary condition for deadlock occurs.
Deadlock-prevention ensures that which of the following does not occur?,High device utilization.,Increased system throughput.,Any necessary condition for deadlock.,A safe state.,Dynamic resource allocation.,C,The primary goal of deadlock-prevention is to ensure that no necessary condition for deadlock occurs.
Which of the following is a common side effect of employing deadlock-prevention strategies?,Increased system throughput.,Enhanced device utilization.,Reduced system overhead.,Low device utilization.,Faster resource acquisition.,D,Deadlock-prevention can lead to low device utilization and reduced system throughput as stated in the text.
What alternative approach to deadlock-prevention requires additional information on resource requests?,Deadlock detection.,Deadlock recovery.,Deadlock avoidance.,Resource preemption.,Priority scheduling.,C,The text states that deadlock avoidance is an alternative that requires additional information on resource requests.
What type of information must the system know a priori for deadlock avoidance algorithms to function?,The current state of all CPU registers.,The maximum resources each thread may need.,The exact sequence of future resource requests.,The current available memory.,The processing speed of each thread.,B,Deadlock avoidance requires knowing the maximum resources each thread may need beforehand (a priori information).
How does a deadlock-avoidance algorithm prevent the condition of circular-wait?,By pre-empting resources from threads.,By dynamically examining the resource-allocation state.,By ignoring all resource requests.,By ensuring mutual exclusion.,By breaking the no-preemption condition.,B,Deadlock-avoidance algorithms dynamically examine the resource-allocation state to prevent circular-wait.
The resource-allocation state is defined by which of the following?,The CPU utilization and I/O rates.,Only the maximum demands of threads.,"The available resources, allocated resources, and maximum demands.",The number of threads and processes currently running.,The history of all past resource requests.,C,"The resource-allocation state is defined by available resources, allocated resources, and maximum demands of threads."
A state is considered 'safe' if the system can achieve which of the following?,Allocate resources to no more than one thread at a time.,Pre-empt resources from any thread to avoid deadlock.,Allocate resources to each thread (up to its maximum) in some order and avoid deadlock.,Immediately detect and recover from any deadlock.,Ensure that no thread ever waits for a resource.,C,A safe state is defined as one where the system can allocate resources to each thread (up to its maximum) in some order and avoid deadlock.
"According to the text, under what condition is a system considered safe?",If no resources are currently allocated.,If all threads have completed execution.,If a safe sequence exists.,If the system is operating at maximum capacity.,If there are no waiting threads.,C,"The text states, 'System is safe if a safe sequence exists.'"
"In a safe sequence <T1, T2, ..., Tn>, what condition must be met for each thread Ti?",Ti must have all its resources allocated before any other thread.,Its resource requests can be met by currently available resources plus resources held by all Tj where j is less than i.,Ti must not make any further resource requests.,Ti must release all its resources before T(i+1) requests any.,Ti must never enter a waiting state.,B,"A safe sequence ensures that for each Ti, its requests can be met by available resources plus those held by preceding threads in the sequence."
"Which statement accurately describes the relationship between safe, deadlocked, and unsafe states?",All unsafe states are deadlocks.,A safe state is always deadlocked.,A deadlocked state is safe.,"A safe state is not deadlocked, and a deadlocked state is unsafe.",All unsafe states will inevitably lead to deadlock.,D,"The text explicitly states, 'Safe state is not deadlocked; deadlocked state is unsafe.' It also clarifies that not all unsafe states are deadlocks."
Which of the following is true regarding unsafe states and deadlocks?,Unsafe states always lead to deadlock.,"Not all unsafe states are deadlocks, but they may lead to deadlock.",A system in an unsafe state cannot ever reach a safe state again.,Deadlocks are a prerequisite for unsafe states.,An unsafe state implies the system is currently deadlocked.,B,"The text states, 'Not all unsafe states are deadlocks, but unsafe states may lead to deadlock.'"
How does the operating system (OS) generally behave regarding unsafe states?,The OS actively seeks out unsafe states to optimize resource use.,"The OS prevents deadlocks regardless of the state, even if unsafe.",The OS avoids unsafe states as long as the state is safe.,The OS forces threads into unsafe states to test resilience.,The OS has no control over unsafe states.,C,"The text indicates, 'OS avoids unsafe states as long as state is safe.'"
"When a system is in an unsafe state, who or what primarily controls whether deadlocks occur?",The operating system's deadlock prevention mechanisms.,The system administrator's manual interventions.,The behavior of the individual threads.,The amount of available memory.,The speed of the CPU.,C,"The text states, 'In unsafe state, OS cannot prevent deadlocks; thread behavior controls unsafe states.'"
The Resource-allocation-graph algorithm is applicable to systems with what characteristic?,Multiple instances of each resource type.,Only one instance of each resource type.,No resource preemption allowed.,An unlimited number of resources.,Only read-only resources.,B,The RAG algorithm is specifically 'For systems with only one instance of each resource type.'
"In a Resource-allocation graph, what does a dashed line from thread Ti to resource Rj represent?",Ti currently holds Rj.,Ti has requested Rj.,Rj is currently available.,Ti may request Rj in the future.,Rj is about to be released by Ti.,D,"A dashed line is a claim edge, indicating that Ti may request Rj in the future."
When does a claim edge (thread Ti to resource Rj) convert into a request edge in the Resource-allocation-graph algorithm?,When Rj is allocated to Ti.,When Rj is released by Ti.,When Ti requests Rj.,When Ti terminates.,When a cycle is detected in the graph.,C,A claim edge converts to a request edge 'when Ti requests Rj.'
Under what condition does a request edge (thread Ti to resource Rj) convert to an assignment edge (resource Rj to thread Ti)?,When Ti finishes its execution.,When Rj is pre-empted from Ti.,When Ti makes a new claim for Rj.,When Rj is allocated to Ti.,When Rj becomes available for the first time.,D,A request edge converts to an assignment edge 'when Rj allocated to Ti.'
"When an assignment edge (resource Rj to thread Ti) converts back to a claim edge (thread Ti to resource Rj) in the Resource-allocation-graph algorithm, what event has occurred?",Ti has made a new request for Rj.,Rj has been assigned to a different thread.,Ti has released Rj.,A deadlock has been detected.,Ti has cancelled its future claim for Rj.,C,An assignment edge converts to a claim edge 'when Rj released by Ti.'
How must resources be claimed by threads when using the Resource-allocation-graph algorithm?,Dynamically during execution.,Only after a deadlock is detected.,A priori (in advance).,Only if a cycle is formed.,Through negotiation with other threads.,C,"The text states, 'Resources must be claimed a priori.'"
"In the Resource-allocation-graph algorithm, a resource request is granted only if what condition is met?",The requested resource is immediately available.,No other thread currently holds the resource.,No cycle is formed in the graph after the hypothetical allocation.,The thread has the highest priority.,The system is in a deadlocked state.,C,A request is granted 'only if no cycle formed in graph' (checked by cycle-detection algorithm).
What does the formation of a cycle in a Resource-allocation graph indicate within the context of deadlock avoidance?,The system is in a safe state.,A resource has been released.,An unsafe state.,A request has been granted.,The system has recovered from a deadlock.,C,"The text states, 'Cycle indicates unsafe state.'"
"What is the time complexity of the Resource-allocation-graph algorithm, where 'n' is the number of threads?",O(n),O(n log n),O(n squared),O(m times n squared),O(2 to the power of n),C,"The algorithm complexity is given as 'O(n^2) operations, where n is number of threads.'"
For what type of systems is the Banker's algorithm primarily applicable?,Systems with only one instance of each resource type.,Systems with multiple instances of each resource type.,Systems that do not allow resource sharing.,Systems that require immediate deadlock detection.,Systems with a fixed number of threads.,B,The Banker's algorithm is 'Applicable to systems with multiple instances of each resource type.'
How does the efficiency of the Banker's algorithm compare to the Resource-allocation graph scheme?,It is more efficient.,It is equally efficient.,It is less efficient.,Efficiency comparison is not possible.,Efficiency depends solely on the number of resources.,C,"The text states, 'Less efficient than resource-allocation graph scheme.'"
"When a new thread enters a system employing the Banker's algorithm, what must it declare?",Its current resource allocation.,The maximum instances of each resource type it may need.,The number of resources it currently holds.,Whether it needs to wait for resources.,Its execution priority.,B,A new thread 'declares max instances of each resource type needed.'
What is the constraint on the maximum resource instances a new thread can declare in the Banker's algorithm?,It must be less than the current available resources.,It cannot exceed the total system resources.,It must be equal to its current allocation.,It must be less than the resources held by other threads.,There is no constraint; threads can declare any amount.,B,The declared max instances 'cannot exceed total system resources.'
Under what condition is a resource request granted in the Banker's algorithm?,If the requested resources are immediately available.,If the allocation leaves the system in a safe state.,If the requesting thread has the highest priority.,If no other thread is currently waiting.,If the request is for a single instance of a resource type.,B,A request is granted 'only if allocation leaves system in safe state.'
"In the Banker's algorithm, what information does the 'Available' vector store?",The maximum demand of each thread.,The resources currently allocated to each thread.,The number of available resources of each type.,The remaining resource need of each thread.,The total number of resource types.,C,"'Available' is a 'vector of length m, number of available resources of each type.'"
What does the 'Max' matrix represent in the Banker's algorithm?,Resources currently allocated to each thread.,Remaining resource need of each thread.,Number of available resources of each type.,Maximum demand of each thread.,The total number of resource instances in the system.,D,"'Max' is an 'n x m matrix, max demand of each thread.'"
The 'Allocation' matrix in the Banker's algorithm stores which of the following?,The total resources available to the system.,The resources that have been released by threads.,Resources currently allocated to each thread.,The maximum resources each thread may request.,Resources that are currently unavailable.,C,"'Allocation' is an 'n x m matrix, resources currently allocated to each thread.'"
"How is the 'Need' matrix calculated in the Banker's algorithm, and what does it represent?","It's Available minus Allocation, representing available resources.","It's Max plus Allocation, representing total potential resources.","It's Max minus Allocation, representing the remaining resource need of each thread.","It's Allocation minus Max, representing over-allocated resources.","It's Available plus Allocation, representing the system's total resources.",C,"'Need' is calculated as Max[i][j] minus Allocation[i][j], representing the remaining resource need of each thread."
"In the Banker's Safety Algorithm, what is the initial value assigned to the 'Work' vector?",A vector of all zeros.,The Max matrix.,The Available vector.,The Allocation matrix.,The Need matrix.,C,Step 1 of the Safety Algorithm states: 'Initialize Work = Available.'
How is the 'Finish' array initialized for each thread 'i' in the Banker's Safety Algorithm?,Finish[i] = true,Finish[i] = false,Finish[i] = Need for thread i,Finish[i] = Allocation for thread i,Finish[i] = Available,B,"Step 1 of the Safety Algorithm states: 'Finish[i] = false for i = 0, 1, ..., n-1.'"
"In the Banker's Safety Algorithm, what conditions must be met to find an index 'i' (representing a thread) to process?",Finish[i] is true AND Need for thread i is greater than Work.,Finish[i] is false AND Need for thread i is less than or equal to Work.,Finish[i] is false AND Allocation for thread i is greater than Work.,Finish[i] is true AND Allocation for thread i is less than or equal to Work.,Finish[i] is false AND Request for thread i is less than or equal to Work.,B,Step 2 of the Safety Algorithm states: 'Find index i such that Finish[i] == false and Need_i <= Work.'
"If a suitable thread 'i' is found in the Banker's Safety Algorithm, how are the 'Work' vector and 'Finish[i]' updated?",Work = Work minus Allocation for thread i; Finish[i] = false.,Work = Work plus Need for thread i; Finish[i] = true.,Work = Work plus Allocation for thread i; Finish[i] = true.,Work = Work minus Need for thread i; Finish[i] = false.,Work = Available; Finish[i] = true.,C,Step 3 of the Safety Algorithm states: 'Work = Work + Allocation_i; Finish[i] = true.'
How is it determined that the system is in a safe state at the end of the Banker's Safety Algorithm?,If Work is equal to Available.,If Finish[i] is false for all i.,If Allocation for thread i is zero for all i.,If Finish[i] is true for all i.,If no thread needed to wait for resources.,D,"Step 4 of the Safety Algorithm states: 'If Finish[i] == true for all i, system is in safe state.'"
What is the time complexity of the Banker's Safety Algorithm?,O(n),O(m times n),O(m times n squared),O(n squared),O(m squared times n),C,The text states the algorithm complexity is 'O(m x n^2) operations.'
What is the very first condition checked when a thread Ti makes a resource request (Request for thread Ti) using the Banker's Resource-request algorithm?,If Request for thread Ti is less than or equal to Available.,If Request for thread Ti is less than or equal to Need for thread Ti.,If the resulting state is safe.,If Request for thread Ti is greater than the total system resources.,If Ti has the highest priority.,B,"Step 1 states: 'If Request_i <= Need_i, go to step 2. Else, error (thread exceeded max claim).'"
"In the Banker's Resource-request algorithm, what is the outcome if a thread's Request for thread Ti is greater than its Need for thread Ti?",The request is immediately granted.,The thread is put into a waiting state.,"An error is indicated, as the thread exceeded its max claim.",The system attempts to find a safe sequence.,The request is modified to match Need for thread Ti.,C,"Step 1 states: 'Else, error (thread exceeded max claim).'"
"After confirming Request for thread Ti is less than or equal to Need for thread Ti, what is the next condition checked in the Banker's Resource-request algorithm?",If the system is currently in a safe state.,If Request for thread Ti is less than or equal to Available.,If any other thread is waiting.,If Allocation for thread Ti is zero.,If Max for thread Ti has been reached.,B,"Step 2 states: 'If Request_i <= Available, go to step 3.'"
"If a thread Ti's Request for thread Ti is found to be greater than Available resources in the Banker's Resource-request algorithm, what happens?",The request is immediately granted.,The system restores its old state.,Ti must wait.,An error is indicated.,Resources are pre-empted from other threads.,C,"Step 2 states: 'Else, Ti must wait (resources unavailable).'"
"During the 'pretend allocation' step of the Banker's Resource-request algorithm, how are Available, Allocation for thread Ti, and Need for thread Ti updated?","Available increases, Allocation for thread Ti decreases, Need for thread Ti increases.","Available decreases, Allocation for thread Ti increases, Need for thread Ti decreases.",All three remain unchanged.,"Available and Allocation for thread Ti increase, Need for thread Ti decreases.",All three decrease.,B,"The text lists the updates: 'Available = Available - Request_i', 'Allocation_i = Allocation_i + Request_i', 'Need_i = Need_i - Request_i'."
What is the final condition that determines if a resource request is granted in the Banker's Resource-request algorithm?,If the request amount is less than the current available resources.,If the Need for thread Ti becomes zero after the allocation.,If the resulting state after pretend allocation is safe.,If no other threads are currently making requests.,If the request comes from a high-priority thread.,C,"Step 4 states: 'If resulting state is safe (using Safety Algorithm), grant request.'"
"If the resulting state after a 'pretend allocation' is found to be unsafe in the Banker's Resource-request algorithm, what is the consequence?",The request is granted anyway.,The system enters a deadlocked state.,"Ti waits, and the old state is restored.",Resources are pre-empted from Ti.,The Need for thread Ti is reset to its maximum.,C,"Step 4 states: 'Else, Ti waits, restore old state.'"
"According to the provided glossary, what defines a 'safe sequence'?",A sequence of processes that always leads to a deadlock.,A sequence where each process completes execution immediately.,"A sequence of processes <P1, P2, ..., Pn> where each P(i)'s requests can be met by available resources plus resources held by P(j) (j is less than i).",A sequence where processes are granted resources strictly in the order of their arrival.,A sequence that minimizes the total number of resource requests.,C,"The glossary defines a safe sequence as: 'Sequence of processes <P1, P2, ..., Pn> where each Pi's requests can be met by available resources + resources held by Pj (j < i).'"
"As defined in the glossary, what is a 'claim edge' in a resource-allocation graph?",An edge indicating a resource is currently allocated to a process.,An edge representing a process's current request for a resource.,An edge indicating a process might claim a resource in the future.,An edge that signifies a deadlock has occurred.,An edge showing a resource has been released by a process.,C,"The glossary defines a claim edge as: 'In resource-allocation graph, an edge indicating a process might claim a resource in the future.'"
"Based on the glossary, which statement best describes the Banker's algorithm?",A deadlock detection algorithm for single resource instances.,A deadlock prevention algorithm that limits resource requests.,"A deadlock avoidance algorithm for multiple resource instances, less efficient than resource-allocation graph.",A resource scheduling algorithm that prioritizes critical processes.,An algorithm for recovering from deadlocks once they occur.,C,"The glossary defines Banker's algorithm as: 'Deadlock avoidance algorithm for multiple resource instances, less efficient than resource-allocation graph.'"
"If a system does not employ deadlock-prevention or deadlock-avoidance strategies, what two main algorithms must it utilize?",Resource preemption and process termination,Deadlock detection and deadlock recovery,Banker's algorithm and graph reduction,Mutual exclusion and hold and wait prevention,Cycle elimination and resource reallocation,B,Systems that do not use deadlock-prevention or deadlock-avoidance must implement algorithms for both deadlock detection and deadlock recovery.
What is a primary consideration regarding the overhead associated with deadlock detection and recovery?,The reduction in system security measures,The increase in CPU clock speed,The run-time costs and potential losses from recovery,The simplification of process scheduling,The elimination of all resource contention,C,Detection-and-recovery overhead involves run-time costs and potential losses that may occur from the recovery process.
Which graph type is used for deadlock detection when there is only a single instance of each resource type?,Gantt chart,Dependency graph,Resource-allocation graph,Wait-for graph,Control flow graph,D,The wait-for graph is a specific variant of the resource-allocation graph used for deadlock detection when there's a single instance of each resource type.
How is a wait-for graph typically obtained from a resource-allocation graph?,By adding new resource nodes and directed edges.,By removing resource nodes and collapsing the corresponding edges.,By converting all directed edges to undirected edges.,By assigning weights to each node based on resource availability.,By separating threads and resources into distinct subgraphs.,B,A wait-for graph is obtained by removing resource nodes from the resource-allocation graph and collapsing the edges that represent resource requests and allocations.
"In a wait-for graph, what does an edge from thread T_i to thread T_j (T_i -> T_j) signify?",Thread T_i has completed execution before thread T_j.,Thread T_j is waiting for thread T_i to release a resource.,Thread T_i is waiting for thread T_j to release a resource that T_i needs.,Thread T_i has acquired a resource from thread T_j.,Thread T_i and Thread T_j are independent and do not interact.,C,An edge T_i -> T_j in a wait-for graph implies that thread T_i is waiting for thread T_j to release a resource R_q that T_i needs.
What characteristic of a wait-for graph indicates the presence of a deadlock?,It contains no isolated nodes.,It has multiple connected components.,It forms a directed acyclic graph (DAG).,It contains a cycle.,The number of edges equals the number of nodes.,D,Deadlock exists if the wait-for graph contains a cycle.
"What is the typical time complexity for cycle detection in a wait-for graph, where 'n' is the number of vertices?",O(n),O(log n),O(n^2),O(n log n),O(n^3),C,"Cycle detection in a wait-for graph has a time complexity of O(n^2) operations, where n is the number of vertices."
The `deadlock_detector` tool from the BCC toolkit on Linux is designed to identify deadlocks specifically for which type of synchronization primitive?,Semaphores,Condition variables,Pthreads mutex locks,Read-write locks,Spinlocks,C,The `deadlock_detector` tool is specified for Pthreads mutex locks on Linux.
How does the `deadlock_detector` tool identify deadlocks?,By analyzing log files for error messages.,By simulating various thread execution orders.,"By inserting probes to trace `pthread_mutex_lock()` and `pthread_mutex_unlock()` calls, then constructing and analyzing a wait-for graph.",By monitoring CPU utilization patterns.,By periodically checking the system call table for hung operations.,C,"It inserts probes to trace `pthread_mutex_lock()` and `pthread_mutex_unlock()` calls, constructs a wait-for graph, and reports a deadlock if a cycle is detected."
"When there are several instances of a resource type, why is the wait-for graph scheme not applicable for deadlock detection?",It becomes too computationally expensive.,It cannot accurately represent multiple instances of resources.,It only works for a single thread system.,"It is primarily for resource allocation, not detection.",It does not allow for dynamic resource requests.,B,"The text explicitly states that the wait-for graph scheme is not applicable when there are several instances of a resource type, implying it's designed for single instances per type."
The deadlock detection algorithm for several instances of a resource type is similar to which other well-known algorithm?,Dijkstra's algorithm,Banker's algorithm,Dining Philosophers algorithm,"First-Come, First-Served algorithm",Round-Robin algorithm,B,The algorithm for several instances of a resource type is stated to be similar to the Banker's algorithm.
"In the deadlock detection algorithm for multiple resource instances, what does the 'Available' vector represent?",The total number of resources in the system.,The maximum number of resources that can be allocated.,The number of available resources of each type.,Resources currently held by completed threads.,Resources requested by active threads.,C,Available is a vector of length 'm' representing the number of available resources of each type.
What does the 'Allocation' matrix represent in the deadlock detection algorithm for multiple resource instances?,The maximum number of resources each thread may request.,Resources currently allocated to each thread.,The remaining resources each thread still needs.,The total resources available in the system.,The history of resource requests.,B,Allocation is an n x m matrix showing resources currently allocated to each thread.
"In the context of the deadlock detection algorithm for multiple resource instances, what does `Request[i][j] = k` signify?",Thread `T_i` has successfully allocated `k` instances of resource type `R_j`.,Thread `T_i` is currently holding `k` instances of resource type `R_j`.,Thread `T_i` needs `k` more instances of resource type `R_j`.,Thread `T_j` is requesting `k` instances of resource type `R_i`.,Thread `T_i` has released `k` instances of resource type `R_j`.,C,`Request[i][j] = k` means thread `T_i` requests `k` more instances of resource type `R_j`.
"According to the deadlock detection algorithm for several instances of a resource type, what is the initial assignment for the 'Work' vector?",It is set to zero for all resource types.,It is set equal to the 'Allocation' matrix for the first thread.,It is initialized with the 'Available' vector.,It is set to the 'Request' matrix for all threads.,It is calculated as the sum of 'Allocation' and 'Request'.,C,Step 1 of the algorithm states: 'Initialize Work = Available'.
"In the deadlock detection algorithm for multiple resource instances, under what condition is `Finish[i]` initially set to `true` for a thread `T_i`?",If `T_i` has no pending requests (`Request_i == 0`).,If `T_i` has completed its execution.,If `T_i` has no resources allocated to it (`Allocation_i == 0`).,If `T_i` is currently blocked.,If `T_i` is part of a safe sequence.,C,"Step 1 states: 'If Allocation_i != 0, then Finish[i] = false. Otherwise (if Allocation_i == 0), Finish[i] = true'."
"What is the time complexity of the deadlock detection algorithm for several instances of a resource type, given 'n' threads and 'm' resource types?",O(n + m),O(n * m),O(m * n^2),O(n * m^2),O(n^3),C,The algorithm complexity is stated as O(m * n^2) operations.
The deadlock detection algorithm for multiple resource instances operates with an 'optimistic attitude'. What does this imply?,It assumes all resource requests will eventually be granted.,It assumes threads will voluntarily release resources if needed.,It assumes a thread `T_i` will complete and return its resources if `Request_i` is less than or equal to `Work`.,It prioritizes threads that have not yet requested any resources.,It optimistically allocates all requested resources immediately.,C,The 'optimistic attitude' is described as assuming `T_i` will complete and return resources if `Request_i <= Work`.
Consider the initial state described in the example for the 'several instances' detection algorithm. What is the claimed status of the system regarding deadlocks?,The system is definitely deadlocked.,"The system is not deadlocked, and a safe sequence exists.",The system is in an unsafe state but not necessarily deadlocked.,The system cannot determine its deadlock status without further requests.,Deadlock is pending for thread T4.,B,"The text states for the initial state: 'Initial claim: system not deadlocked. Sequence <T0, T2, T3, T1, T4> results in Finish[i] == true for all i.'"
"Referring to the example, if thread `T_2` requests 1 additional instance of resource C, what is the impact on the system's deadlock status?",The system remains not deadlocked.,The system enters a safe state.,"The system becomes deadlocked, involving threads `T_1, T_2, T_3, T_4`.",Only thread `T_2` becomes deadlocked.,The system enters a state where all resources are immediately available.,C,"The text states: 'New claim: system is deadlocked. Can reclaim T0's resources, but not enough for others. Deadlock involves T1, T2, T3, T4.'"
What are the two primary factors that determine when to invoke a deadlock detection algorithm?,System boot time and network latency.,Amount of free memory and disk space.,How often a deadlock is likely to occur and how many threads will be affected.,The operating system version and kernel type.,User login frequency and application usage.,C,The text lists 'How often is a deadlock likely to occur?' and 'How many threads will be affected by deadlock when it happens?' as the two factors.
What is a consequence of threads being involved in a deadlock cycle?,They consume minimal CPU resources.,Their allocated resources become idle.,They automatically release their resources after a timeout.,They switch to a low-power mode.,They enter a state of suspended animation indefinitely.,B,"Resources allocated to deadlocked threads become idle, and the number of threads in the deadlock cycle may grow."
What is a significant disadvantage of invoking the deadlock detection algorithm every time a resource request cannot be granted immediately?,It makes it harder to identify the 'causing' thread.,It might lead to false positives.,It results in high computational overhead.,It can only be used in single-resource-instance scenarios.,It delays the recovery process significantly.,C,"While this method identifies the 'causing' thread, it comes with 'High computational overhead'."
What is an advantage of invoking the deadlock detection algorithm every time a resource request cannot be granted immediately?,It is the least expensive invocation method.,It always prevents deadlocks from occurring.,It ensures that no resources ever become idle.,It identifies deadlocked threads and the specific thread that 'caused' the deadlock.,It works without maintaining any complex data structures.,D,Invoking the algorithm every time a request cannot be granted 'Identifies deadlocked threads and the specific thread that 'caused' the deadlock'.
"What is a potential drawback of invoking the deadlock detection algorithm only at defined intervals (e.g., hourly or when CPU utilization drops)?",It always incurs higher computational overhead than continuous invocation.,It may not identify the specific thread that 'caused' the deadlock.,It prevents any threads from entering a deadlocked state.,It requires manual intervention for recovery.,It can only detect deadlocks in single-instance resource systems.,B,A less expensive invocation at defined intervals 'May not identify the 'causing' thread'.
How do database systems primarily manage deadlocks?,By preventing them through strict resource ordering.,By avoiding them using the Banker's algorithm.,By using deadlock detection and recovery mechanisms.,By requiring manual intervention from a database administrator.,By limiting the number of concurrent transactions.,C,Database systems manage deadlock using detection and recovery.
"In database systems, what are updates often referred to as, which utilize locks for data integrity and can lead to deadlocks?",Processes,Operations,Transactions,Queries,Sessions,C,"Updates are referred to as 'transactions' in database systems, which use locks and can lead to deadlocks."
How does a database server typically detect deadlocks?,By performing a full system reboot.,By monitoring individual lock acquisition times.,By periodically searching for cycles in the wait-for graph.,By checking for excessive memory usage.,By requiring manual deadlock checks by developers.,C,The database server periodically searches for cycles in the wait-for graph to detect deadlocks.
"When a deadlock is detected in a database system, what is the initial step taken for recovery?",All transactions are immediately aborted.,A victim transaction is selected.,New locks are granted to all waiting transactions.,The database server pauses all operations.,An error message is logged without further action.,B,"When a deadlock is detected, the first step is that 'A victim transaction is selected'."
What happens immediately to a victim transaction chosen during database deadlock recovery?,It is prioritized for resource allocation.,It is suspended until resources become available.,"It is aborted and rolled back, releasing its locks.",It is forced to release only a portion of its locks.,It is moved to a lower priority queue.,C,"The victim transaction is aborted and rolled back, releasing its locks."
"After a victim transaction is aborted and rolled back in a database deadlock scenario, what is the outcome for the remaining transactions involved in the deadlock?",They also get aborted automatically.,They remain in a deadlocked state.,They are freed from deadlock.,They must restart from the beginning.,They acquire new locks from other transactions.,C,"After the victim is aborted and rolled back, the 'Remaining transactions are freed from deadlock'."
What happens to a transaction that has been aborted and rolled back as a victim of a database deadlock?,It is permanently discarded.,It is reissued to execute again.,It enters a waiting state indefinitely.,It converts into a read-only transaction.,It requires manual re-entry by the user.,B,The aborted transaction is reissued.
Which criterion might MySQL use when selecting a victim transaction during database deadlock recovery?,The transaction that has been running the longest.,The transaction that holds the most locks.,"The transaction that has inserted, updated, or deleted the minimum number of rows.",The transaction that requested the lock first.,The transaction that is least likely to succeed.,C,"MySQL, for example, minimizes rows inserted, updated, or deleted when choosing a victim."
"According to the provided glossary, which statement accurately defines a 'wait-for graph'?",A graph showing the order in which threads acquire resources.,"A variant of the resource-allocation graph with resource nodes removed, indicating a deadlock if the graph contains a cycle.",A graph used exclusively for preventing deadlocks in real-time systems.,A tool for visualizing the dependencies between different processes.,A network diagram illustrating communication between servers.,B,"The glossary defines a 'wait-for graph' as 'In deadlock detection, a variant of the resource-allocation graph with resource nodes removed; indicates a deadlock if the graph contains a cycle.'"
"What is the primary purpose of a 'thread dump' in Java, according to the glossary?",To optimize garbage collection performance.,"To provide a snapshot of all thread states for debugging, especially deadlocks.",To reallocate memory efficiently among threads.,To terminate unresponsive threads.,To log network activity of an application.,B,The glossary states 'thread dump' is 'a snapshot of the state of all threads in an application; a useful debugging tool for deadlocks.'
"When a deadlock is detected in a system, what are the two primary high-level options for recovery?",Implement a resource ordering scheme or perform a system reboot.,Increase the priority of deadlocked processes or expand system memory.,Inform the operator for manual recovery or allow the system to recover automatically.,Isolate the deadlocked processes or prevent future resource requests.,Apply the Banker's algorithm or initiate a system-wide rollback.,C,"The text states that when a deadlock is detected, the options are to 'Inform operator (manual recovery)' or for the 'System recovers automatically'."
What are the two fundamental strategies for actively breaking a deadlock once it has been identified?,Introduce more resources to the system or reduce the number of active processes.,Abort one or more threads (to break circular wait) or preempt resources from deadlocked threads.,Change process scheduling algorithms or increase CPU clock speed.,Implement a timeout for resource requests or use a deadlock prevention algorithm.,Migrate deadlocked processes to another server or restart individual applications.,B,The text explicitly lists 'Abort one or more threads (break circular wait)' and 'Preempt resources from deadlocked threads' as the two options for breaking deadlock.
"When deadlocks are resolved by aborting a process or thread, what action does the system take regarding the resources previously held by the terminated entity?",The resources are released to a temporary holding area.,The system reclaims all of those resources.,The resources remain allocated but inaccessible.,The resources are automatically reallocated to the next waiting process.,The resources are marked as permanently unavailable.,B,"The text states that when eliminating deadlocks by aborting a process/thread, the 'System reclaims all resources'."
What is a significant drawback of choosing to 'Abort all deadlocked processes' as a deadlock recovery method?,It often fails to break the deadlock cycle effectively.,It is expensive due to discarded computations and the necessity for recomputation.,It requires continuous manual intervention by the system operator.,It can lead to unpredictable system crashes and data loss.,It causes high overhead due to frequent deadlock detection cycles.,B,"The text identifies 'Abort all deadlocked processes' as 'expensive (discarded computations, recomputation needed)'."
"Which specific method of deadlock recovery, involving process termination, is characterized by 'High overhead (deadlock-detection after each abort)'?",Aborting all deadlocked processes simultaneously.,Preempting resources from all involved processes.,Implementing a system-wide rollback to a safe state.,Aborting one process at a time until the deadlock is eliminated.,Manually reallocating resources based on process priority.,D,The text specifies that 'Abort one process at a time until deadlock eliminated' results in 'High overhead (deadlock-detection after each abort)'.
"If a process is aborted for deadlock recovery while it is in the middle of updating a file, what is a potential issue?",The process will automatically restart and complete the file update.,The file might be left in an incorrect or inconsistent state.,The entire file system will become corrupted.,All other processes accessing files will be blocked indefinitely.,The system will automatically restore the file to its original state before the update.,B,The text lists 'File in incorrect state if updating' as a potential issue when aborting a process.
What problem can arise if a process is aborted for deadlock resolution while holding a mutex lock and updating shared data?,The mutex lock will be permanently destroyed.,Other processes will be able to immediately acquire the lock without issue.,"Shared data integrity issues may occur, necessitating restoration of the lock status.",The aborted process will automatically re-acquire the lock upon restart.,The system will automatically revert all shared data to its last consistent state.,C,The text states: 'Shared data integrity issues if updating while holding mutex lock (must restore lock status)'.
"When performing partial termination to resolve a deadlock, the decision of which process to terminate is described as a 'policy decision'. What other critical characteristic is mentioned for this decision?",Technical,Legal,Economic,Random,Arbitrary,C,"The text specifies that the decision of which process to terminate is a 'policy decision, economic'."
Which of the following is a factor considered when choosing a 'victim' process for termination to minimize the cost of deadlock recovery?,The color scheme of the process's user interface.,The current network bandwidth utilization.,The process priority.,The amount of available disk space.,The time since the last system reboot.,C,Process priority is listed as one of the 'Factors for choosing victim (minimum cost)'.
"When selecting a victim for deadlock termination, 'computation time' is a factor. What specific aspects of computation time are considered?",Only the remaining time until the process completes.,Only the time the process has already spent computing.,How long the process has computed and how much longer it needs to complete.,The CPU cycles consumed per instruction.,The maximum allowed computation time for the process.,C,"The text specifies 'Computation time (how long computed, how much longer)' as a factor for victim selection."
"In the context of choosing a victim process for deadlock recovery, which aspect of 'resources used' is a relevant factor?",The monetary value of the resources held.,The number of files the process has opened.,The types of resources used and their ease of preemption.,Whether the resources are physical or virtual.,The total capacity of all resources held.,C,"The text lists 'Resources used (types, ease of preemption)' as a factor for choosing a victim."
What is the primary objective when selecting a victim process for termination in deadlock recovery?,To choose the process that has consumed the most CPU time.,To ensure that all processes get an equal chance to be terminated.,To minimize the overall cost associated with the termination.,To terminate the process with the lowest security clearance.,To randomly select a process to ensure fairness.,C,The text states that factors for choosing a victim are aimed at achieving 'minimum cost'.
How does resource preemption typically resolve a deadlock?,By forcing processes to request all their resources at once.,By preventing new resource requests from being made.,By successively taking resources from processes and reassigning them to others until the deadlock is broken.,By rolling back the entire system to a previous state.,"By allocating additional, redundant resources to all processes.",C,"Resource preemption involves 'Successively preempt resources from processes, give to others until deadlock broken'."
Which of the following is NOT one of the three core issues associated with resource preemption as a deadlock recovery method?,Selecting a victim,Rollback,Starvation,Resource discovery,All of the above are issues,D,"The three issues listed are 'Selecting a victim', 'Rollback', and 'Starvation'. 'Resource discovery' is not mentioned."
"When selecting a victim for resource preemption, what is the key consideration for minimizing cost?",The process's current network activity.,The resources held by the process and the time it has consumed.,The number of input/output operations performed by the process.,The total amount of memory allocated to the process.,The number of open network connections.,B,"When selecting a victim for preemption, the goal is to 'Minimize cost (e.g., resources held, time consumed)'."
"After a process has its resources preempted, what action is typically taken regarding that process?","It is allowed to continue execution, ignoring the missing resource.",It is automatically restarted from the beginning without any state preservation.,It is rolled back to a safe state and then restarted.,It is immediately terminated without further action.,It is placed into a suspended state until the resource becomes available again.,C,"The text states that a preempted process 'Cannot continue normal execution (missing resource). Roll back to safe state, restart'."
Which type of rollback is described as the 'simplest' method when resources are preempted from a process?,Rolling back only the specific operations affected by the preemption.,"Total rollback, which involves aborting the process and restarting it.",Implementing frequent checkpoints to restore to a very recent state.,A partial rollback that leaves some operations incomplete.,Manually re-entering data after the process is restarted.,B,"The text defines the 'Simplest' rollback as 'total rollback (abort, restart)'."
"What characterizes the 'more effective' method of rollback, as opposed to the simplest method?",It performs a full system reboot.,It rolls back only as necessary and requires more state information.,It does not require any state information.,It only works for processes with very low priority.,It involves manual intervention for every rollback operation.,B,The text describes the 'More effective' rollback as 'roll back only as necessary (requires more state info)'.
"In the context of resource preemption, what does the issue of 'Starvation' refer to?",A situation where the system runs out of physical memory.,A condition where a process never completes because its resources are repeatedly preempted.,The inability of a process to acquire any resources due to high demand.,A scenario where the operating system itself runs low on critical resources.,The continuous failure of resource allocation algorithms.,B,Starvation is described as when a 'Process never completes' due to being repeatedly picked as a victim for resource preemption.
How can starvation be prevented in a system where resource preemption is used for deadlock recovery?,By ensuring a process is picked as a victim an infinite number of times.,By always selecting the same process as the victim.,By ensuring a process is picked as a victim a finite number of times.,By increasing the priority of the victim process to infinity.,By never preempting resources from any process.,C,"To prevent starvation, the system must 'Ensure process picked as victim finite number of times'."
A common solution to prevent starvation during resource preemption involves including what specific factor in the cost calculation for victim selection?,The total CPU time consumed by the process.,The amount of memory currently in use by the process.,The number of times the process has been rolled back.,The number of files the process has open.,The unique process ID number.,C,A 'Common solution' to starvation is to 'include number of rollbacks in cost factor'.
"Based on the provided glossary, what is the definition of 'recovery mode'?",A system setting that enables automatic data backup and synchronization.,"A system boot state providing limited services, designed to assist system administrators in repairing and debugging.",A network protocol used for restoring lost data packets.,A software utility that automatically fixes corrupted files.,A low-power state for electronic devices.,B,The glossary defines 'recovery mode' as 'A system boot state providing limited services and designed to enable the system admin to repair system problems and debug system startup'.
Which factor for choosing a victim process in deadlock recovery refers to how many resources a process will still need to complete its execution?,Process priority.,Computation time.,Resources used.,Resources needed to complete.,Number of processes to terminate.,D,'Resources needed to complete' is explicitly listed as a factor for choosing a victim.
"When considering the factors for choosing a victim process to terminate, 'number of processes to terminate' is mentioned. What is the implied goal when considering this factor?",To terminate as many processes as possible to free up resources.,To ensure that only one process is ever terminated at a time.,To minimize the number of processes that need to be terminated to break the deadlock.,To terminate a fixed number of processes regardless of the deadlock state.,To prioritize terminating processes that are easy to restart.,C,"This factor contributes to the goal of 'minimum cost', implying that terminating fewer processes is generally preferred if it resolves the deadlock."
Which statement accurately defines a deadlock?,A set of processes where each process is waiting for an event caused by another process within the same set.,"A state where a single process is infinitely looping, consuming all CPU resources.",An error where a program crashes due to insufficient memory.,A condition where all processes complete their execution simultaneously.,The rapid execution of multiple processes on a multi-core system.,A,"A deadlock is specifically defined as a situation where a set of processes are all blocked, each waiting for a resource or event held by another process in that same set."
How many necessary conditions must be present for a deadlock to occur?,One,Two,Three,Four,Five,D,The text explicitly states 'Four necessary conditions for deadlock'.
Which of the following is NOT one of the four necessary conditions for deadlock?,Mutual exclusion,Hold and wait,Resource preemption,Circular wait,No preemption,C,"The four necessary conditions are Mutual exclusion, Hold and wait, No preemption, and Circular wait. 'Resource preemption' is the opposite of 'No preemption' and would prevent deadlock, not cause it."
The 'mutual exclusion' condition for deadlock implies that:,Processes must share resources simultaneously.,Only one process at a time can use a resource.,Resources can be accessed by multiple processes concurrently.,Processes can enter a critical section without acquiring a lock.,All resources are always available to all processes.,B,"Mutual exclusion means that at least one resource involved must be non-sharable, allowing only one process to use it at a time."
The 'hold and wait' condition for deadlock describes a situation where a process:,Requests all its resources at the beginning of execution.,Releases all held resources before requesting new ones.,Holds at least one resource and is waiting to acquire additional resources held by other processes.,Waits for a specific event to occur before acquiring any resources.,Immediately releases resources as soon as it finishes using them.,C,Hold and wait means a process is holding onto at least one resource while waiting to acquire additional resources that are currently held by other processes.
The 'no preemption' condition for deadlock means that:,Resources can be forcibly taken away from a process.,"A resource can be released only voluntarily by the process holding it, after that process has completed its task.",Processes must preempt other processes to acquire resources.,All resources are preemptable.,Processes can always take resources from other processes if needed.,B,No preemption implies that resources cannot be forcibly taken away; they must be voluntarily released by the process holding them.
The 'circular wait' condition for deadlock means there exists a:,Linear sequence of processes where each process waits for the next.,"Set of processes P0, P1, ..., Pn such that P0 is waiting for a resource held by P1, P1 is waiting for a resource held by P2, ..., and Pn is waiting for a resource held by P0.",Process that continuously allocates and deallocates the same resource.,Situation where processes are not allowed to wait for resources.,Hierarchy of resource allocation that prevents any cycles.,B,"Circular wait means there's a closed chain of processes where each process in the chain is waiting for a resource held by the next process in the chain, with the last process waiting for a resource held by the first."
"For a deadlock to be possible, which of the following must be true regarding the four necessary conditions?",At least one of the conditions must be present.,Any two of the conditions must be present.,Exactly three of the conditions must be present.,All four conditions must be present simultaneously.,None of the conditions should be present.,D,The text states that 'Deadlock only possible if all four conditions present'.
What tool is typically used to model deadlocks in a system?,Flowcharts,Gantt charts,Resource-allocation graphs,State transition diagrams,Petri nets,C,The text specifies that 'Deadlocks modeled with resource-allocation graphs'.
"In a resource-allocation graph, what visually indicates the presence of a deadlock?",A straight line connecting two processes.,An isolated process node.,A cycle in the graph.,An absence of edges between nodes.,All resources pointing to a single process.,C,"The text states that in resource-allocation graphs, a 'cycle indicates deadlock'."
The primary goal of deadlock prevention strategies is to:,Allow deadlocks to occur and then recover from them.,Detect deadlocks after they have happened.,Ensure that at least one of the four necessary conditions for deadlock cannot hold.,Grant resources liberally to all processes.,Identify unsafe states in resource allocation.,C,"Deadlock prevention aims to 'ensure one of four conditions cannot occur', thereby making deadlocks impossible."
Which of the four necessary conditions for deadlock is most commonly targeted for elimination in practical deadlock prevention?,Mutual exclusion,Hold and wait,No preemption,Circular wait,Resource starvation,D,The text notes that 'Practical prevention: eliminate circular wait'. Eliminating the other conditions can be impractical or lead to poor resource utilization.
Which algorithm is typically employed for deadlock avoidance?,Dijkstra's shortest path algorithm,Round-robin algorithm,Banker's algorithm,FIFO scheduling algorithm,LRU replacement algorithm,C,The text explicitly states that 'Deadlock avoidance: use banker's algorithm'.
What is the core principle behind deadlock avoidance regarding resource granting?,Always grant resources immediately upon request.,Grant resources only if the system remains in a safe state.,Grant resources only to processes with the highest priority.,Never grant resources if any process is currently waiting.,"Grant resources on a first-come, first-served basis without checking safety.",B,"Deadlock avoidance strategy is to 'don't grant resources if leads to unsafe state', implying resources are granted only if it maintains a safe state."
What is the main function of a deadlock detection algorithm?,To prevent deadlocks from ever occurring.,To ensure that resource requests are always granted.,To evaluate the current state of processes and resources on a running system to identify if a deadlocked state exists.,To automatically recover from any system crashes.,To predict future resource needs of processes.,C,Deadlock detection involves an 'algorithm evaluates processes/resources on running system to find deadlocked state'.
One strategy for deadlock recovery involves:,Waiting indefinitely for the deadlock to resolve itself.,Aborting one or more processes involved in the circular wait.,Increasing the system's memory allocation.,Adding more CPUs to the system.,Ignoring the deadlock and hoping it disappears.,B,One recovery strategy is to 'Abort one process in circular wait'.
Another method for deadlock recovery involves:,Requesting the user to manually release resources.,Automatically granting all pending resource requests.,Preempting (taking away) resources that have been assigned to deadlocked processes.,Suspending all processes in the system.,Restarting the entire operating system.,C,Another recovery strategy is to 'Preempt resources assigned to deadlocked process'.
A deadlock is fundamentally characterized by processes that are:,Actively competing for CPU time.,Rapidly completing their tasks.,Stalled and waiting for each other indefinitely.,Cooperating to share resources efficiently.,Failing to start due to missing executable files.,C,"The definition highlights that processes in a deadlock are 'each waiting for event caused by another process in set', implying they are stalled indefinitely."
The key difference between deadlock prevention and deadlock avoidance is that:,"Prevention ensures conditions *cannot* occur, while avoidance *doesn't grant* resources if it leads to an unsafe state.","Prevention uses the Banker's Algorithm, while avoidance eliminates circular wait.","Prevention only applies to single-resource systems, while avoidance applies to multi-resource systems.","Prevention is reactive, while avoidance is proactive.","Prevention is about detecting, while avoidance is about recovering.",A,"Prevention aims to 'ensure one of four conditions cannot occur', making deadlocks impossible by design. Avoidance is a dynamic approach that 'don't grant resources if leads to unsafe state', always trying to keep the system in a safe state."
Which two actions are listed as primary strategies for deadlock recovery?,Implementing the Banker's algorithm and eliminating circular wait.,Modeling with resource-allocation graphs and ensuring mutual exclusion.,Aborting a process in circular wait and preempting resources from deadlocked processes.,Detecting deadlocked states and preventing hold-and-wait conditions.,Allowing preemption and ensuring all four conditions are met.,C,The text lists 'Abort one process in circular wait' and 'Preempt resources assigned to deadlocked process' as recovery methods.
