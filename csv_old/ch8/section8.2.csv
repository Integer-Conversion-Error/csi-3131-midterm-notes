Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
What is the primary function of `pthread_mutex_init()` in Pthreads?,To acquire an existing mutex lock.,To release a held mutex lock.,To initialize a new mutex in an unlocked state.,To block a thread until a mutex becomes available.,To destroy a mutex that is no longer needed.,C,The text states that `pthread_mutex_init()` initializes an unlocked mutex.
What is the behavior of `pthread_mutex_lock()` when a thread attempts to acquire a mutex that is already held by another thread?,The function returns an error code immediately.,The calling thread proceeds without acquiring the lock.,The calling thread releases any locks it currently holds.,The calling thread blocks until the mutex lock is released.,The system automatically resolves the contention without blocking.,D,The text describes `pthread_mutex_lock()` as acquiring a lock and blocking if the lock is held.
Which Pthreads function is used to release a mutex lock?,`pthread_mutex_init()`,`pthread_mutex_lock()`,`pthread_mutex_release()`,`pthread_mutex_unlock()`,`pthread_mutex_destroy()`,D,The text explicitly states that `pthread_mutex_unlock()` releases a lock.
"In the described deadlock scenario, how many distinct mutex locks are created and utilized?",One,Two,Three,Four,Five,B,"The scenario details the creation of 'Two mutex locks: `first_mutex`, `second_mutex`'."
What is the specific locking order for `thread_one` in the Pthreads deadlock example?,`second_mutex` then `first_mutex`,`first_mutex` then `second_mutex`,Only `first_mutex`,No specific order is defined,The order is randomized,B,"The text states `thread_one` locks in order: (1) `first_mutex`, (2) `second_mutex`."
What is the specific locking order for `thread_two` in the Pthreads deadlock example?,`first_mutex` then `second_mutex`,`second_mutex` then `first_mutex`,Only `second_mutex`,No specific order is defined,The order is randomized,B,"The text states `thread_two` locks in order: (1) `second_mutex`, (2) `first_mutex`."
Which specific condition must be met for a deadlock to be possible in the given Pthreads example?,`thread_one` acquires `second_mutex` and `thread_two` acquires `first_mutex`.,Both `thread_one` and `thread_two` attempt to acquire the same mutex simultaneously.,`thread_one` acquires `first_mutex` and `thread_two` acquires `second_mutex`.,Both threads release all their acquired locks before attempting to acquire new ones.,Only one mutex is used across both threads.,C,"The text explains the deadlock is possible 'If `thread_one` acquires `first_mutex` and `thread_two` acquires `second_mutex`, both threads will block waiting for the other's lock.'"
What factor explicitly influences whether a deadlock occurs in the example scenario?,The total number of processes running on the system.,The amount of available system memory.,The CPU scheduler's behavior.,The version of the operating system.,The specific programming language used.,C,The text states that the 'Occurrence depends on the CPU scheduler'.
The intermittent nature of deadlocks has what primary consequence for software development?,It simplifies the compilation process of multithreaded applications.,It makes it easier to design scalable concurrent systems.,It makes identifying and testing for deadlocks difficult.,It guarantees that deadlocks will never occur in production environments.,It reduces the need for careful mutex management.,C,The text explains that the intermittent nature 'Makes identifying and testing for deadlocks difficult.'
"According to the provided text, what is the definition of livelock?",A condition where threads are completely idle and consuming no CPU time.,A state where a thread successfully completes its task but then immediately restarts it.,A condition in which a thread continuously attempts an action that fails.,A temporary pause in thread execution due to I/O operations.,A situation where a single thread monopolizes all available resources.,C,Both the main text and the glossary define livelock as 'A condition in which a thread continuously attempts an action that fails.'
How does livelock differ from deadlock in terms of thread state?,"In livelock, threads are blocked, while in deadlock, they are actively working.","In livelock, threads are not blocked, while in deadlock, threads are blocked.","Livelock only occurs in kernel mode, while deadlock occurs in user mode.","Deadlock is a temporary state, while livelock is permanent.",There is no difference; the terms are interchangeable.,B,"The text explicitly states livelock is 'Similar to deadlock, but threads are not blocked.'"
Which analogy is used to explain the concept of livelock?,A single-lane road with cars traveling in one direction.,"Two people trying to pass in a hallway, repeatedly moving into each other's way.",A group of people waiting in a line for a limited resource.,A marathon race where all runners are making progress.,A computer program successfully completing a complex calculation.,B,"The text provides the analogy: 'Two people trying to pass in a hallway, repeatedly moving into each other's way. They are active but make no progress.'"
What is the key characteristic of `pthread_mutex_trylock()` compared to `pthread_mutex_lock()`?,"`pthread_mutex_trylock()` initializes a mutex, while `pthread_mutex_lock()` acquires it.","`pthread_mutex_trylock()` acquires a lock and always blocks, while `pthread_mutex_lock()` does not block.","`pthread_mutex_trylock()` attempts to acquire a lock without blocking, while `pthread_mutex_lock()` blocks if the lock is held.","`pthread_mutex_trylock()` releases a mutex, while `pthread_mutex_lock()` acquires it.","`pthread_mutex_trylock()` is used for read-only access, while `pthread_mutex_lock()` is for write access.",C,The text defines `pthread_mutex_trylock()` as attempting 'to acquire a lock without blocking'.
"In the Pthreads livelock scenario involving `pthread_mutex_trylock()`, what is the outcome when threads fail to acquire the second mutex?",The threads immediately terminate.,The threads successfully complete their work due to retrying.,They release their currently held locks and repeat the attempt indefinitely.,"They block indefinitely, similar to a deadlock.",They exchange their held mutexes with each other.,C,"The text states: 'Both then call `trylock` on the other mutex, which fails. They release their locks and repeat indefinitely.'"
"What is a recommended strategy to avoid livelock, as mentioned in the text?","Always acquiring mutex locks in a predetermined, global order.",Implementing a fixed delay before retrying failed operations.,Having threads retry failing operations at random times.,Reducing the number of mutexes used in the application.,Increasing the CPU clock speed to speed up execution.,C,The text states livelock 'Can be avoided by having threads retry at random times.'
Which real-world example is provided to illustrate the concept of retrying operations at random times to avoid contention?,Database systems using two-phase locking.,Web servers distributing incoming requests among available instances.,Hosts involved in an Ethernet network collision backing off for a random period.,Operating system schedulers prioritizing tasks based on urgency.,Mail servers queuing emails for delivery.,C,The text uses the 'Ethernet Example: Hosts involved in a network collision backoff for a random period before retransmitting.'
How common is livelock compared to deadlock in concurrent application design?,Livelock is significantly more common than deadlock.,Livelock and deadlock occur with roughly equal frequency.,Livelock is less common than deadlock.,Livelock is a theoretical concept and rarely observed in practice.,Livelock has been completely eliminated in modern systems.,C,"The text states, 'Rarity: Less common than deadlock, but still a challenge in concurrent application design.'"
"In the `do_work_one` function of the deadlock example code, what is the order of mutex unlocking?",`first_mutex` then `second_mutex`,`second_mutex` then `first_mutex`,Only `first_mutex`,No mutexes are unlocked,The order is random,B,"The code shows `pthread_mutex_unlock(&second_mutex);` followed by `pthread_mutex_unlock(&first_mutex);`, which is the reverse of the locking order."
"In the `do_work_two` function of the deadlock example code, what is the order of mutex unlocking?",`second_mutex` then `first_mutex`,`first_mutex` then `second_mutex`,Only `second_mutex`,No mutexes are unlocked,The order is random,B,"The code shows `pthread_mutex_unlock(&first_mutex);` followed by `pthread_mutex_unlock(&second_mutex);`, which is the reverse of the locking order."
"In the livelock example code, specifically within the `do_work_one` function, what is the purpose of the `if (pthread_mutex_trylock(&second_mutex))` condition?",To check if `first_mutex` is currently available.,To attempt to acquire `second_mutex` and proceed only if successful without blocking.,To re-initialize `second_mutex` if it's in an invalid state.,To wait for `second_mutex` to become available indefinitely.,To signal to `thread_two` that `second_mutex` is needed.,B,The `pthread_mutex_trylock()` function attempts to acquire the lock without blocking. The `if` condition checks if this non-blocking attempt was successful.
"If `pthread_mutex_trylock(&second_mutex)` fails in the `do_work_one` function of the livelock example, what immediate action does `thread_one` take?",It attempts to acquire `second_mutex` using `pthread_mutex_lock()`.,It immediately exits the loop and the function.,"It releases `first_mutex`, which it currently holds.",It waits for a random amount of time before retrying.,It signals `thread_two` to release `second_mutex`.,C,"The `else` block after `if (pthread_mutex_trylock(&second_mutex))` contains `pthread_mutex_unlock(&first_mutex);`, meaning it releases the lock it already holds if the `trylock` fails."
What does the term 'liveness failure' imply in the context of livelock?,The system has crashed and is no longer operational.,Threads are actively working but not making any meaningful progress towards completion.,"The application is performing operations too quickly, leading to instability.",All threads are completely stopped and consuming no CPU cycles.,The system is unable to initiate new processes.,B,Livelock is described as a 'Liveness Failure' where threads are 'active but make no progress'.
