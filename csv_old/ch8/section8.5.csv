Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
"According to the provided text, when does a deadlock occur?",If at least one of the four necessary conditions holds.,If two or more necessary conditions hold simultaneously.,If all four necessary conditions hold.,Only when resources are preempted without notice.,Only when a circular wait condition is explicitly detected.,C,The text states: 'Deadlock occurs if all four necessary conditions hold.'
What is the primary objective of deadlock prevention methods?,To allow all four necessary conditions to hold but manage them effectively.,To ensure that at least one of the necessary conditions for deadlock cannot hold.,To detect deadlocks and recover from them efficiently.,To avoid deadlocks by dynamically analyzing resource requests.,To minimize the number of resources requested by threads.,B,The text states: 'Prevent deadlock by ensuring at least one condition cannot hold.' And the definition of 'deadlock prevention' is 'A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.'
Which condition is explicitly stated as 'must hold for deadlock'?,Hold and wait,No preemption,Circular wait,Mutual exclusion,Resource allocation,D,"Under the 'Mutual exclusion' section, the text says: 'Mutual-exclusion condition must hold for deadlock.'"
"Which type of resources, as described, do not require mutual exclusion and thus cannot be involved in a deadlock?",Nonsharable resources like mutex locks.,Intrinsically nonsharable resources.,Resources that can be preempted.,"Sharable resources (e.g., read-only files).",Resources allocated dynamically.,D,"The text states: 'Sharable resources (e.g., read-only files) do not require mutual exclusion, thus cannot be involved in deadlock.'"
Why is it generally impossible to prevent deadlocks by denying the mutual-exclusion condition?,Because mutual exclusion is only one of four conditions.,Because some resources are intrinsically nonsharable.,Because threads would never acquire resources.,Because it leads to higher resource utilization.,Because it increases the likelihood of starvation.,B,"The text states: 'Cannot generally prevent deadlocks by denying mutual-exclusion, as some resources are intrinsically nonsharable (e.g., mutex locks).'"
Which of the following describes Protocol 1 for preventing the 'hold and wait' condition?,A thread releases all current resources before requesting more.,A thread requests resources only when holding none.,A thread requests and allocates all resources before its execution begins.,A thread's held resources are preempted if it requests a resource and must wait.,Resources are requested in an increasing order of enumeration.,C,"Under 'Hold and wait', Protocol 1 is described as: 'Thread requests/allocates all resources before execution.'"
Which of the following describes Protocol 2 for preventing the 'hold and wait' condition?,A thread must request all resources at once at the start of execution.,"A thread requests resources only when holding none, and must release all current resources before requesting more.","If a thread requests a resource and must wait, all currently held resources are implicitly released.",Resources are granted based on a total ordering of resource types.,The operating system preempts resources from waiting threads and allocates them to requesting threads.,B,"Under 'Hold and wait', Protocol 2 is described as: 'Thread requests resources only when holding none. Must release all current resources before requesting more.'"
What are two significant disadvantages common to both 'hold and wait' prevention protocols?,Increased throughput and complex implementation.,Low resource utilization and potential for starvation.,High resource utilization and guaranteed fairness.,Reduced overhead and ease of debugging.,Guaranteed deadlock prevention and high concurrency.,B,The text lists two disadvantages for both protocols: 'Low resource utilization: resources allocated but unused for long periods.' and 'Starvation possible: thread waits indefinitely for popular resources.'
"In the context of 'no preemption' prevention, what happens in Protocol 1 if a thread requests a resource and must wait?","The thread's request is denied, and it tries again later.",All currently held resources by that thread are preempted (implicitly released).,"The thread is immediately granted the resource, overriding other processes.",The system checks if other threads can release their resources.,The thread is put into a queue and its resources remain held.,B,"Under 'No preemption', Protocol 1 states: 'If thread requests resource and must wait, all currently held resources are preempted (implicitly released).'"
"According to Protocol 1 for 'no preemption' prevention, when does a thread restart after its resources have been preempted?",Immediately after preemption.,When only the new requested resources are available.,When all other threads have finished their execution.,When its old and new resources are both available.,Only if the user manually restarts the process.,D,Protocol 1 for 'no preemption' states: 'Thread restarts when old and new resources are available.'
Which types of resources are often suitable for 'no preemption' prevention methods?,Mutex locks and semaphores.,Resources whose state cannot be saved or restored.,CPU registers and database transactions.,Sharable resources like read-only files.,Printers and other physical peripherals.,C,"The text states: 'Often applied to resources whose state can be saved/restored (e.g., CPU registers, database transactions).'"
Which types of resources are generally NOT suitable for 'no preemption' prevention methods?,CPU registers.,Database transactions.,Resources whose state can be saved/restored.,Mutex locks and semaphores.,Sharable read-only files.,D,The text states: 'Cannot generally apply to mutex locks and semaphores (where deadlocks commonly occur).'
What is the practical solution mentioned for preventing the 'circular wait' condition?,Ensuring all resources are requested at once.,Implementing preemption for all resource types.,Imposing a total ordering of all resource types.,Denying mutual exclusion for all resources.,Allowing threads to wait indefinitely for popular resources.,C,"Under 'Circular wait', the text says: 'Practical solution: impose total ordering of all resource types.'"
"When preventing 'circular wait' by imposing a total ordering, how are threads required to request resources?",In decreasing order of enumeration.,"In any random order, as long as all are requested at once.",In increasing order of enumeration.,Only one resource at a time.,"Based on their availability, regardless of order.",C,The text states: 'Require threads to request resources in increasing order of enumeration.'
"Consider a resource ordering where F(first_mutex) = 1 and F(second_mutex) = 5. According to the circular wait prevention protocol, in what order must a thread request these resources?",second_mutex then first_mutex.,first_mutex then second_mutex.,The order does not matter.,Both must be requested simultaneously.,Only one of them can be requested per thread.,B,"The text states: 'Example: F(first_mutex) = 1, F(second_mutex) = 5. Thread must request first_mutex then second_mutex.', which follows the rule of 'increasing order of enumeration'."
"In the circular wait prevention protocol using total ordering, if a thread needs multiple instances of the same resource type, what is required?",It must request them one by one.,It must make a single request for all instances at once.,It can request them in any order.,It must release all other resources first.,It must wait for other threads to finish using them.,B,"The text states: 'If multiple instances of same resource type needed, single request for all must be issued.'"
How does the text claim the total ordering protocol prevents circular wait?,By direct proof.,By induction.,By contradiction.,It does not guarantee prevention.,By empirical observation.,C,The text explicitly states: 'This protocol prevents circular wait (proof by contradiction).'
Which Java method is mentioned in the text as being used for lock acquisition ordering?,`System.getLockOrder()`,`System.identityHashCode(Object)`,`Object.getLockID()`,`Thread.getCurrentLock()`,`Lock.acquireOrder()`,B,The text states: 'Java uses `System.identityHashCode(Object)` for lock acquisition ordering.'
"Under what circumstance does lock ordering NOT guarantee deadlock prevention, according to the text?",If resources are sharable.,If locks are acquired dynamically.,If multiple instances of a resource type are needed.,If resource utilization is low.,If threads experience starvation.,B,"The text states: 'Lock ordering does not guarantee deadlock prevention if locks acquired dynamically (e.g., `transaction()` function example).'"
What is the definition of 'deadlock prevention' as provided in the section glossary?,An operating system method where processes inform the OS of resource use to approve/deny requests.,A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.,The process of detecting a deadlock after it has occurred and recovering from it.,Techniques for minimizing resource allocation overhead.,A protocol that prioritizes certain threads to avoid indefinite waiting.,B,The glossary defines 'deadlock prevention' as: 'A set of methods intended to ensure that at least one of the necessary conditions for deadlock cannot hold.'
How is 'deadlock avoidance' defined in the provided glossary?,A method to preempt resources from waiting threads.,A protocol requiring threads to request all resources before execution.,An operating system method in which processes inform the operating system of which resources they will use during their lifetimes so the system can approve or deny requests to avoid deadlock.,A technique that imposes a total ordering of all resource types to prevent circular wait.,A strategy that aims to deny mutual exclusion for all sharable resources.,C,The glossary defines 'deadlock avoidance' as: 'An operating system method in which processes inform the operating system of which resources they will use during their lifetimes so the system can approve or deny requests to avoid deadlock.'
