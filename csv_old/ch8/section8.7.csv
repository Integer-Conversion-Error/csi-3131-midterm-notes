Question,Option A,Option B,Option C,Option D,Option E,Answer,Explanation
"If a system does not employ deadlock-prevention or deadlock-avoidance strategies, what two main algorithms must it utilize?",Resource preemption and process termination,Deadlock detection and deadlock recovery,Banker's algorithm and graph reduction,Mutual exclusion and hold and wait prevention,Cycle elimination and resource reallocation,B,Systems that do not use deadlock-prevention or deadlock-avoidance must implement algorithms for both deadlock detection and deadlock recovery.
What is a primary consideration regarding the overhead associated with deadlock detection and recovery?,The reduction in system security measures,The increase in CPU clock speed,The run-time costs and potential losses from recovery,The simplification of process scheduling,The elimination of all resource contention,C,Detection-and-recovery overhead involves run-time costs and potential losses that may occur from the recovery process.
Which graph type is used for deadlock detection when there is only a single instance of each resource type?,Gantt chart,Dependency graph,Resource-allocation graph,Wait-for graph,Control flow graph,D,The wait-for graph is a specific variant of the resource-allocation graph used for deadlock detection when there's a single instance of each resource type.
How is a wait-for graph typically obtained from a resource-allocation graph?,By adding new resource nodes and directed edges.,By removing resource nodes and collapsing the corresponding edges.,By converting all directed edges to undirected edges.,By assigning weights to each node based on resource availability.,By separating threads and resources into distinct subgraphs.,B,A wait-for graph is obtained by removing resource nodes from the resource-allocation graph and collapsing the edges that represent resource requests and allocations.
"In a wait-for graph, what does an edge from thread T_i to thread T_j (T_i -> T_j) signify?",Thread T_i has completed execution before thread T_j.,Thread T_j is waiting for thread T_i to release a resource.,Thread T_i is waiting for thread T_j to release a resource that T_i needs.,Thread T_i has acquired a resource from thread T_j.,Thread T_i and Thread T_j are independent and do not interact.,C,An edge T_i -> T_j in a wait-for graph implies that thread T_i is waiting for thread T_j to release a resource R_q that T_i needs.
What characteristic of a wait-for graph indicates the presence of a deadlock?,It contains no isolated nodes.,It has multiple connected components.,It forms a directed acyclic graph (DAG).,It contains a cycle.,The number of edges equals the number of nodes.,D,Deadlock exists if the wait-for graph contains a cycle.
"What is the typical time complexity for cycle detection in a wait-for graph, where 'n' is the number of vertices?",O(n),O(log n),O(n^2),O(n log n),O(n^3),C,"Cycle detection in a wait-for graph has a time complexity of O(n^2) operations, where n is the number of vertices."
The `deadlock_detector` tool from the BCC toolkit on Linux is designed to identify deadlocks specifically for which type of synchronization primitive?,Semaphores,Condition variables,Pthreads mutex locks,Read-write locks,Spinlocks,C,The `deadlock_detector` tool is specified for Pthreads mutex locks on Linux.
How does the `deadlock_detector` tool identify deadlocks?,By analyzing log files for error messages.,By simulating various thread execution orders.,"By inserting probes to trace `pthread_mutex_lock()` and `pthread_mutex_unlock()` calls, then constructing and analyzing a wait-for graph.",By monitoring CPU utilization patterns.,By periodically checking the system call table for hung operations.,C,"It inserts probes to trace `pthread_mutex_lock()` and `pthread_mutex_unlock()` calls, constructs a wait-for graph, and reports a deadlock if a cycle is detected."
"When there are several instances of a resource type, why is the wait-for graph scheme not applicable for deadlock detection?",It becomes too computationally expensive.,It cannot accurately represent multiple instances of resources.,It only works for a single thread system.,"It is primarily for resource allocation, not detection.",It does not allow for dynamic resource requests.,B,"The text explicitly states that the wait-for graph scheme is not applicable when there are several instances of a resource type, implying it's designed for single instances per type."
The deadlock detection algorithm for several instances of a resource type is similar to which other well-known algorithm?,Dijkstra's algorithm,Banker's algorithm,Dining Philosophers algorithm,"First-Come, First-Served algorithm",Round-Robin algorithm,B,The algorithm for several instances of a resource type is stated to be similar to the Banker's algorithm.
"In the deadlock detection algorithm for multiple resource instances, what does the 'Available' vector represent?",The total number of resources in the system.,The maximum number of resources that can be allocated.,The number of available resources of each type.,Resources currently held by completed threads.,Resources requested by active threads.,C,Available is a vector of length 'm' representing the number of available resources of each type.
What does the 'Allocation' matrix represent in the deadlock detection algorithm for multiple resource instances?,The maximum number of resources each thread may request.,Resources currently allocated to each thread.,The remaining resources each thread still needs.,The total resources available in the system.,The history of resource requests.,B,Allocation is an n x m matrix showing resources currently allocated to each thread.
"In the context of the deadlock detection algorithm for multiple resource instances, what does `Request[i][j] = k` signify?",Thread `T_i` has successfully allocated `k` instances of resource type `R_j`.,Thread `T_i` is currently holding `k` instances of resource type `R_j`.,Thread `T_i` needs `k` more instances of resource type `R_j`.,Thread `T_j` is requesting `k` instances of resource type `R_i`.,Thread `T_i` has released `k` instances of resource type `R_j`.,C,`Request[i][j] = k` means thread `T_i` requests `k` more instances of resource type `R_j`.
"According to the deadlock detection algorithm for several instances of a resource type, what is the initial assignment for the 'Work' vector?",It is set to zero for all resource types.,It is set equal to the 'Allocation' matrix for the first thread.,It is initialized with the 'Available' vector.,It is set to the 'Request' matrix for all threads.,It is calculated as the sum of 'Allocation' and 'Request'.,C,Step 1 of the algorithm states: 'Initialize Work = Available'.
"In the deadlock detection algorithm for multiple resource instances, under what condition is `Finish[i]` initially set to `true` for a thread `T_i`?",If `T_i` has no pending requests (`Request_i == 0`).,If `T_i` has completed its execution.,If `T_i` has no resources allocated to it (`Allocation_i == 0`).,If `T_i` is currently blocked.,If `T_i` is part of a safe sequence.,C,"Step 1 states: 'If Allocation_i != 0, then Finish[i] = false. Otherwise (if Allocation_i == 0), Finish[i] = true'."
"What is the time complexity of the deadlock detection algorithm for several instances of a resource type, given 'n' threads and 'm' resource types?",O(n + m),O(n * m),O(m * n^2),O(n * m^2),O(n^3),C,The algorithm complexity is stated as O(m * n^2) operations.
The deadlock detection algorithm for multiple resource instances operates with an 'optimistic attitude'. What does this imply?,It assumes all resource requests will eventually be granted.,It assumes threads will voluntarily release resources if needed.,It assumes a thread `T_i` will complete and return its resources if `Request_i` is less than or equal to `Work`.,It prioritizes threads that have not yet requested any resources.,It optimistically allocates all requested resources immediately.,C,The 'optimistic attitude' is described as assuming `T_i` will complete and return resources if `Request_i <= Work`.
Consider the initial state described in the example for the 'several instances' detection algorithm. What is the claimed status of the system regarding deadlocks?,The system is definitely deadlocked.,"The system is not deadlocked, and a safe sequence exists.",The system is in an unsafe state but not necessarily deadlocked.,The system cannot determine its deadlock status without further requests.,Deadlock is pending for thread T4.,B,"The text states for the initial state: 'Initial claim: system not deadlocked. Sequence <T0, T2, T3, T1, T4> results in Finish[i] == true for all i.'"
"Referring to the example, if thread `T_2` requests 1 additional instance of resource C, what is the impact on the system's deadlock status?",The system remains not deadlocked.,The system enters a safe state.,"The system becomes deadlocked, involving threads `T_1, T_2, T_3, T_4`.",Only thread `T_2` becomes deadlocked.,The system enters a state where all resources are immediately available.,C,"The text states: 'New claim: system is deadlocked. Can reclaim T0's resources, but not enough for others. Deadlock involves T1, T2, T3, T4.'"
What are the two primary factors that determine when to invoke a deadlock detection algorithm?,System boot time and network latency.,Amount of free memory and disk space.,How often a deadlock is likely to occur and how many threads will be affected.,The operating system version and kernel type.,User login frequency and application usage.,C,The text lists 'How often is a deadlock likely to occur?' and 'How many threads will be affected by deadlock when it happens?' as the two factors.
What is a consequence of threads being involved in a deadlock cycle?,They consume minimal CPU resources.,Their allocated resources become idle.,They automatically release their resources after a timeout.,They switch to a low-power mode.,They enter a state of suspended animation indefinitely.,B,"Resources allocated to deadlocked threads become idle, and the number of threads in the deadlock cycle may grow."
What is a significant disadvantage of invoking the deadlock detection algorithm every time a resource request cannot be granted immediately?,It makes it harder to identify the 'causing' thread.,It might lead to false positives.,It results in high computational overhead.,It can only be used in single-resource-instance scenarios.,It delays the recovery process significantly.,C,"While this method identifies the 'causing' thread, it comes with 'High computational overhead'."
What is an advantage of invoking the deadlock detection algorithm every time a resource request cannot be granted immediately?,It is the least expensive invocation method.,It always prevents deadlocks from occurring.,It ensures that no resources ever become idle.,It identifies deadlocked threads and the specific thread that 'caused' the deadlock.,It works without maintaining any complex data structures.,D,Invoking the algorithm every time a request cannot be granted 'Identifies deadlocked threads and the specific thread that 'caused' the deadlock'.
"What is a potential drawback of invoking the deadlock detection algorithm only at defined intervals (e.g., hourly or when CPU utilization drops)?",It always incurs higher computational overhead than continuous invocation.,It may not identify the specific thread that 'caused' the deadlock.,It prevents any threads from entering a deadlocked state.,It requires manual intervention for recovery.,It can only detect deadlocks in single-instance resource systems.,B,A less expensive invocation at defined intervals 'May not identify the 'causing' thread'.
How do database systems primarily manage deadlocks?,By preventing them through strict resource ordering.,By avoiding them using the Banker's algorithm.,By using deadlock detection and recovery mechanisms.,By requiring manual intervention from a database administrator.,By limiting the number of concurrent transactions.,C,Database systems manage deadlock using detection and recovery.
"In database systems, what are updates often referred to as, which utilize locks for data integrity and can lead to deadlocks?",Processes,Operations,Transactions,Queries,Sessions,C,"Updates are referred to as 'transactions' in database systems, which use locks and can lead to deadlocks."
How does a database server typically detect deadlocks?,By performing a full system reboot.,By monitoring individual lock acquisition times.,By periodically searching for cycles in the wait-for graph.,By checking for excessive memory usage.,By requiring manual deadlock checks by developers.,C,The database server periodically searches for cycles in the wait-for graph to detect deadlocks.
"When a deadlock is detected in a database system, what is the initial step taken for recovery?",All transactions are immediately aborted.,A victim transaction is selected.,New locks are granted to all waiting transactions.,The database server pauses all operations.,An error message is logged without further action.,B,"When a deadlock is detected, the first step is that 'A victim transaction is selected'."
What happens immediately to a victim transaction chosen during database deadlock recovery?,It is prioritized for resource allocation.,It is suspended until resources become available.,"It is aborted and rolled back, releasing its locks.",It is forced to release only a portion of its locks.,It is moved to a lower priority queue.,C,"The victim transaction is aborted and rolled back, releasing its locks."
"After a victim transaction is aborted and rolled back in a database deadlock scenario, what is the outcome for the remaining transactions involved in the deadlock?",They also get aborted automatically.,They remain in a deadlocked state.,They are freed from deadlock.,They must restart from the beginning.,They acquire new locks from other transactions.,C,"After the victim is aborted and rolled back, the 'Remaining transactions are freed from deadlock'."
What happens to a transaction that has been aborted and rolled back as a victim of a database deadlock?,It is permanently discarded.,It is reissued to execute again.,It enters a waiting state indefinitely.,It converts into a read-only transaction.,It requires manual re-entry by the user.,B,The aborted transaction is reissued.
Which criterion might MySQL use when selecting a victim transaction during database deadlock recovery?,The transaction that has been running the longest.,The transaction that holds the most locks.,"The transaction that has inserted, updated, or deleted the minimum number of rows.",The transaction that requested the lock first.,The transaction that is least likely to succeed.,C,"MySQL, for example, minimizes rows inserted, updated, or deleted when choosing a victim."
"According to the provided glossary, which statement accurately defines a 'wait-for graph'?",A graph showing the order in which threads acquire resources.,"A variant of the resource-allocation graph with resource nodes removed, indicating a deadlock if the graph contains a cycle.",A graph used exclusively for preventing deadlocks in real-time systems.,A tool for visualizing the dependencies between different processes.,A network diagram illustrating communication between servers.,B,"The glossary defines a 'wait-for graph' as 'In deadlock detection, a variant of the resource-allocation graph with resource nodes removed; indicates a deadlock if the graph contains a cycle.'"
"What is the primary purpose of a 'thread dump' in Java, according to the glossary?",To optimize garbage collection performance.,"To provide a snapshot of all thread states for debugging, especially deadlocks.",To reallocate memory efficiently among threads.,To terminate unresponsive threads.,To log network activity of an application.,B,The glossary states 'thread dump' is 'a snapshot of the state of all threads in an application; a useful debugging tool for deadlocks.'
